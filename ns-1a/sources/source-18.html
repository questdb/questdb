


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > SqlCodeGenerator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/highlight-idea.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.questdb.griffin</a>
</div>

<h1>Coverage Summary for Class: SqlCodeGenerator (io.questdb.griffin)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SqlCodeGenerator</td>
<td class="coverageStat">
  <span class="percent">
    98.7%
  </span>
  <span class="absValue">
    (76/77)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.3%
  </span>
  <span class="absValue">
    (1779/1886)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SqlCodeGenerator$FullFatJoinGenerator</td>
  </tr>
  <tr>
    <td class="name">SqlCodeGenerator$ModelOperator</td>
  </tr>
  <tr>
    <td class="name">SqlCodeGenerator$RecordCursorFactoryStub</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (10/15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (79/83)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (1789/1901)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<div class="sourceCode" id="sourceCode"><i class="no-highlight">1</i>&nbsp;/*******************************************************************************
<i class="no-highlight">2</i>&nbsp; *     ___                  _   ____  ____
<i class="no-highlight">3</i>&nbsp; *    / _ \ _   _  ___  ___| |_|  _ \| __ )
<i class="no-highlight">4</i>&nbsp; *   | | | | | | |/ _ \/ __| __| | | |  _ \
<i class="no-highlight">5</i>&nbsp; *   | |_| | |_| |  __/\__ \ |_| |_| | |_) |
<i class="no-highlight">6</i>&nbsp; *    \__\_\\__,_|\___||___/\__|____/|____/
<i class="no-highlight">7</i>&nbsp; *
<i class="no-highlight">8</i>&nbsp; *  Copyright (c) 2014-2019 Appsicle
<i class="no-highlight">9</i>&nbsp; *  Copyright (c) 2019-2022 QuestDB
<i class="no-highlight">10</i>&nbsp; *
<i class="no-highlight">11</i>&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<i class="no-highlight">12</i>&nbsp; *  you may not use this file except in compliance with the License.
<i class="no-highlight">13</i>&nbsp; *  You may obtain a copy of the License at
<i class="no-highlight">14</i>&nbsp; *
<i class="no-highlight">15</i>&nbsp; *  http://www.apache.org/licenses/LICENSE-2.0
<i class="no-highlight">16</i>&nbsp; *
<i class="no-highlight">17</i>&nbsp; *  Unless required by applicable law or agreed to in writing, software
<i class="no-highlight">18</i>&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i class="no-highlight">19</i>&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i class="no-highlight">20</i>&nbsp; *  See the License for the specific language governing permissions and
<i class="no-highlight">21</i>&nbsp; *  limitations under the License.
<i class="no-highlight">22</i>&nbsp; *
<i class="no-highlight">23</i>&nbsp; ******************************************************************************/
<i class="no-highlight">24</i>&nbsp;
<i class="no-highlight">25</i>&nbsp;package io.questdb.griffin;
<i class="no-highlight">26</i>&nbsp;
<i class="no-highlight">27</i>&nbsp;import io.questdb.cairo.*;
<i class="no-highlight">28</i>&nbsp;import io.questdb.cairo.map.RecordValueSink;
<i class="no-highlight">29</i>&nbsp;import io.questdb.cairo.map.RecordValueSinkFactory;
<i class="no-highlight">30</i>&nbsp;import io.questdb.cairo.sql.Record;
<i class="no-highlight">31</i>&nbsp;import io.questdb.cairo.sql.*;
<i class="no-highlight">32</i>&nbsp;import io.questdb.cairo.sql.async.PageFrameReduceTask;
<i class="no-highlight">33</i>&nbsp;import io.questdb.cairo.vm.Vm;
<i class="no-highlight">34</i>&nbsp;import io.questdb.cairo.vm.api.MemoryCARW;
<i class="no-highlight">35</i>&nbsp;import io.questdb.griffin.engine.*;
<i class="no-highlight">36</i>&nbsp;import io.questdb.griffin.engine.analytic.AnalyticFunction;
<i class="no-highlight">37</i>&nbsp;import io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory;
<i class="no-highlight">38</i>&nbsp;import io.questdb.griffin.engine.functions.GroupByFunction;
<i class="no-highlight">39</i>&nbsp;import io.questdb.griffin.engine.functions.SymbolFunction;
<i class="no-highlight">40</i>&nbsp;import io.questdb.griffin.engine.functions.bind.IndexedParameterLinkFunction;
<i class="no-highlight">41</i>&nbsp;import io.questdb.griffin.engine.functions.bind.NamedParameterLinkFunction;
<i class="no-highlight">42</i>&nbsp;import io.questdb.griffin.engine.functions.cast.*;
<i class="no-highlight">43</i>&nbsp;import io.questdb.griffin.engine.functions.columns.*;
<i class="no-highlight">44</i>&nbsp;import io.questdb.griffin.engine.functions.constants.*;
<i class="no-highlight">45</i>&nbsp;import io.questdb.griffin.engine.groupby.*;
<i class="no-highlight">46</i>&nbsp;import io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory;
<i class="no-highlight">47</i>&nbsp;import io.questdb.griffin.engine.groupby.vect.*;
<i class="no-highlight">48</i>&nbsp;import io.questdb.griffin.engine.join.*;
<i class="no-highlight">49</i>&nbsp;import io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory;
<i class="no-highlight">50</i>&nbsp;import io.questdb.griffin.engine.orderby.RecordComparatorCompiler;
<i class="no-highlight">51</i>&nbsp;import io.questdb.griffin.engine.orderby.SortedLightRecordCursorFactory;
<i class="no-highlight">52</i>&nbsp;import io.questdb.griffin.engine.orderby.SortedRecordCursorFactory;
<i class="no-highlight">53</i>&nbsp;import io.questdb.griffin.engine.table.*;
<i class="no-highlight">54</i>&nbsp;import io.questdb.griffin.engine.union.*;
<i class="no-highlight">55</i>&nbsp;import io.questdb.griffin.model.*;
<i class="no-highlight">56</i>&nbsp;import io.questdb.jit.CompiledFilter;
<i class="no-highlight">57</i>&nbsp;import io.questdb.jit.CompiledFilterIRSerializer;
<i class="no-highlight">58</i>&nbsp;import io.questdb.jit.JitUtil;
<i class="no-highlight">59</i>&nbsp;import io.questdb.log.Log;
<i class="no-highlight">60</i>&nbsp;import io.questdb.log.LogFactory;
<i class="no-highlight">61</i>&nbsp;import io.questdb.std.*;
<i class="no-highlight">62</i>&nbsp;import org.jetbrains.annotations.NotNull;
<i class="no-highlight">63</i>&nbsp;import org.jetbrains.annotations.Nullable;
<i class="no-highlight">64</i>&nbsp;
<i class="no-highlight">65</i>&nbsp;import java.io.Closeable;
<i class="no-highlight">66</i>&nbsp;import java.util.ArrayDeque;
<i class="no-highlight">67</i>&nbsp;
<i class="no-highlight">68</i>&nbsp;import static io.questdb.cairo.sql.DataFrameCursorFactory.ORDER_ANY;
<i class="no-highlight">69</i>&nbsp;import static io.questdb.griffin.SqlKeywords.*;
<i class="no-highlight">70</i>&nbsp;import static io.questdb.griffin.model.ExpressionNode.FUNCTION;
<i class="no-highlight">71</i>&nbsp;import static io.questdb.griffin.model.ExpressionNode.LITERAL;
<i class="no-highlight">72</i>&nbsp;import static io.questdb.griffin.model.ExpressionNode.CONSTANT;
<i class="no-highlight">73</i>&nbsp;import static io.questdb.griffin.model.QueryModel.*;
<i class="no-highlight">74</i>&nbsp;
<b class="fc"><i class="no-highlight">75</i>&nbsp;public class SqlCodeGenerator implements Mutable, Closeable {</b>
<i class="no-highlight">76</i>&nbsp;    public static final int GKK_HOUR_INT = 1;
<i class="no-highlight">77</i>&nbsp;    public static final int GKK_VANILLA_INT = 0;
<b class="fc"><i class="no-highlight">78</i>&nbsp;    private static final ModelOperator BACKUP_WHERE_CLAUSE = QueryModel::backupWhereClause;</b>
<b class="fc"><i class="no-highlight">79</i>&nbsp;    private static final VectorAggregateFunctionConstructor COUNT_CONSTRUCTOR = (keyKind, columnIndex, workerCount) -&gt; new CountVectorAggregateFunction(keyKind);</b>
<b class="fc"><i class="no-highlight">80</i>&nbsp;    private static final FullFatJoinGenerator CREATE_FULL_FAT_AS_OF_JOIN = SqlCodeGenerator::createFullFatAsOfJoin;</b>
<b class="fc"><i class="no-highlight">81</i>&nbsp;    private static final FullFatJoinGenerator CREATE_FULL_FAT_LT_JOIN = SqlCodeGenerator::createFullFatLtJoin;</b>
<b class="fc"><i class="no-highlight">82</i>&nbsp;    private static final Log LOG = LogFactory.getLog(SqlCodeGenerator.class);</b>
<b class="fc"><i class="no-highlight">83</i>&nbsp;    private static final ModelOperator RESTORE_WHERE_CLAUSE = QueryModel::restoreWhereClause;</b>
<b class="fc"><i class="no-highlight">84</i>&nbsp;    private static final SetRecordCursorFactoryConstructor SET_EXCEPT_CONSTRUCTOR = ExceptRecordCursorFactory::new;</b>
<b class="fc"><i class="no-highlight">85</i>&nbsp;    private static final SetRecordCursorFactoryConstructor SET_INTERSECT_CONSTRUCTOR = IntersectRecordCursorFactory::new;</b>
<b class="fc"><i class="no-highlight">86</i>&nbsp;    private static final SetRecordCursorFactoryConstructor SET_UNION_CONSTRUCTOR = UnionRecordCursorFactory::new;</b>
<b class="fc"><i class="no-highlight">87</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; avgConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">88</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; countConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">89</i>&nbsp;    private static final boolean[] joinsRequiringTimestamp = new boolean[JOIN_MAX + 1];</b>
<b class="fc"><i class="no-highlight">90</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; ksumConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">91</i>&nbsp;    private static final IntHashSet limitTypes = new IntHashSet();</b>
<b class="fc"><i class="no-highlight">92</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; maxConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">93</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; minConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">94</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; nsumConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">95</i>&nbsp;    private static final IntObjHashMap&lt;VectorAggregateFunctionConstructor&gt; sumConstructors = new IntObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">96</i>&nbsp;    private final ArrayColumnTypes arrayColumnTypes = new ArrayColumnTypes();</b>
<b class="fc"><i class="no-highlight">97</i>&nbsp;    private final BytecodeAssembler asm = new BytecodeAssembler();</b>
<i class="no-highlight">98</i>&nbsp;    private final CairoConfiguration configuration;
<b class="fc"><i class="no-highlight">99</i>&nbsp;    private final ObjList&lt;TableColumnMetadata&gt; deferredAnalyticMetadata = new ObjList&lt;&gt;();</b>
<i class="no-highlight">100</i>&nbsp;    private final boolean enableJitDebug;
<i class="no-highlight">101</i>&nbsp;    private final CairoEngine engine;
<b class="fc"><i class="no-highlight">102</i>&nbsp;    private final EntityColumnFilter entityColumnFilter = new EntityColumnFilter();</b>
<i class="no-highlight">103</i>&nbsp;    private final ObjectPool&lt;ExpressionNode&gt; expressionNodePool;
<i class="no-highlight">104</i>&nbsp;    private final FunctionParser functionParser;
<b class="fc"><i class="no-highlight">105</i>&nbsp;    private final IntList groupByFunctionPositions = new IntList();</b>
<b class="fc"><i class="no-highlight">106</i>&nbsp;    private final ObjObjHashMap&lt;IntList, ObjList&lt;AnalyticFunction&gt;&gt; groupedAnalytic = new ObjObjHashMap&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">107</i>&nbsp;    private final IntHashSet intHashSet = new IntHashSet();</b>
<b class="fc"><i class="no-highlight">108</i>&nbsp;    private final ObjectPool&lt;IntList&gt; intListPool = new ObjectPool&lt;&gt;(IntList::new, 4);</b>
<i class="no-highlight">109</i>&nbsp;    private final MemoryCARW jitIRMem;
<b class="fc"><i class="no-highlight">110</i>&nbsp;    private final CompiledFilterIRSerializer jitIRSerializer = new CompiledFilterIRSerializer();</b>
<b class="fc"><i class="no-highlight">111</i>&nbsp;    private final ArrayColumnTypes keyTypes = new ArrayColumnTypes();</b>
<i class="no-highlight">112</i>&nbsp;    // this list is used to generate record sinks
<b class="fc"><i class="no-highlight">113</i>&nbsp;    private final ListColumnFilter listColumnFilterA = new ListColumnFilter();</b>
<b class="fc"><i class="no-highlight">114</i>&nbsp;    private final ListColumnFilter listColumnFilterB = new ListColumnFilter();</b>
<b class="fc"><i class="no-highlight">115</i>&nbsp;    private final LongList prefixes = new LongList();</b>
<i class="no-highlight">116</i>&nbsp;    private final RecordComparatorCompiler recordComparatorCompiler;
<b class="fc"><i class="no-highlight">117</i>&nbsp;    private final IntList recordFunctionPositions = new IntList();</b>
<i class="no-highlight">118</i>&nbsp;    private final WeakClosableObjectPool&lt;PageFrameReduceTask&gt; reduceTaskPool;
<i class="no-highlight">119</i>&nbsp;
<b class="fc"><i class="no-highlight">120</i>&nbsp;    private final ArrayDeque&lt;ExpressionNode&gt; sqlNodeStack = new ArrayDeque&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">121</i>&nbsp;    private final WhereClauseSymbolEstimator symbolEstimator = new WhereClauseSymbolEstimator();</b>
<b class="fc"><i class="no-highlight">122</i>&nbsp;    private final IntList tempAggIndex = new IntList();</b>
<b class="fc"><i class="no-highlight">123</i>&nbsp;    private final IntList tempKeyIndex = new IntList();</b>
<b class="fc"><i class="no-highlight">124</i>&nbsp;    private final IntList tempKeyIndexesInBase = new IntList();</b>
<b class="fc"><i class="no-highlight">125</i>&nbsp;    private final IntList tempKeyKinds = new IntList();</b>
<b class="fc"><i class="no-highlight">126</i>&nbsp;    private final GenericRecordMetadata tempMetadata = new GenericRecordMetadata();</b>
<b class="fc"><i class="no-highlight">127</i>&nbsp;    private final IntList tempSymbolSkewIndexes = new IntList();</b>
<b class="fc"><i class="no-highlight">128</i>&nbsp;    private final ObjList&lt;VectorAggregateFunction&gt; tempVaf = new ObjList&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">129</i>&nbsp;    private final IntList tempVecConstructorArgIndexes = new IntList();</b>
<b class="fc"><i class="no-highlight">130</i>&nbsp;    private final ObjList&lt;VectorAggregateFunctionConstructor&gt; tempVecConstructors = new ObjList&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">131</i>&nbsp;    private final ArrayColumnTypes valueTypes = new ArrayColumnTypes();</b>
<b class="fc"><i class="no-highlight">132</i>&nbsp;    private final WhereClauseParser whereClauseParser = new WhereClauseParser();</b>
<b class="fc"><i class="no-highlight">133</i>&nbsp;    private boolean enableJitNullChecks = true;</b>
<b class="fc"><i class="no-highlight">134</i>&nbsp;    private boolean fullFatJoins = false;</b>
<i class="no-highlight">135</i>&nbsp;
<i class="no-highlight">136</i>&nbsp;    public SqlCodeGenerator(
<i class="no-highlight">137</i>&nbsp;            CairoEngine engine,
<i class="no-highlight">138</i>&nbsp;            CairoConfiguration configuration,
<i class="no-highlight">139</i>&nbsp;            FunctionParser functionParser,
<i class="no-highlight">140</i>&nbsp;            ObjectPool&lt;ExpressionNode&gt; expressionNodePool
<b class="fc"><i class="no-highlight">141</i>&nbsp;    ) {</b>
<b class="fc"><i class="no-highlight">142</i>&nbsp;        this.engine = engine;</b>
<b class="fc"><i class="no-highlight">143</i>&nbsp;        this.configuration = configuration;</b>
<b class="fc"><i class="no-highlight">144</i>&nbsp;        this.functionParser = functionParser;</b>
<b class="fc"><i class="no-highlight">145</i>&nbsp;        this.recordComparatorCompiler = new RecordComparatorCompiler(asm);</b>
<b class="fc"><i class="no-highlight">146</i>&nbsp;        this.enableJitDebug = configuration.isSqlJitDebugEnabled();</b>
<b class="fc"><i class="no-highlight">147</i>&nbsp;        this.jitIRMem = Vm.getCARWInstance(configuration.getSqlJitIRMemoryPageSize(),</b>
<b class="fc"><i class="no-highlight">148</i>&nbsp;                configuration.getSqlJitIRMemoryMaxPages(), MemoryTag.NATIVE_JIT);</b>
<i class="no-highlight">149</i>&nbsp;        // Pre-touch JIT IR memory to avoid false positive memory leak detections.
<b class="fc"><i class="no-highlight">150</i>&nbsp;        jitIRMem.putByte((byte) 0);</b>
<b class="fc"><i class="no-highlight">151</i>&nbsp;        jitIRMem.truncate();</b>
<b class="fc"><i class="no-highlight">152</i>&nbsp;        this.expressionNodePool = expressionNodePool;</b>
<b class="fc"><i class="no-highlight">153</i>&nbsp;        this.reduceTaskPool = new WeakClosableObjectPool&lt;&gt;(</b>
<b class="fc"><i class="no-highlight">154</i>&nbsp;                () -&gt; new PageFrameReduceTask(configuration),</b>
<b class="fc"><i class="no-highlight">155</i>&nbsp;                configuration.getPageFrameReduceTaskPoolCapacity()</b>
<i class="no-highlight">156</i>&nbsp;        );
<i class="no-highlight">157</i>&nbsp;    }
<i class="no-highlight">158</i>&nbsp;
<i class="no-highlight">159</i>&nbsp;    @Override
<i class="no-highlight">160</i>&nbsp;    public void clear() {
<b class="fc"><i class="no-highlight">161</i>&nbsp;        whereClauseParser.clear();</b>
<b class="fc"><i class="no-highlight">162</i>&nbsp;        symbolEstimator.clear();</b>
<b class="fc"><i class="no-highlight">163</i>&nbsp;        intListPool.clear();</b>
<i class="no-highlight">164</i>&nbsp;    }
<i class="no-highlight">165</i>&nbsp;
<i class="no-highlight">166</i>&nbsp;    @Override
<i class="no-highlight">167</i>&nbsp;    public void close() {
<b class="fc"><i class="no-highlight">168</i>&nbsp;        Misc.free(jitIRMem);</b>
<b class="fc"><i class="no-highlight">169</i>&nbsp;        Misc.free(reduceTaskPool);</b>
<i class="no-highlight">170</i>&nbsp;    }
<i class="no-highlight">171</i>&nbsp;
<i class="no-highlight">172</i>&nbsp;    @NotNull
<i class="no-highlight">173</i>&nbsp;    public Function compileBooleanFilter(
<i class="no-highlight">174</i>&nbsp;            ExpressionNode expr,
<i class="no-highlight">175</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">176</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">177</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">178</i>&nbsp;        final Function filter = functionParser.parseFunction(expr, metadata, executionContext);</b>
<b class="fc"><i class="no-highlight">179</i>&nbsp;        if (ColumnType.isBoolean(filter.getType())) {</b>
<b class="fc"><i class="no-highlight">180</i>&nbsp;            return filter;</b>
<i class="no-highlight">181</i>&nbsp;        }
<b class="fc"><i class="no-highlight">182</i>&nbsp;        Misc.free(filter);</b>
<b class="fc"><i class="no-highlight">183</i>&nbsp;        throw SqlException.$(expr.position, &quot;boolean expression expected&quot;);</b>
<i class="no-highlight">184</i>&nbsp;    }
<i class="no-highlight">185</i>&nbsp;
<i class="no-highlight">186</i>&nbsp;    public RecordCursorFactory generate(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">187</i>&nbsp;        return generateQuery(model, executionContext, true);</b>
<i class="no-highlight">188</i>&nbsp;    }
<i class="no-highlight">189</i>&nbsp;
<i class="no-highlight">190</i>&nbsp;    public RecordCursorFactory generateExplain(QueryModel model, RecordCursorFactory factory, int format) {
<b class="fc"><i class="no-highlight">191</i>&nbsp;        RecordCursorFactory recordCursorFactory = new RecordCursorFactoryStub(model, factory);</b>
<b class="fc"><i class="no-highlight">192</i>&nbsp;        return new ExplainPlanFactory(recordCursorFactory, format);</b>
<i class="no-highlight">193</i>&nbsp;    }
<i class="no-highlight">194</i>&nbsp;
<i class="no-highlight">195</i>&nbsp;    public RecordCursorFactory generateExplain(ExplainModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">196</i>&nbsp;        ExecutionModel innerModel = model.getInnerExecutionModel();</b>
<b class="fc"><i class="no-highlight">197</i>&nbsp;        QueryModel queryModel = innerModel.getQueryModel();</b>
<i class="no-highlight">198</i>&nbsp;        RecordCursorFactory factory;
<b class="fc"><i class="no-highlight">199</i>&nbsp;        if (queryModel != null) {</b>
<b class="fc"><i class="no-highlight">200</i>&nbsp;            factory = generate(queryModel, executionContext);</b>
<b class="fc"><i class="no-highlight">201</i>&nbsp;            if (innerModel.getModelType() != QUERY) {</b>
<b class="fc"><i class="no-highlight">202</i>&nbsp;                factory = new RecordCursorFactoryStub(innerModel, factory);</b>
<i class="no-highlight">203</i>&nbsp;            }
<i class="no-highlight">204</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">205</i>&nbsp;            factory = new RecordCursorFactoryStub(innerModel, null);</b>
<i class="no-highlight">206</i>&nbsp;        }
<i class="no-highlight">207</i>&nbsp;
<b class="fc"><i class="no-highlight">208</i>&nbsp;        return new ExplainPlanFactory(factory, model.getFormat());</b>
<i class="no-highlight">209</i>&nbsp;    }
<i class="no-highlight">210</i>&nbsp;
<i class="no-highlight">211</i>&nbsp;    private static boolean allGroupsFirstLastWithSingleSymbolFilter(QueryModel model, RecordMetadata metadata) {
<b class="fc"><i class="no-highlight">212</i>&nbsp;        final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</b>
<b class="fc"><i class="no-highlight">213</i>&nbsp;        for (int i = 0, n = columns.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">214</i>&nbsp;            final QueryColumn column = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">215</i>&nbsp;            final ExpressionNode node = column.getAst();</b>
<i class="no-highlight">216</i>&nbsp;
<b class="fc"><i class="no-highlight">217</i>&nbsp;            if (node.type != ExpressionNode.LITERAL) {</b>
<b class="fc"><i class="no-highlight">218</i>&nbsp;                ExpressionNode columnAst = column.getAst();</b>
<b class="fc"><i class="no-highlight">219</i>&nbsp;                CharSequence token = columnAst.token;</b>
<b class="fc"><i class="no-highlight">220</i>&nbsp;                if (!SqlKeywords.isFirstKeyword(token) &amp;&amp; !SqlKeywords.isLastKeyword(token)) {</b>
<b class="fc"><i class="no-highlight">221</i>&nbsp;                    return false;</b>
<i class="no-highlight">222</i>&nbsp;                }
<i class="no-highlight">223</i>&nbsp;
<b class="fc"><i class="no-highlight">224</i>&nbsp;                if (columnAst.rhs.type != ExpressionNode.LITERAL || metadata.getColumnIndex(columnAst.rhs.token) &lt; 0) {</b>
<b class="fc"><i class="no-highlight">225</i>&nbsp;                    return false;</b>
<i class="no-highlight">226</i>&nbsp;                }
<i class="no-highlight">227</i>&nbsp;            }
<i class="no-highlight">228</i>&nbsp;        }
<i class="no-highlight">229</i>&nbsp;
<b class="fc"><i class="no-highlight">230</i>&nbsp;        return true;</b>
<i class="no-highlight">231</i>&nbsp;    }
<i class="no-highlight">232</i>&nbsp;
<i class="no-highlight">233</i>&nbsp;    private static RecordCursorFactory createFullFatAsOfJoin(CairoConfiguration configuration,
<i class="no-highlight">234</i>&nbsp;                                                             RecordMetadata metadata,
<i class="no-highlight">235</i>&nbsp;                                                             RecordCursorFactory masterFactory,
<i class="no-highlight">236</i>&nbsp;                                                             RecordCursorFactory slaveFactory,
<i class="no-highlight">237</i>&nbsp;                                                             @Transient ColumnTypes mapKeyTypes,
<i class="no-highlight">238</i>&nbsp;                                                             @Transient ColumnTypes mapValueTypes,
<i class="no-highlight">239</i>&nbsp;                                                             @Transient ColumnTypes slaveColumnTypes,
<i class="no-highlight">240</i>&nbsp;                                                             RecordSink masterKeySink,
<i class="no-highlight">241</i>&nbsp;                                                             RecordSink slaveKeySink,
<i class="no-highlight">242</i>&nbsp;                                                             int columnSplit,
<i class="no-highlight">243</i>&nbsp;                                                             RecordValueSink slaveValueSink,
<i class="no-highlight">244</i>&nbsp;                                                             IntList columnIndex,
<i class="no-highlight">245</i>&nbsp;                                                             JoinContext joinContext) {
<b class="fc"><i class="no-highlight">246</i>&nbsp;        return new AsOfJoinRecordCursorFactory(configuration, metadata, masterFactory, slaveFactory, mapKeyTypes, mapValueTypes, slaveColumnTypes, masterKeySink, slaveKeySink, columnSplit, slaveValueSink, columnIndex, joinContext);</b>
<i class="no-highlight">247</i>&nbsp;    }
<i class="no-highlight">248</i>&nbsp;
<i class="no-highlight">249</i>&nbsp;    private static RecordCursorFactory createFullFatLtJoin(CairoConfiguration configuration,
<i class="no-highlight">250</i>&nbsp;                                                           RecordMetadata metadata,
<i class="no-highlight">251</i>&nbsp;                                                           RecordCursorFactory masterFactory,
<i class="no-highlight">252</i>&nbsp;                                                           RecordCursorFactory slaveFactory,
<i class="no-highlight">253</i>&nbsp;                                                           @Transient ColumnTypes mapKeyTypes,
<i class="no-highlight">254</i>&nbsp;                                                           @Transient ColumnTypes mapValueTypes,
<i class="no-highlight">255</i>&nbsp;                                                           @Transient ColumnTypes slaveColumnTypes,
<i class="no-highlight">256</i>&nbsp;                                                           RecordSink masterKeySink,
<i class="no-highlight">257</i>&nbsp;                                                           RecordSink slaveKeySink,
<i class="no-highlight">258</i>&nbsp;                                                           int columnSplit,
<i class="no-highlight">259</i>&nbsp;                                                           RecordValueSink slaveValueSink,
<i class="no-highlight">260</i>&nbsp;                                                           IntList columnIndex,
<i class="no-highlight">261</i>&nbsp;                                                           JoinContext joinContext) {
<b class="fc"><i class="no-highlight">262</i>&nbsp;        return new LtJoinRecordCursorFactory(configuration, metadata, masterFactory, slaveFactory, mapKeyTypes, mapValueTypes, slaveColumnTypes, masterKeySink, slaveKeySink, columnSplit, slaveValueSink, columnIndex, joinContext);</b>
<i class="no-highlight">263</i>&nbsp;    }
<i class="no-highlight">264</i>&nbsp;
<i class="no-highlight">265</i>&nbsp;    private static int getOrderByDirectionOrDefault(QueryModel model, int index) {
<b class="fc"><i class="no-highlight">266</i>&nbsp;        IntList direction = model.getOrderByDirectionAdvice();</b>
<b class="fc"><i class="no-highlight">267</i>&nbsp;        if (index &gt;= direction.size()) {</b>
<b class="fc"><i class="no-highlight">268</i>&nbsp;            return ORDER_DIRECTION_ASCENDING;</b>
<i class="no-highlight">269</i>&nbsp;        }
<b class="fc"><i class="no-highlight">270</i>&nbsp;        return model.getOrderByDirectionAdvice().getQuick(index);</b>
<i class="no-highlight">271</i>&nbsp;    }
<i class="no-highlight">272</i>&nbsp;
<i class="no-highlight">273</i>&nbsp;    private VectorAggregateFunctionConstructor assembleFunctionReference(RecordMetadata metadata, ExpressionNode ast) {
<i class="no-highlight">274</i>&nbsp;        int columnIndex;
<b class="fc"><i class="no-highlight">275</i>&nbsp;        if (ast.type == FUNCTION &amp;&amp; ast.paramCount == 1 &amp;&amp; SqlKeywords.isSumKeyword(ast.token) &amp;&amp; ast.rhs.type == LITERAL) {</b>
<b class="fc"><i class="no-highlight">276</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">277</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">278</i>&nbsp;            return sumConstructors.get(metadata.getColumnType(columnIndex));</b>
<b class="fc"><i class="no-highlight">279</i>&nbsp;        } else if (ast.type == FUNCTION &amp;&amp; SqlKeywords.isCountKeyword(ast.token) &amp;&amp;</b>
<b class="fc"><i class="no-highlight">280</i>&nbsp;                (ast.paramCount == 0 || (ast.paramCount == 1 &amp;&amp; ast.rhs.type == CONSTANT &amp;&amp; !isNullKeyword(ast.rhs.token)))) {</b>
<i class="no-highlight">281</i>&nbsp;            // count() is a no-arg function, count(1) is the same as count(*)
<b class="fc"><i class="no-highlight">282</i>&nbsp;            tempVecConstructorArgIndexes.add(-1);</b>
<b class="fc"><i class="no-highlight">283</i>&nbsp;            return COUNT_CONSTRUCTOR;</b>
<b class="fc"><i class="no-highlight">284</i>&nbsp;        } else if (isSingleColumnFunction(ast, &quot;count&quot;)) {</b>
<b class="fc"><i class="no-highlight">285</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">286</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">287</i>&nbsp;            return countConstructors.get(metadata.getColumnType(columnIndex));</b>
<b class="fc"><i class="no-highlight">288</i>&nbsp;        } else if (isSingleColumnFunction(ast, &quot;ksum&quot;)) {</b>
<b class="fc"><i class="no-highlight">289</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">290</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">291</i>&nbsp;            return ksumConstructors.get(metadata.getColumnType(columnIndex));</b>
<b class="fc"><i class="no-highlight">292</i>&nbsp;        } else if (isSingleColumnFunction(ast, &quot;nsum&quot;)) {</b>
<b class="fc"><i class="no-highlight">293</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">294</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">295</i>&nbsp;            return nsumConstructors.get(metadata.getColumnType(columnIndex));</b>
<b class="fc"><i class="no-highlight">296</i>&nbsp;        } else if (isSingleColumnFunction(ast, &quot;avg&quot;)) {</b>
<b class="fc"><i class="no-highlight">297</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">298</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">299</i>&nbsp;            return avgConstructors.get(metadata.getColumnType(columnIndex));</b>
<b class="fc"><i class="no-highlight">300</i>&nbsp;        } else if (isSingleColumnFunction(ast, &quot;min&quot;)) {</b>
<b class="fc"><i class="no-highlight">301</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">302</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">303</i>&nbsp;            return minConstructors.get(metadata.getColumnType(columnIndex));</b>
<b class="fc"><i class="no-highlight">304</i>&nbsp;        } else if (isSingleColumnFunction(ast, &quot;max&quot;)) {</b>
<b class="fc"><i class="no-highlight">305</i>&nbsp;            columnIndex = metadata.getColumnIndex(ast.rhs.token);</b>
<b class="fc"><i class="no-highlight">306</i>&nbsp;            tempVecConstructorArgIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">307</i>&nbsp;            return maxConstructors.get(metadata.getColumnType(columnIndex));</b>
<i class="no-highlight">308</i>&nbsp;        }
<b class="fc"><i class="no-highlight">309</i>&nbsp;        return null;</b>
<i class="no-highlight">310</i>&nbsp;    }
<i class="no-highlight">311</i>&nbsp;
<i class="no-highlight">312</i>&nbsp;    private boolean assembleKeysAndFunctionReferences(
<i class="no-highlight">313</i>&nbsp;            ObjList&lt;QueryColumn&gt; columns,
<i class="no-highlight">314</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">315</i>&nbsp;            boolean checkLiterals
<i class="no-highlight">316</i>&nbsp;    ) {
<b class="fc"><i class="no-highlight">317</i>&nbsp;        tempVaf.clear();</b>
<b class="fc"><i class="no-highlight">318</i>&nbsp;        tempMetadata.clear();</b>
<b class="fc"><i class="no-highlight">319</i>&nbsp;        tempSymbolSkewIndexes.clear();</b>
<b class="fc"><i class="no-highlight">320</i>&nbsp;        tempVecConstructors.clear();</b>
<b class="fc"><i class="no-highlight">321</i>&nbsp;        tempVecConstructorArgIndexes.clear();</b>
<b class="fc"><i class="no-highlight">322</i>&nbsp;        tempAggIndex.clear();</b>
<i class="no-highlight">323</i>&nbsp;
<b class="fc"><i class="no-highlight">324</i>&nbsp;        for (int i = 0, n = columns.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">325</i>&nbsp;            final QueryColumn qc = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">326</i>&nbsp;            final ExpressionNode ast = qc.getAst();</b>
<b class="fc"><i class="no-highlight">327</i>&nbsp;            if (ast.type == LITERAL) {</b>
<b class="fc"><i class="no-highlight">328</i>&nbsp;                if (checkLiterals) {</b>
<b class="fc"><i class="no-highlight">329</i>&nbsp;                    final int columnIndex = metadata.getColumnIndex(ast.token);</b>
<b class="fc"><i class="no-highlight">330</i>&nbsp;                    final int type = metadata.getColumnType(columnIndex);</b>
<b class="fc"><i class="no-highlight">331</i>&nbsp;                    if (ColumnType.isInt(type)) {</b>
<b class="fc"><i class="no-highlight">332</i>&nbsp;                        tempKeyIndexesInBase.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">333</i>&nbsp;                        tempKeyIndex.add(i);</b>
<b class="fc"><i class="no-highlight">334</i>&nbsp;                        arrayColumnTypes.add(ColumnType.INT);</b>
<b class="fc"><i class="no-highlight">335</i>&nbsp;                        tempKeyKinds.add(GKK_VANILLA_INT);</b>
<b class="fc"><i class="no-highlight">336</i>&nbsp;                    } else if (ColumnType.isSymbol(type)) {</b>
<b class="fc"><i class="no-highlight">337</i>&nbsp;                        tempKeyIndexesInBase.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">338</i>&nbsp;                        tempKeyIndex.add(i);</b>
<b class="fc"><i class="no-highlight">339</i>&nbsp;                        tempSymbolSkewIndexes.extendAndSet(i, columnIndex);</b>
<b class="fc"><i class="no-highlight">340</i>&nbsp;                        arrayColumnTypes.add(ColumnType.SYMBOL);</b>
<b class="fc"><i class="no-highlight">341</i>&nbsp;                        tempKeyKinds.add(GKK_VANILLA_INT);</b>
<i class="no-highlight">342</i>&nbsp;                    } else {
<b class="fc"><i class="no-highlight">343</i>&nbsp;                        return false;</b>
<i class="no-highlight">344</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">345</i>&nbsp;                }</b>
<i class="no-highlight">346</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">347</i>&nbsp;                final VectorAggregateFunctionConstructor constructor = assembleFunctionReference(metadata, ast);</b>
<b class="fc"><i class="no-highlight">348</i>&nbsp;                if (constructor != null) {</b>
<b class="fc"><i class="no-highlight">349</i>&nbsp;                    tempVecConstructors.add(constructor);</b>
<b class="fc"><i class="no-highlight">350</i>&nbsp;                    tempAggIndex.add(i);</b>
<i class="no-highlight">351</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">352</i>&nbsp;                    return false;</b>
<i class="no-highlight">353</i>&nbsp;                }
<i class="no-highlight">354</i>&nbsp;            }
<i class="no-highlight">355</i>&nbsp;        }
<b class="fc"><i class="no-highlight">356</i>&nbsp;        return true;</b>
<i class="no-highlight">357</i>&nbsp;    }
<i class="no-highlight">358</i>&nbsp;
<i class="no-highlight">359</i>&nbsp;    private void backupWhereClause(ExpressionNode node) {
<b class="fc"><i class="no-highlight">360</i>&nbsp;        processNodeQueryModels(node, BACKUP_WHERE_CLAUSE);</b>
<i class="no-highlight">361</i>&nbsp;    }
<i class="no-highlight">362</i>&nbsp;
<i class="no-highlight">363</i>&nbsp;    // Check if lo, hi is set and lo &gt;=0 while hi &lt; 0 (meaning - return whole result set except some rows at start and some at the end)
<i class="no-highlight">364</i>&nbsp;    // because such case can&#39;t really be optimized by topN/bottomN
<i class="no-highlight">365</i>&nbsp;    private boolean canBeOptimized(QueryModel model, SqlExecutionContext context, Function loFunc, Function hiFunc) {
<b class="fc"><i class="no-highlight">366</i>&nbsp;        if (model.getLimitLo() == null &amp;&amp; model.getLimitHi() == null) {</b>
<b class="fc"><i class="no-highlight">367</i>&nbsp;            return false;</b>
<i class="no-highlight">368</i>&nbsp;        }
<i class="no-highlight">369</i>&nbsp;
<b class="fc"><i class="no-highlight">370</i>&nbsp;        if (loFunc != null &amp;&amp; loFunc.isConstant()</b>
<b class="fc"><i class="no-highlight">371</i>&nbsp;                &amp;&amp; hiFunc != null &amp;&amp; hiFunc.isConstant()) {</b>
<i class="no-highlight">372</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">373</i>&nbsp;                loFunc.init(null, context);</b>
<b class="fc"><i class="no-highlight">374</i>&nbsp;                hiFunc.init(null, context);</b>
<i class="no-highlight">375</i>&nbsp;
<b class="fc"><i class="no-highlight">376</i>&nbsp;                return !(loFunc.getLong(null) &gt;= 0 &amp;&amp; hiFunc.getLong(null) &lt; 0);</b>
<b class="nc"><i class="no-highlight">377</i>&nbsp;            } catch (SqlException ex) {</b>
<b class="nc"><i class="no-highlight">378</i>&nbsp;                LOG.error().$(&quot;Failed to initialize lo or hi functions [&quot;).$(&quot;error=&quot;).$(ex.getMessage()).I$();</b>
<i class="no-highlight">379</i>&nbsp;            }
<i class="no-highlight">380</i>&nbsp;        }
<i class="no-highlight">381</i>&nbsp;
<b class="fc"><i class="no-highlight">382</i>&nbsp;        return true;</b>
<i class="no-highlight">383</i>&nbsp;    }
<i class="no-highlight">384</i>&nbsp;
<i class="no-highlight">385</i>&nbsp;    private boolean checkIfSetCastIsRequired(RecordMetadata metadataA, RecordMetadata metadataB, boolean symbolDisallowed) {
<b class="fc"><i class="no-highlight">386</i>&nbsp;        int columnCount = metadataA.getColumnCount();</b>
<b class="fc"><i class="no-highlight">387</i>&nbsp;        assert columnCount == metadataB.getColumnCount();</b>
<i class="no-highlight">388</i>&nbsp;
<b class="fc"><i class="no-highlight">389</i>&nbsp;        for (int i = 0; i &lt; columnCount; i++) {</b>
<b class="fc"><i class="no-highlight">390</i>&nbsp;            int typeA = metadataA.getColumnType(i);</b>
<b class="fc"><i class="no-highlight">391</i>&nbsp;            int typeB = metadataB.getColumnType(i);</b>
<b class="fc"><i class="no-highlight">392</i>&nbsp;            if (typeA != typeB || (typeA == ColumnType.SYMBOL &amp;&amp; symbolDisallowed)) {</b>
<b class="fc"><i class="no-highlight">393</i>&nbsp;                return true;</b>
<i class="no-highlight">394</i>&nbsp;            }
<i class="no-highlight">395</i>&nbsp;        }
<b class="fc"><i class="no-highlight">396</i>&nbsp;        return false;</b>
<i class="no-highlight">397</i>&nbsp;    }
<i class="no-highlight">398</i>&nbsp;
<i class="no-highlight">399</i>&nbsp;    @Nullable
<i class="no-highlight">400</i>&nbsp;    private Function compileFilter(
<i class="no-highlight">401</i>&nbsp;            IntrinsicModel intrinsicModel,
<i class="no-highlight">402</i>&nbsp;            RecordMetadata readerMeta,
<i class="no-highlight">403</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">404</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">405</i>&nbsp;        if (intrinsicModel.filter != null) {</b>
<b class="fc"><i class="no-highlight">406</i>&nbsp;            return compileBooleanFilter(intrinsicModel.filter, readerMeta, executionContext);</b>
<i class="no-highlight">407</i>&nbsp;        }
<b class="fc"><i class="no-highlight">408</i>&nbsp;        return null;</b>
<i class="no-highlight">409</i>&nbsp;    }
<i class="no-highlight">410</i>&nbsp;
<i class="no-highlight">411</i>&nbsp;    private @Nullable ObjList&lt;Function&gt; compileWorkerFilterConditionally(
<i class="no-highlight">412</i>&nbsp;            boolean condition,
<i class="no-highlight">413</i>&nbsp;            int workerCount,
<i class="no-highlight">414</i>&nbsp;            ExpressionNode filterExpr,
<i class="no-highlight">415</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">416</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">417</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">418</i>&nbsp;        if (condition) {</b>
<b class="fc"><i class="no-highlight">419</i>&nbsp;            ObjList&lt;Function&gt; workerFilters = new ObjList&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">420</i>&nbsp;            for (int i = 0; i &lt; workerCount; i++) {</b>
<b class="fc"><i class="no-highlight">421</i>&nbsp;                restoreWhereClause(filterExpr);//restore original filters in node query models</b>
<b class="fc"><i class="no-highlight">422</i>&nbsp;                workerFilters.extendAndSet(i, compileBooleanFilter(filterExpr, metadata, executionContext));</b>
<i class="no-highlight">423</i>&nbsp;            }
<b class="fc"><i class="no-highlight">424</i>&nbsp;            return workerFilters;</b>
<i class="no-highlight">425</i>&nbsp;        }
<b class="fc"><i class="no-highlight">426</i>&nbsp;        return null;</b>
<i class="no-highlight">427</i>&nbsp;    }
<i class="no-highlight">428</i>&nbsp;
<i class="no-highlight">429</i>&nbsp;    private RecordCursorFactory createAsOfJoin(
<i class="no-highlight">430</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">431</i>&nbsp;            RecordCursorFactory master,
<i class="no-highlight">432</i>&nbsp;            RecordSink masterKeySink,
<i class="no-highlight">433</i>&nbsp;            RecordCursorFactory slave,
<i class="no-highlight">434</i>&nbsp;            RecordSink slaveKeySink,
<i class="no-highlight">435</i>&nbsp;            int columnSplit,
<i class="no-highlight">436</i>&nbsp;            JoinContext joinContext
<i class="no-highlight">437</i>&nbsp;    ) {
<b class="fc"><i class="no-highlight">438</i>&nbsp;        valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">439</i>&nbsp;        valueTypes.add(ColumnType.LONG);</b>
<b class="fc"><i class="no-highlight">440</i>&nbsp;        valueTypes.add(ColumnType.LONG);</b>
<i class="no-highlight">441</i>&nbsp;
<b class="fc"><i class="no-highlight">442</i>&nbsp;        return new AsOfJoinLightRecordCursorFactory(</b>
<i class="no-highlight">443</i>&nbsp;                configuration,
<i class="no-highlight">444</i>&nbsp;                metadata,
<i class="no-highlight">445</i>&nbsp;                master,
<i class="no-highlight">446</i>&nbsp;                slave,
<i class="no-highlight">447</i>&nbsp;                keyTypes,
<i class="no-highlight">448</i>&nbsp;                valueTypes,
<i class="no-highlight">449</i>&nbsp;                masterKeySink,
<i class="no-highlight">450</i>&nbsp;                slaveKeySink,
<i class="no-highlight">451</i>&nbsp;                columnSplit,
<i class="no-highlight">452</i>&nbsp;                joinContext
<i class="no-highlight">453</i>&nbsp;        );
<i class="no-highlight">454</i>&nbsp;    }
<i class="no-highlight">455</i>&nbsp;
<i class="no-highlight">456</i>&nbsp;    @NotNull
<i class="no-highlight">457</i>&nbsp;    private RecordCursorFactory createFullFatJoin(
<i class="no-highlight">458</i>&nbsp;            RecordCursorFactory master,
<i class="no-highlight">459</i>&nbsp;            RecordMetadata masterMetadata,
<i class="no-highlight">460</i>&nbsp;            CharSequence masterAlias,
<i class="no-highlight">461</i>&nbsp;            RecordCursorFactory slave,
<i class="no-highlight">462</i>&nbsp;            RecordMetadata slaveMetadata,
<i class="no-highlight">463</i>&nbsp;            CharSequence slaveAlias,
<i class="no-highlight">464</i>&nbsp;            int joinPosition,
<i class="no-highlight">465</i>&nbsp;            FullFatJoinGenerator generator,
<i class="no-highlight">466</i>&nbsp;            JoinContext joinContext
<i class="no-highlight">467</i>&nbsp;    ) throws SqlException {
<i class="no-highlight">468</i>&nbsp;
<i class="no-highlight">469</i>&nbsp;        // create hash set of key columns to easily find them
<b class="fc"><i class="no-highlight">470</i>&nbsp;        intHashSet.clear();</b>
<b class="fc"><i class="no-highlight">471</i>&nbsp;        for (int i = 0, n = listColumnFilterA.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">472</i>&nbsp;            intHashSet.add(listColumnFilterA.getColumnIndexFactored(i));</b>
<i class="no-highlight">473</i>&nbsp;        }
<i class="no-highlight">474</i>&nbsp;
<i class="no-highlight">475</i>&nbsp;        // map doesn&#39;t support variable length types in map value, which is ok
<i class="no-highlight">476</i>&nbsp;        // when we join tables on strings - technically string is the key,
<i class="no-highlight">477</i>&nbsp;        // and we do not need to store it in value, but we will still reject
<i class="no-highlight">478</i>&nbsp;        //
<i class="no-highlight">479</i>&nbsp;        // never mind, this is a stop-gap measure until I understand the problem
<i class="no-highlight">480</i>&nbsp;        // fully
<i class="no-highlight">481</i>&nbsp;
<b class="fc"><i class="no-highlight">482</i>&nbsp;        for (int k = 0, m = slaveMetadata.getColumnCount(); k &lt; m; k++) {</b>
<b class="fc"><i class="no-highlight">483</i>&nbsp;            if (intHashSet.excludes(k)) {</b>
<b class="fc"><i class="no-highlight">484</i>&nbsp;                if (ColumnType.isVariableLength(slaveMetadata.getColumnType(k))) {</b>
<b class="fc"><i class="no-highlight">485</i>&nbsp;                    throw SqlException</b>
<b class="fc"><i class="no-highlight">486</i>&nbsp;                            .position(joinPosition).put(&quot;right side column &#39;&quot;)</b>
<b class="fc"><i class="no-highlight">487</i>&nbsp;                            .put(slaveMetadata.getColumnName(k)).put(&quot;&#39; is of unsupported type&quot;);</b>
<i class="no-highlight">488</i>&nbsp;                }
<i class="no-highlight">489</i>&nbsp;            }
<i class="no-highlight">490</i>&nbsp;        }
<i class="no-highlight">491</i>&nbsp;
<b class="fc"><i class="no-highlight">492</i>&nbsp;        RecordSink masterSink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">493</i>&nbsp;                asm,
<i class="no-highlight">494</i>&nbsp;                masterMetadata,
<i class="no-highlight">495</i>&nbsp;                listColumnFilterB,
<i class="no-highlight">496</i>&nbsp;                true
<i class="no-highlight">497</i>&nbsp;        );
<i class="no-highlight">498</i>&nbsp;
<i class="no-highlight">499</i>&nbsp;        // This metadata allocates native memory, it has to be closed in case join
<i class="no-highlight">500</i>&nbsp;        // generation is unsuccessful. The exception can be thrown anywhere between
<i class="no-highlight">501</i>&nbsp;        // try...catch
<b class="fc"><i class="no-highlight">502</i>&nbsp;        JoinRecordMetadata metadata = new JoinRecordMetadata(</b>
<i class="no-highlight">503</i>&nbsp;                configuration,
<b class="fc"><i class="no-highlight">504</i>&nbsp;                masterMetadata.getColumnCount() + slaveMetadata.getColumnCount()</b>
<i class="no-highlight">505</i>&nbsp;        );
<i class="no-highlight">506</i>&nbsp;
<i class="no-highlight">507</i>&nbsp;        try {
<i class="no-highlight">508</i>&nbsp;
<i class="no-highlight">509</i>&nbsp;            // metadata will have master record verbatim
<b class="fc"><i class="no-highlight">510</i>&nbsp;            metadata.copyColumnMetadataFrom(masterAlias, masterMetadata);</b>
<i class="no-highlight">511</i>&nbsp;
<i class="no-highlight">512</i>&nbsp;            // slave record is split across key and value of map
<i class="no-highlight">513</i>&nbsp;            // the rationale is not to store columns twice
<i class="no-highlight">514</i>&nbsp;            // especially when map value does not support variable
<i class="no-highlight">515</i>&nbsp;            // length types
<i class="no-highlight">516</i>&nbsp;
<i class="no-highlight">517</i>&nbsp;
<b class="fc"><i class="no-highlight">518</i>&nbsp;            final IntList columnIndex = new IntList(slaveMetadata.getColumnCount());</b>
<i class="no-highlight">519</i>&nbsp;            // In map record value columns go first, so at this stage
<i class="no-highlight">520</i>&nbsp;            // we add to metadata all slave columns that are not keys.
<i class="no-highlight">521</i>&nbsp;            // Add same columns to filter while we are in this loop.
<b class="fc"><i class="no-highlight">522</i>&nbsp;            listColumnFilterB.clear();</b>
<b class="fc"><i class="no-highlight">523</i>&nbsp;            valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">524</i>&nbsp;            ArrayColumnTypes slaveTypes = new ArrayColumnTypes();</b>
<b class="fc"><i class="no-highlight">525</i>&nbsp;            if (slaveMetadata instanceof AbstractRecordMetadata) {</b>
<b class="fc"><i class="no-highlight">526</i>&nbsp;                for (int i = 0, n = slaveMetadata.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">527</i>&nbsp;                    if (intHashSet.excludes(i)) {</b>
<b class="fc"><i class="no-highlight">528</i>&nbsp;                        final TableColumnMetadata m = ((AbstractRecordMetadata) slaveMetadata).getColumnMetadata(i);</b>
<b class="fc"><i class="no-highlight">529</i>&nbsp;                        metadata.add(slaveAlias, m);</b>
<b class="fc"><i class="no-highlight">530</i>&nbsp;                        listColumnFilterB.add(i + 1);</b>
<b class="fc"><i class="no-highlight">531</i>&nbsp;                        columnIndex.add(i);</b>
<b class="fc"><i class="no-highlight">532</i>&nbsp;                        valueTypes.add(m.getType());</b>
<b class="fc"><i class="no-highlight">533</i>&nbsp;                        slaveTypes.add(m.getType());</b>
<i class="no-highlight">534</i>&nbsp;                    }
<i class="no-highlight">535</i>&nbsp;                }
<i class="no-highlight">536</i>&nbsp;
<i class="no-highlight">537</i>&nbsp;                // now add key columns to metadata
<b class="fc"><i class="no-highlight">538</i>&nbsp;                for (int i = 0, n = listColumnFilterA.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">539</i>&nbsp;                    int index = listColumnFilterA.getColumnIndexFactored(i);</b>
<b class="fc"><i class="no-highlight">540</i>&nbsp;                    final TableColumnMetadata m = ((AbstractRecordMetadata) slaveMetadata).getColumnMetadata(index);</b>
<b class="fc"><i class="no-highlight">541</i>&nbsp;                    if (ColumnType.isSymbol(m.getType())) {</b>
<b class="fc"><i class="no-highlight">542</i>&nbsp;                        metadata.add(</b>
<i class="no-highlight">543</i>&nbsp;                                slaveAlias,
<b class="fc"><i class="no-highlight">544</i>&nbsp;                                m.getName(),</b>
<i class="no-highlight">545</i>&nbsp;                                ColumnType.STRING,
<i class="no-highlight">546</i>&nbsp;                                false,
<i class="no-highlight">547</i>&nbsp;                                0,
<i class="no-highlight">548</i>&nbsp;                                false,
<i class="no-highlight">549</i>&nbsp;                                null
<i class="no-highlight">550</i>&nbsp;                        );
<b class="fc"><i class="no-highlight">551</i>&nbsp;                        slaveTypes.add(ColumnType.STRING);</b>
<i class="no-highlight">552</i>&nbsp;                    } else {
<b class="fc"><i class="no-highlight">553</i>&nbsp;                        metadata.add(slaveAlias, m);</b>
<b class="fc"><i class="no-highlight">554</i>&nbsp;                        slaveTypes.add(m.getType());</b>
<i class="no-highlight">555</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">556</i>&nbsp;                    columnIndex.add(index);</b>
<i class="no-highlight">557</i>&nbsp;                }
<i class="no-highlight">558</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">559</i>&nbsp;                for (int i = 0, n = slaveMetadata.getColumnCount(); i &lt; n; i++) {</b>
<b class="nc"><i class="no-highlight">560</i>&nbsp;                    if (intHashSet.excludes(i)) {</b>
<b class="nc"><i class="no-highlight">561</i>&nbsp;                        int type = slaveMetadata.getColumnType(i);</b>
<b class="nc"><i class="no-highlight">562</i>&nbsp;                        metadata.add(</b>
<i class="no-highlight">563</i>&nbsp;                                slaveAlias,
<b class="nc"><i class="no-highlight">564</i>&nbsp;                                slaveMetadata.getColumnName(i),</b>
<i class="no-highlight">565</i>&nbsp;                                type,
<b class="nc"><i class="no-highlight">566</i>&nbsp;                                slaveMetadata.isColumnIndexed(i),</b>
<b class="nc"><i class="no-highlight">567</i>&nbsp;                                slaveMetadata.getIndexValueBlockCapacity(i),</b>
<b class="nc"><i class="no-highlight">568</i>&nbsp;                                slaveMetadata.isSymbolTableStatic(i),</b>
<b class="nc"><i class="no-highlight">569</i>&nbsp;                                slaveMetadata.getMetadata(i)</b>
<i class="no-highlight">570</i>&nbsp;                        );
<b class="nc"><i class="no-highlight">571</i>&nbsp;                        listColumnFilterB.add(i + 1);</b>
<b class="nc"><i class="no-highlight">572</i>&nbsp;                        columnIndex.add(i);</b>
<b class="nc"><i class="no-highlight">573</i>&nbsp;                        valueTypes.add(type);</b>
<b class="nc"><i class="no-highlight">574</i>&nbsp;                        slaveTypes.add(type);</b>
<i class="no-highlight">575</i>&nbsp;                    }
<i class="no-highlight">576</i>&nbsp;                }
<i class="no-highlight">577</i>&nbsp;
<i class="no-highlight">578</i>&nbsp;                // now add key columns to metadata
<b class="nc"><i class="no-highlight">579</i>&nbsp;                for (int i = 0, n = listColumnFilterA.getColumnCount(); i &lt; n; i++) {</b>
<b class="nc"><i class="no-highlight">580</i>&nbsp;                    int index = listColumnFilterA.getColumnIndexFactored(i);</b>
<b class="nc"><i class="no-highlight">581</i>&nbsp;                    int type = slaveMetadata.getColumnType(index);</b>
<b class="nc"><i class="no-highlight">582</i>&nbsp;                    if (ColumnType.isSymbol(type)) {</b>
<b class="nc"><i class="no-highlight">583</i>&nbsp;                        type = ColumnType.STRING;</b>
<i class="no-highlight">584</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">585</i>&nbsp;                    metadata.add(</b>
<i class="no-highlight">586</i>&nbsp;                            slaveAlias,
<b class="nc"><i class="no-highlight">587</i>&nbsp;                            slaveMetadata.getColumnName(index),</b>
<i class="no-highlight">588</i>&nbsp;                            type,
<b class="nc"><i class="no-highlight">589</i>&nbsp;                            slaveMetadata.isColumnIndexed(i),</b>
<b class="nc"><i class="no-highlight">590</i>&nbsp;                            slaveMetadata.getIndexValueBlockCapacity(i),</b>
<b class="nc"><i class="no-highlight">591</i>&nbsp;                            slaveMetadata.isSymbolTableStatic(i),</b>
<b class="nc"><i class="no-highlight">592</i>&nbsp;                            slaveMetadata.getMetadata(i)</b>
<i class="no-highlight">593</i>&nbsp;                    );
<b class="nc"><i class="no-highlight">594</i>&nbsp;                    columnIndex.add(index);</b>
<b class="nc"><i class="no-highlight">595</i>&nbsp;                    slaveTypes.add(type);</b>
<i class="no-highlight">596</i>&nbsp;                }
<i class="no-highlight">597</i>&nbsp;            }
<i class="no-highlight">598</i>&nbsp;
<i class="no-highlight">599</i>&nbsp;
<b class="fc"><i class="no-highlight">600</i>&nbsp;            if (masterMetadata.getTimestampIndex() != -1) {</b>
<b class="fc"><i class="no-highlight">601</i>&nbsp;                metadata.setTimestampIndex(masterMetadata.getTimestampIndex());</b>
<i class="no-highlight">602</i>&nbsp;            }
<i class="no-highlight">603</i>&nbsp;
<b class="fc"><i class="no-highlight">604</i>&nbsp;            return generator.create(</b>
<i class="no-highlight">605</i>&nbsp;                    configuration,
<i class="no-highlight">606</i>&nbsp;                    metadata,
<i class="no-highlight">607</i>&nbsp;                    master,
<i class="no-highlight">608</i>&nbsp;                    slave,
<i class="no-highlight">609</i>&nbsp;                    keyTypes,
<i class="no-highlight">610</i>&nbsp;                    valueTypes,
<i class="no-highlight">611</i>&nbsp;                    slaveTypes,
<i class="no-highlight">612</i>&nbsp;                    masterSink,
<b class="fc"><i class="no-highlight">613</i>&nbsp;                    RecordSinkFactory.getInstance(</b>
<i class="no-highlight">614</i>&nbsp;                            asm,
<i class="no-highlight">615</i>&nbsp;                            slaveMetadata,
<i class="no-highlight">616</i>&nbsp;                            listColumnFilterA,
<i class="no-highlight">617</i>&nbsp;                            true
<i class="no-highlight">618</i>&nbsp;                    ),
<b class="fc"><i class="no-highlight">619</i>&nbsp;                    masterMetadata.getColumnCount(),</b>
<b class="fc"><i class="no-highlight">620</i>&nbsp;                    RecordValueSinkFactory.getInstance(asm, slaveMetadata, listColumnFilterB),</b>
<i class="no-highlight">621</i>&nbsp;                    columnIndex,
<i class="no-highlight">622</i>&nbsp;                    joinContext
<i class="no-highlight">623</i>&nbsp;            );
<i class="no-highlight">624</i>&nbsp;
<b class="fc"><i class="no-highlight">625</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">626</i>&nbsp;            Misc.free(metadata);</b>
<b class="fc"><i class="no-highlight">627</i>&nbsp;            throw e;</b>
<i class="no-highlight">628</i>&nbsp;        }
<i class="no-highlight">629</i>&nbsp;    }
<i class="no-highlight">630</i>&nbsp;
<i class="no-highlight">631</i>&nbsp;    private RecordCursorFactory createHashJoin(
<i class="no-highlight">632</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">633</i>&nbsp;            RecordCursorFactory master,
<i class="no-highlight">634</i>&nbsp;            RecordCursorFactory slave,
<i class="no-highlight">635</i>&nbsp;            int joinType,
<i class="no-highlight">636</i>&nbsp;            Function filter,
<i class="no-highlight">637</i>&nbsp;            JoinContext context
<i class="no-highlight">638</i>&nbsp;    ) {
<i class="no-highlight">639</i>&nbsp;        /*
<i class="no-highlight">640</i>&nbsp;         * JoinContext provides the following information:
<i class="no-highlight">641</i>&nbsp;         * a/bIndexes - index of model where join column is coming from
<i class="no-highlight">642</i>&nbsp;         * a/bNames - name of columns in respective models, these column names are not prefixed with table aliases
<i class="no-highlight">643</i>&nbsp;         * a/bNodes - the original column references, that can include table alias. Sometimes it doesn&#39;t when column name is unambiguous
<i class="no-highlight">644</i>&nbsp;         *
<i class="no-highlight">645</i>&nbsp;         * a/b are &quot;inverted&quot; in that &quot;a&quot; for slave and &quot;b&quot; for master
<i class="no-highlight">646</i>&nbsp;         *
<i class="no-highlight">647</i>&nbsp;         * The issue is when we use model indexes and vanilla column names they would only work on single-table
<i class="no-highlight">648</i>&nbsp;         * record cursor but original names with prefixed columns will only work with JoinRecordMetadata
<i class="no-highlight">649</i>&nbsp;         */
<b class="fc"><i class="no-highlight">650</i>&nbsp;        final RecordMetadata masterMetadata = master.getMetadata();</b>
<b class="fc"><i class="no-highlight">651</i>&nbsp;        final RecordMetadata slaveMetadata = slave.getMetadata();</b>
<b class="fc"><i class="no-highlight">652</i>&nbsp;        final RecordSink masterKeySink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">653</i>&nbsp;                asm,
<i class="no-highlight">654</i>&nbsp;                masterMetadata,
<i class="no-highlight">655</i>&nbsp;                listColumnFilterB,
<i class="no-highlight">656</i>&nbsp;                true
<i class="no-highlight">657</i>&nbsp;        );
<i class="no-highlight">658</i>&nbsp;
<b class="fc"><i class="no-highlight">659</i>&nbsp;        final RecordSink slaveKeySink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">660</i>&nbsp;                asm,
<i class="no-highlight">661</i>&nbsp;                slaveMetadata,
<i class="no-highlight">662</i>&nbsp;                listColumnFilterA,
<i class="no-highlight">663</i>&nbsp;                true
<i class="no-highlight">664</i>&nbsp;        );
<i class="no-highlight">665</i>&nbsp;
<b class="fc"><i class="no-highlight">666</i>&nbsp;        valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">667</i>&nbsp;        valueTypes.add(ColumnType.LONG);</b>
<b class="fc"><i class="no-highlight">668</i>&nbsp;        valueTypes.add(ColumnType.LONG);</b>
<i class="no-highlight">669</i>&nbsp;
<b class="fc"><i class="no-highlight">670</i>&nbsp;        if (slave.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</b>
<b class="fc"><i class="no-highlight">671</i>&nbsp;            if (joinType == JOIN_INNER) {</b>
<b class="fc"><i class="no-highlight">672</i>&nbsp;                return new HashJoinLightRecordCursorFactory(</b>
<i class="no-highlight">673</i>&nbsp;                        configuration,
<i class="no-highlight">674</i>&nbsp;                        metadata,
<i class="no-highlight">675</i>&nbsp;                        master,
<i class="no-highlight">676</i>&nbsp;                        slave,
<i class="no-highlight">677</i>&nbsp;                        keyTypes,
<i class="no-highlight">678</i>&nbsp;                        valueTypes,
<i class="no-highlight">679</i>&nbsp;                        masterKeySink,
<i class="no-highlight">680</i>&nbsp;                        slaveKeySink,
<b class="fc"><i class="no-highlight">681</i>&nbsp;                        masterMetadata.getColumnCount(),</b>
<i class="no-highlight">682</i>&nbsp;                        context
<i class="no-highlight">683</i>&nbsp;                );
<i class="no-highlight">684</i>&nbsp;            }
<i class="no-highlight">685</i>&nbsp;
<b class="fc"><i class="no-highlight">686</i>&nbsp;            if (filter != null) {</b>
<b class="fc"><i class="no-highlight">687</i>&nbsp;                return new HashOuterJoinFilteredLightRecordCursorFactory(</b>
<i class="no-highlight">688</i>&nbsp;                        configuration,
<i class="no-highlight">689</i>&nbsp;                        metadata,
<i class="no-highlight">690</i>&nbsp;                        master,
<i class="no-highlight">691</i>&nbsp;                        slave,
<i class="no-highlight">692</i>&nbsp;                        keyTypes,
<i class="no-highlight">693</i>&nbsp;                        valueTypes,
<i class="no-highlight">694</i>&nbsp;                        masterKeySink,
<i class="no-highlight">695</i>&nbsp;                        slaveKeySink,
<b class="fc"><i class="no-highlight">696</i>&nbsp;                        masterMetadata.getColumnCount(),</b>
<i class="no-highlight">697</i>&nbsp;                        filter,
<i class="no-highlight">698</i>&nbsp;                        context
<i class="no-highlight">699</i>&nbsp;                );
<i class="no-highlight">700</i>&nbsp;            }
<i class="no-highlight">701</i>&nbsp;
<b class="fc"><i class="no-highlight">702</i>&nbsp;            return new HashOuterJoinLightRecordCursorFactory(</b>
<i class="no-highlight">703</i>&nbsp;                    configuration,
<i class="no-highlight">704</i>&nbsp;                    metadata,
<i class="no-highlight">705</i>&nbsp;                    master,
<i class="no-highlight">706</i>&nbsp;                    slave,
<i class="no-highlight">707</i>&nbsp;                    keyTypes,
<i class="no-highlight">708</i>&nbsp;                    valueTypes,
<i class="no-highlight">709</i>&nbsp;                    masterKeySink,
<i class="no-highlight">710</i>&nbsp;                    slaveKeySink,
<b class="fc"><i class="no-highlight">711</i>&nbsp;                    masterMetadata.getColumnCount(),</b>
<i class="no-highlight">712</i>&nbsp;                    context
<i class="no-highlight">713</i>&nbsp;            );
<i class="no-highlight">714</i>&nbsp;        }
<i class="no-highlight">715</i>&nbsp;
<b class="fc"><i class="no-highlight">716</i>&nbsp;        entityColumnFilter.of(slaveMetadata.getColumnCount());</b>
<b class="fc"><i class="no-highlight">717</i>&nbsp;        RecordSink slaveSink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">718</i>&nbsp;                asm,
<i class="no-highlight">719</i>&nbsp;                slaveMetadata,
<i class="no-highlight">720</i>&nbsp;                entityColumnFilter,
<i class="no-highlight">721</i>&nbsp;                false
<i class="no-highlight">722</i>&nbsp;        );
<i class="no-highlight">723</i>&nbsp;
<b class="fc"><i class="no-highlight">724</i>&nbsp;        if (joinType == JOIN_INNER) {</b>
<b class="fc"><i class="no-highlight">725</i>&nbsp;            return new HashJoinRecordCursorFactory(</b>
<i class="no-highlight">726</i>&nbsp;                    configuration,
<i class="no-highlight">727</i>&nbsp;                    metadata,
<i class="no-highlight">728</i>&nbsp;                    master,
<i class="no-highlight">729</i>&nbsp;                    slave,
<i class="no-highlight">730</i>&nbsp;                    keyTypes,
<i class="no-highlight">731</i>&nbsp;                    valueTypes,
<i class="no-highlight">732</i>&nbsp;                    masterKeySink,
<i class="no-highlight">733</i>&nbsp;                    slaveKeySink,
<i class="no-highlight">734</i>&nbsp;                    slaveSink,
<b class="fc"><i class="no-highlight">735</i>&nbsp;                    masterMetadata.getColumnCount(),</b>
<i class="no-highlight">736</i>&nbsp;                    context
<i class="no-highlight">737</i>&nbsp;            );
<i class="no-highlight">738</i>&nbsp;        }
<i class="no-highlight">739</i>&nbsp;
<b class="fc"><i class="no-highlight">740</i>&nbsp;        if (filter != null) {</b>
<b class="fc"><i class="no-highlight">741</i>&nbsp;            return new HashOuterJoinFilteredRecordCursorFactory(</b>
<i class="no-highlight">742</i>&nbsp;                    configuration,
<i class="no-highlight">743</i>&nbsp;                    metadata,
<i class="no-highlight">744</i>&nbsp;                    master,
<i class="no-highlight">745</i>&nbsp;                    slave,
<i class="no-highlight">746</i>&nbsp;                    keyTypes,
<i class="no-highlight">747</i>&nbsp;                    valueTypes,
<i class="no-highlight">748</i>&nbsp;                    masterKeySink,
<i class="no-highlight">749</i>&nbsp;                    slaveKeySink,
<i class="no-highlight">750</i>&nbsp;                    slaveSink,
<b class="fc"><i class="no-highlight">751</i>&nbsp;                    masterMetadata.getColumnCount(),</b>
<i class="no-highlight">752</i>&nbsp;                    filter,
<i class="no-highlight">753</i>&nbsp;                    context
<i class="no-highlight">754</i>&nbsp;            );
<i class="no-highlight">755</i>&nbsp;        }
<i class="no-highlight">756</i>&nbsp;
<b class="fc"><i class="no-highlight">757</i>&nbsp;        return new HashOuterJoinRecordCursorFactory(</b>
<i class="no-highlight">758</i>&nbsp;                configuration,
<i class="no-highlight">759</i>&nbsp;                metadata,
<i class="no-highlight">760</i>&nbsp;                master,
<i class="no-highlight">761</i>&nbsp;                slave,
<i class="no-highlight">762</i>&nbsp;                keyTypes,
<i class="no-highlight">763</i>&nbsp;                valueTypes,
<i class="no-highlight">764</i>&nbsp;                masterKeySink,
<i class="no-highlight">765</i>&nbsp;                slaveKeySink,
<i class="no-highlight">766</i>&nbsp;                slaveSink,
<b class="fc"><i class="no-highlight">767</i>&nbsp;                masterMetadata.getColumnCount(),</b>
<i class="no-highlight">768</i>&nbsp;                context
<i class="no-highlight">769</i>&nbsp;        );
<i class="no-highlight">770</i>&nbsp;    }
<i class="no-highlight">771</i>&nbsp;
<i class="no-highlight">772</i>&nbsp;    @NotNull
<i class="no-highlight">773</i>&nbsp;    private JoinRecordMetadata createJoinMetadata(
<i class="no-highlight">774</i>&nbsp;            CharSequence masterAlias,
<i class="no-highlight">775</i>&nbsp;            RecordMetadata masterMetadata,
<i class="no-highlight">776</i>&nbsp;            CharSequence slaveAlias,
<i class="no-highlight">777</i>&nbsp;            RecordMetadata slaveMetadata
<i class="no-highlight">778</i>&nbsp;    ) {
<b class="fc"><i class="no-highlight">779</i>&nbsp;        return createJoinMetadata(</b>
<i class="no-highlight">780</i>&nbsp;                masterAlias,
<i class="no-highlight">781</i>&nbsp;                masterMetadata,
<i class="no-highlight">782</i>&nbsp;                slaveAlias,
<i class="no-highlight">783</i>&nbsp;                slaveMetadata,
<b class="fc"><i class="no-highlight">784</i>&nbsp;                masterMetadata.getTimestampIndex()</b>
<i class="no-highlight">785</i>&nbsp;        );
<i class="no-highlight">786</i>&nbsp;    }
<i class="no-highlight">787</i>&nbsp;
<i class="no-highlight">788</i>&nbsp;    @NotNull
<i class="no-highlight">789</i>&nbsp;    private JoinRecordMetadata createJoinMetadata(
<i class="no-highlight">790</i>&nbsp;            CharSequence masterAlias,
<i class="no-highlight">791</i>&nbsp;            RecordMetadata masterMetadata,
<i class="no-highlight">792</i>&nbsp;            CharSequence slaveAlias,
<i class="no-highlight">793</i>&nbsp;            RecordMetadata slaveMetadata,
<i class="no-highlight">794</i>&nbsp;            int timestampIndex
<i class="no-highlight">795</i>&nbsp;    ) {
<i class="no-highlight">796</i>&nbsp;        JoinRecordMetadata metadata;
<b class="fc"><i class="no-highlight">797</i>&nbsp;        metadata = new JoinRecordMetadata(</b>
<i class="no-highlight">798</i>&nbsp;                configuration,
<b class="fc"><i class="no-highlight">799</i>&nbsp;                masterMetadata.getColumnCount() + slaveMetadata.getColumnCount()</b>
<i class="no-highlight">800</i>&nbsp;        );
<i class="no-highlight">801</i>&nbsp;
<b class="fc"><i class="no-highlight">802</i>&nbsp;        metadata.copyColumnMetadataFrom(masterAlias, masterMetadata);</b>
<b class="fc"><i class="no-highlight">803</i>&nbsp;        metadata.copyColumnMetadataFrom(slaveAlias, slaveMetadata);</b>
<i class="no-highlight">804</i>&nbsp;
<b class="fc"><i class="no-highlight">805</i>&nbsp;        if (timestampIndex != -1) {</b>
<b class="fc"><i class="no-highlight">806</i>&nbsp;            metadata.setTimestampIndex(timestampIndex);</b>
<i class="no-highlight">807</i>&nbsp;        }
<b class="fc"><i class="no-highlight">808</i>&nbsp;        return metadata;</b>
<i class="no-highlight">809</i>&nbsp;    }
<i class="no-highlight">810</i>&nbsp;
<i class="no-highlight">811</i>&nbsp;    private RecordCursorFactory createLtJoin(
<i class="no-highlight">812</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">813</i>&nbsp;            RecordCursorFactory master,
<i class="no-highlight">814</i>&nbsp;            RecordSink masterKeySink,
<i class="no-highlight">815</i>&nbsp;            RecordCursorFactory slave,
<i class="no-highlight">816</i>&nbsp;            RecordSink slaveKeySink,
<i class="no-highlight">817</i>&nbsp;            int columnSplit,
<i class="no-highlight">818</i>&nbsp;            JoinContext joinContext
<i class="no-highlight">819</i>&nbsp;    ) {
<b class="fc"><i class="no-highlight">820</i>&nbsp;        valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">821</i>&nbsp;        valueTypes.add(ColumnType.LONG);</b>
<b class="fc"><i class="no-highlight">822</i>&nbsp;        valueTypes.add(ColumnType.LONG);</b>
<i class="no-highlight">823</i>&nbsp;
<b class="fc"><i class="no-highlight">824</i>&nbsp;        return new LtJoinLightRecordCursorFactory(</b>
<i class="no-highlight">825</i>&nbsp;                configuration,
<i class="no-highlight">826</i>&nbsp;                metadata,
<i class="no-highlight">827</i>&nbsp;                master,
<i class="no-highlight">828</i>&nbsp;                slave,
<i class="no-highlight">829</i>&nbsp;                keyTypes,
<i class="no-highlight">830</i>&nbsp;                valueTypes,
<i class="no-highlight">831</i>&nbsp;                masterKeySink,
<i class="no-highlight">832</i>&nbsp;                slaveKeySink,
<i class="no-highlight">833</i>&nbsp;                columnSplit,
<i class="no-highlight">834</i>&nbsp;                joinContext
<i class="no-highlight">835</i>&nbsp;        );
<i class="no-highlight">836</i>&nbsp;    }
<i class="no-highlight">837</i>&nbsp;
<i class="no-highlight">838</i>&nbsp;    private RecordCursorFactory createSpliceJoin(
<i class="no-highlight">839</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">840</i>&nbsp;            RecordCursorFactory master,
<i class="no-highlight">841</i>&nbsp;            RecordSink masterKeySink,
<i class="no-highlight">842</i>&nbsp;            RecordCursorFactory slave,
<i class="no-highlight">843</i>&nbsp;            RecordSink slaveKeySink,
<i class="no-highlight">844</i>&nbsp;            int columnSplit,
<i class="no-highlight">845</i>&nbsp;            JoinContext context
<i class="no-highlight">846</i>&nbsp;    ) {
<b class="fc"><i class="no-highlight">847</i>&nbsp;        valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">848</i>&nbsp;        valueTypes.add(ColumnType.LONG); // master previous</b>
<b class="fc"><i class="no-highlight">849</i>&nbsp;        valueTypes.add(ColumnType.LONG); // master current</b>
<b class="fc"><i class="no-highlight">850</i>&nbsp;        valueTypes.add(ColumnType.LONG); // slave previous</b>
<b class="fc"><i class="no-highlight">851</i>&nbsp;        valueTypes.add(ColumnType.LONG); // slave current</b>
<i class="no-highlight">852</i>&nbsp;
<b class="fc"><i class="no-highlight">853</i>&nbsp;        return new SpliceJoinLightRecordCursorFactory(</b>
<i class="no-highlight">854</i>&nbsp;                configuration,
<i class="no-highlight">855</i>&nbsp;                metadata,
<i class="no-highlight">856</i>&nbsp;                master,
<i class="no-highlight">857</i>&nbsp;                slave,
<i class="no-highlight">858</i>&nbsp;                keyTypes,
<i class="no-highlight">859</i>&nbsp;                valueTypes,
<i class="no-highlight">860</i>&nbsp;                masterKeySink,
<i class="no-highlight">861</i>&nbsp;                slaveKeySink,
<i class="no-highlight">862</i>&nbsp;                columnSplit,
<i class="no-highlight">863</i>&nbsp;                context
<i class="no-highlight">864</i>&nbsp;        );
<i class="no-highlight">865</i>&nbsp;    }
<i class="no-highlight">866</i>&nbsp;
<i class="no-highlight">867</i>&nbsp;    private ObjList&lt;Function&gt; generateCastFunctions(
<i class="no-highlight">868</i>&nbsp;            RecordMetadata castToMetadata,
<i class="no-highlight">869</i>&nbsp;            RecordMetadata castFromMetadata,
<i class="no-highlight">870</i>&nbsp;            int modelPosition
<i class="no-highlight">871</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">872</i>&nbsp;        int columnCount = castToMetadata.getColumnCount();</b>
<b class="fc"><i class="no-highlight">873</i>&nbsp;        ObjList&lt;Function&gt; castFunctions = new ObjList&lt;&gt;();</b>
<b class="fc"><i class="no-highlight">874</i>&nbsp;        for (int i = 0; i &lt; columnCount; i++) {</b>
<b class="fc"><i class="no-highlight">875</i>&nbsp;            int toType = castToMetadata.getColumnType(i);</b>
<b class="fc"><i class="no-highlight">876</i>&nbsp;            int fromType = castFromMetadata.getColumnType(i);</b>
<b class="fc"><i class="no-highlight">877</i>&nbsp;            int toTag = ColumnType.tagOf(toType);</b>
<b class="fc"><i class="no-highlight">878</i>&nbsp;            int fromTag = ColumnType.tagOf(fromType);</b>
<b class="fc"><i class="no-highlight">879</i>&nbsp;            if (fromTag == ColumnType.NULL) {</b>
<b class="fc"><i class="no-highlight">880</i>&nbsp;                castFunctions.add(NullConstant.NULL);</b>
<i class="no-highlight">881</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">882</i>&nbsp;                switch (toTag) {</b>
<i class="no-highlight">883</i>&nbsp;                    case ColumnType.BOOLEAN:
<b class="fc"><i class="no-highlight">884</i>&nbsp;                        castFunctions.add(new BooleanColumn(i));</b>
<b class="fc"><i class="no-highlight">885</i>&nbsp;                        break;</b>
<i class="no-highlight">886</i>&nbsp;                    case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">887</i>&nbsp;                        castFunctions.add(new ByteColumn(i));</b>
<b class="fc"><i class="no-highlight">888</i>&nbsp;                        break;</b>
<i class="no-highlight">889</i>&nbsp;                    case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">890</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">891</i>&nbsp;                            // BOOLEAN will not be cast to CHAR
<i class="no-highlight">892</i>&nbsp;                            // in cast of BOOLEAN -&gt; CHAR combination both will be cast to STRING
<i class="no-highlight">893</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">894</i>&nbsp;                                castFunctions.add(new ByteColumn(i));</b>
<b class="fc"><i class="no-highlight">895</i>&nbsp;                                break;</b>
<i class="no-highlight">896</i>&nbsp;                            case ColumnType.CHAR:
<b class="fc"><i class="no-highlight">897</i>&nbsp;                                castFunctions.add(new CharColumn(i));</b>
<b class="fc"><i class="no-highlight">898</i>&nbsp;                                break;</b>
<i class="no-highlight">899</i>&nbsp;                            case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">900</i>&nbsp;                                castFunctions.add(new ShortColumn(i));</b>
<i class="no-highlight">901</i>&nbsp;                                break;
<i class="no-highlight">902</i>&nbsp;                            // wider types are not possible here
<i class="no-highlight">903</i>&nbsp;                            // SHORT will be cast to wider types, not other way around
<i class="no-highlight">904</i>&nbsp;                            // Wider types tested are: SHORT, INT, LONG, FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
<i class="no-highlight">905</i>&nbsp;                            // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
<i class="no-highlight">906</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">907</i>&nbsp;                        break;</b>
<i class="no-highlight">908</i>&nbsp;                    case ColumnType.CHAR:
<b class="fc"><i class="no-highlight">909</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">910</i>&nbsp;                            // BOOLEAN will not be cast to CHAR
<i class="no-highlight">911</i>&nbsp;                            // in cast of BOOLEAN -&gt; CHAR combination both will be cast to STRING
<i class="no-highlight">912</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">913</i>&nbsp;                                castFunctions.add(new CastByteToCharFunctionFactory.CastByteToCharFunction(new ByteColumn(i)));</b>
<b class="fc"><i class="no-highlight">914</i>&nbsp;                                break;</b>
<i class="no-highlight">915</i>&nbsp;                            case ColumnType.CHAR:
<b class="fc"><i class="no-highlight">916</i>&nbsp;                                castFunctions.add(new CharColumn(i));</b>
<b class="fc"><i class="no-highlight">917</i>&nbsp;                                break;</b>
<i class="no-highlight">918</i>&nbsp;                            // wider types are not possible here
<i class="no-highlight">919</i>&nbsp;                            // CHAR will be cast to wider types, not other way around
<i class="no-highlight">920</i>&nbsp;                            // Wider types tested are: SHORT, INT, LONG, FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
<i class="no-highlight">921</i>&nbsp;                            // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
<i class="no-highlight">922</i>&nbsp;                            default:
<i class="no-highlight">923</i>&nbsp;
<i class="no-highlight">924</i>&nbsp;                        }
<b class="nc"><i class="no-highlight">925</i>&nbsp;                        break;</b>
<i class="no-highlight">926</i>&nbsp;                    case ColumnType.INT:
<b class="fc"><i class="no-highlight">927</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">928</i>&nbsp;                            // BOOLEAN will not be cast to INT
<i class="no-highlight">929</i>&nbsp;                            // in cast of BOOLEAN -&gt; INT combination both will be cast to STRING
<i class="no-highlight">930</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">931</i>&nbsp;                                castFunctions.add(new ByteColumn(i));</b>
<b class="fc"><i class="no-highlight">932</i>&nbsp;                                break;</b>
<i class="no-highlight">933</i>&nbsp;                            case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">934</i>&nbsp;                                castFunctions.add(new ShortColumn(i));</b>
<b class="fc"><i class="no-highlight">935</i>&nbsp;                                break;</b>
<i class="no-highlight">936</i>&nbsp;                            case ColumnType.CHAR:
<b class="fc"><i class="no-highlight">937</i>&nbsp;                                castFunctions.add(new CharColumn(i));</b>
<b class="fc"><i class="no-highlight">938</i>&nbsp;                                break;</b>
<i class="no-highlight">939</i>&nbsp;                            case ColumnType.INT:
<b class="fc"><i class="no-highlight">940</i>&nbsp;                                castFunctions.add(new IntColumn(i));</b>
<i class="no-highlight">941</i>&nbsp;                                break;
<i class="no-highlight">942</i>&nbsp;                            // wider types are not possible here
<i class="no-highlight">943</i>&nbsp;                            // INT will be cast to wider types, not other way around
<i class="no-highlight">944</i>&nbsp;                            // Wider types tested are: LONG, FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
<i class="no-highlight">945</i>&nbsp;                            // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
<i class="no-highlight">946</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">947</i>&nbsp;                        break;</b>
<i class="no-highlight">948</i>&nbsp;                    case ColumnType.LONG:
<b class="fc"><i class="no-highlight">949</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">950</i>&nbsp;                            // BOOLEAN will not be cast to LONG
<i class="no-highlight">951</i>&nbsp;                            // in cast of BOOLEAN -&gt; LONG combination both will be cast to STRING
<i class="no-highlight">952</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">953</i>&nbsp;                                castFunctions.add(new ByteColumn(i));</b>
<b class="fc"><i class="no-highlight">954</i>&nbsp;                                break;</b>
<i class="no-highlight">955</i>&nbsp;                            case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">956</i>&nbsp;                                castFunctions.add(new ShortColumn(i));</b>
<b class="fc"><i class="no-highlight">957</i>&nbsp;                                break;</b>
<i class="no-highlight">958</i>&nbsp;                            case ColumnType.CHAR:
<b class="fc"><i class="no-highlight">959</i>&nbsp;                                castFunctions.add(new CharColumn(i));</b>
<b class="fc"><i class="no-highlight">960</i>&nbsp;                                break;</b>
<i class="no-highlight">961</i>&nbsp;                            case ColumnType.INT:
<b class="fc"><i class="no-highlight">962</i>&nbsp;                                castFunctions.add(new IntColumn(i));</b>
<b class="fc"><i class="no-highlight">963</i>&nbsp;                                break;</b>
<i class="no-highlight">964</i>&nbsp;                            case ColumnType.LONG:
<b class="fc"><i class="no-highlight">965</i>&nbsp;                                castFunctions.add(new LongColumn(i));</b>
<b class="fc"><i class="no-highlight">966</i>&nbsp;                                break;</b>
<i class="no-highlight">967</i>&nbsp;                            default:
<b class="fc"><i class="no-highlight">968</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">969</i>&nbsp;                                        modelPosition,
<b class="fc"><i class="no-highlight">970</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">971</i>&nbsp;                                        fromType,
<i class="no-highlight">972</i>&nbsp;                                        toType
<i class="no-highlight">973</i>&nbsp;                                );
<i class="no-highlight">974</i>&nbsp;                                // wider types are not possible here
<i class="no-highlight">975</i>&nbsp;                                // LONG will be cast to wider types, not other way around
<i class="no-highlight">976</i>&nbsp;                                // Wider types tested are: FLOAT, DOUBLE, DATE, TIMESTAMP, SYMBOL, STRING, LONG256
<i class="no-highlight">977</i>&nbsp;                                // GEOBYTE, GEOSHORT, GEOINT, GEOLONG
<i class="no-highlight">978</i>&nbsp;                        }
<i class="no-highlight">979</i>&nbsp;                        break;
<i class="no-highlight">980</i>&nbsp;                    case ColumnType.DATE:
<b class="fc"><i class="no-highlight">981</i>&nbsp;                        if (fromTag == ColumnType.DATE) {</b>
<b class="fc"><i class="no-highlight">982</i>&nbsp;                            castFunctions.add(new DateColumn(i));</b>
<i class="no-highlight">983</i>&nbsp;                        } else {
<b class="fc"><i class="no-highlight">984</i>&nbsp;                            throw SqlException.unsupportedCast(</b>
<i class="no-highlight">985</i>&nbsp;                                    modelPosition,
<b class="fc"><i class="no-highlight">986</i>&nbsp;                                    castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">987</i>&nbsp;                                    fromType,
<i class="no-highlight">988</i>&nbsp;                                    toType
<i class="no-highlight">989</i>&nbsp;                            );
<i class="no-highlight">990</i>&nbsp;                        }
<i class="no-highlight">991</i>&nbsp;                        break;
<i class="no-highlight">992</i>&nbsp;                    case ColumnType.UUID:
<b class="fc"><i class="no-highlight">993</i>&nbsp;                        assert fromTag == ColumnType.UUID;</b>
<b class="fc"><i class="no-highlight">994</i>&nbsp;                        castFunctions.add(new UuidColumn(i));</b>
<b class="fc"><i class="no-highlight">995</i>&nbsp;                        break;</b>
<i class="no-highlight">996</i>&nbsp;                    case ColumnType.TIMESTAMP:
<b class="fc"><i class="no-highlight">997</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">998</i>&nbsp;                            case ColumnType.DATE:
<b class="fc"><i class="no-highlight">999</i>&nbsp;                                castFunctions.add(new CastDateToTimestampFunctionFactory.CastDateToTimestampFunction(new DateColumn(i)));</b>
<b class="fc"><i class="no-highlight">1000</i>&nbsp;                                break;</b>
<i class="no-highlight">1001</i>&nbsp;                            case ColumnType.TIMESTAMP:
<b class="fc"><i class="no-highlight">1002</i>&nbsp;                                castFunctions.add(new TimestampColumn(i));</b>
<b class="fc"><i class="no-highlight">1003</i>&nbsp;                                break;</b>
<i class="no-highlight">1004</i>&nbsp;                            default:
<b class="fc"><i class="no-highlight">1005</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1006</i>&nbsp;                                        modelPosition,
<b class="fc"><i class="no-highlight">1007</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1008</i>&nbsp;                                        fromType,
<i class="no-highlight">1009</i>&nbsp;                                        toType
<i class="no-highlight">1010</i>&nbsp;                                );
<i class="no-highlight">1011</i>&nbsp;                        }
<i class="no-highlight">1012</i>&nbsp;                        break;
<i class="no-highlight">1013</i>&nbsp;                    case ColumnType.FLOAT:
<b class="fc"><i class="no-highlight">1014</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1015</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">1016</i>&nbsp;                                castFunctions.add(new ByteColumn(i));</b>
<b class="fc"><i class="no-highlight">1017</i>&nbsp;                                break;</b>
<i class="no-highlight">1018</i>&nbsp;                            case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">1019</i>&nbsp;                                castFunctions.add(new ShortColumn(i));</b>
<b class="fc"><i class="no-highlight">1020</i>&nbsp;                                break;</b>
<i class="no-highlight">1021</i>&nbsp;                            case ColumnType.INT:
<b class="fc"><i class="no-highlight">1022</i>&nbsp;                                castFunctions.add(new IntColumn(i));</b>
<b class="fc"><i class="no-highlight">1023</i>&nbsp;                                break;</b>
<i class="no-highlight">1024</i>&nbsp;                            case ColumnType.LONG:
<b class="fc"><i class="no-highlight">1025</i>&nbsp;                                castFunctions.add(new LongColumn(i));</b>
<b class="fc"><i class="no-highlight">1026</i>&nbsp;                                break;</b>
<i class="no-highlight">1027</i>&nbsp;                            case ColumnType.FLOAT:
<b class="fc"><i class="no-highlight">1028</i>&nbsp;                                castFunctions.add(new FloatColumn(i));</b>
<b class="fc"><i class="no-highlight">1029</i>&nbsp;                                break;</b>
<i class="no-highlight">1030</i>&nbsp;                            default:
<b class="fc"><i class="no-highlight">1031</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1032</i>&nbsp;                                        modelPosition,
<b class="fc"><i class="no-highlight">1033</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1034</i>&nbsp;                                        fromType,
<i class="no-highlight">1035</i>&nbsp;                                        toType
<i class="no-highlight">1036</i>&nbsp;                                );
<i class="no-highlight">1037</i>&nbsp;                        }
<i class="no-highlight">1038</i>&nbsp;                        break;
<i class="no-highlight">1039</i>&nbsp;                    case ColumnType.DOUBLE:
<b class="fc"><i class="no-highlight">1040</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1041</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">1042</i>&nbsp;                                castFunctions.add(new ByteColumn(i));</b>
<b class="fc"><i class="no-highlight">1043</i>&nbsp;                                break;</b>
<i class="no-highlight">1044</i>&nbsp;                            case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">1045</i>&nbsp;                                castFunctions.add(new ShortColumn(i));</b>
<b class="fc"><i class="no-highlight">1046</i>&nbsp;                                break;</b>
<i class="no-highlight">1047</i>&nbsp;                            case ColumnType.INT:
<b class="fc"><i class="no-highlight">1048</i>&nbsp;                                castFunctions.add(new IntColumn(i));</b>
<b class="fc"><i class="no-highlight">1049</i>&nbsp;                                break;</b>
<i class="no-highlight">1050</i>&nbsp;                            case ColumnType.LONG:
<b class="fc"><i class="no-highlight">1051</i>&nbsp;                                castFunctions.add(new LongColumn(i));</b>
<b class="fc"><i class="no-highlight">1052</i>&nbsp;                                break;</b>
<i class="no-highlight">1053</i>&nbsp;                            case ColumnType.FLOAT:
<b class="fc"><i class="no-highlight">1054</i>&nbsp;                                castFunctions.add(new FloatColumn(i));</b>
<b class="fc"><i class="no-highlight">1055</i>&nbsp;                                break;</b>
<i class="no-highlight">1056</i>&nbsp;                            case ColumnType.DOUBLE:
<b class="fc"><i class="no-highlight">1057</i>&nbsp;                                castFunctions.add(new DoubleColumn(i));</b>
<b class="fc"><i class="no-highlight">1058</i>&nbsp;                                break;</b>
<i class="no-highlight">1059</i>&nbsp;                            default:
<b class="fc"><i class="no-highlight">1060</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1061</i>&nbsp;                                        modelPosition,
<b class="fc"><i class="no-highlight">1062</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1063</i>&nbsp;                                        fromType,
<i class="no-highlight">1064</i>&nbsp;                                        toType
<i class="no-highlight">1065</i>&nbsp;                                );
<i class="no-highlight">1066</i>&nbsp;                        }
<i class="no-highlight">1067</i>&nbsp;                        break;
<i class="no-highlight">1068</i>&nbsp;                    case ColumnType.STRING:
<b class="fc"><i class="no-highlight">1069</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1070</i>&nbsp;                            case ColumnType.BOOLEAN:
<b class="fc"><i class="no-highlight">1071</i>&nbsp;                                castFunctions.add(new BooleanColumn(i));</b>
<b class="fc"><i class="no-highlight">1072</i>&nbsp;                                break;</b>
<i class="no-highlight">1073</i>&nbsp;                            case ColumnType.BYTE:
<b class="fc"><i class="no-highlight">1074</i>&nbsp;                                castFunctions.add(new CastByteToStrFunctionFactory.CastByteToStrFunction(new ByteColumn(i)));</b>
<b class="fc"><i class="no-highlight">1075</i>&nbsp;                                break;</b>
<i class="no-highlight">1076</i>&nbsp;                            case ColumnType.SHORT:
<b class="fc"><i class="no-highlight">1077</i>&nbsp;                                castFunctions.add(new CastShortToStrFunctionFactory.CastShortToStrFunction(new ShortColumn(i)));</b>
<b class="fc"><i class="no-highlight">1078</i>&nbsp;                                break;</b>
<i class="no-highlight">1079</i>&nbsp;                            case ColumnType.CHAR:
<i class="no-highlight">1080</i>&nbsp;                                // CharFunction has built-in cast to String
<b class="fc"><i class="no-highlight">1081</i>&nbsp;                                castFunctions.add(new CharColumn(i));</b>
<b class="fc"><i class="no-highlight">1082</i>&nbsp;                                break;</b>
<i class="no-highlight">1083</i>&nbsp;                            case ColumnType.INT:
<b class="fc"><i class="no-highlight">1084</i>&nbsp;                                castFunctions.add(new CastIntToStrFunctionFactory.CastIntToStrFunction(new IntColumn(i)));</b>
<b class="fc"><i class="no-highlight">1085</i>&nbsp;                                break;</b>
<i class="no-highlight">1086</i>&nbsp;                            case ColumnType.LONG:
<b class="fc"><i class="no-highlight">1087</i>&nbsp;                                castFunctions.add(new CastLongToStrFunctionFactory.CastLongToStrFunction(new LongColumn(i)));</b>
<b class="fc"><i class="no-highlight">1088</i>&nbsp;                                break;</b>
<i class="no-highlight">1089</i>&nbsp;                            case ColumnType.DATE:
<b class="fc"><i class="no-highlight">1090</i>&nbsp;                                castFunctions.add(new CastDateToStrFunctionFactory.CastDateToStrFunction(new DateColumn(i)));</b>
<b class="fc"><i class="no-highlight">1091</i>&nbsp;                                break;</b>
<i class="no-highlight">1092</i>&nbsp;                            case ColumnType.TIMESTAMP:
<b class="fc"><i class="no-highlight">1093</i>&nbsp;                                castFunctions.add(new CastTimestampToStrFunctionFactory.CastTimestampToStrFunction(new TimestampColumn(i)));</b>
<b class="fc"><i class="no-highlight">1094</i>&nbsp;                                break;</b>
<i class="no-highlight">1095</i>&nbsp;                            case ColumnType.FLOAT:
<b class="fc"><i class="no-highlight">1096</i>&nbsp;                                castFunctions.add(new CastFloatToStrFunctionFactory.CastFloatToStrFunction(</b>
<i class="no-highlight">1097</i>&nbsp;                                        new FloatColumn(i),
<b class="fc"><i class="no-highlight">1098</i>&nbsp;                                        configuration.getFloatToStrCastScale()</b>
<i class="no-highlight">1099</i>&nbsp;                                ));
<b class="fc"><i class="no-highlight">1100</i>&nbsp;                                break;</b>
<i class="no-highlight">1101</i>&nbsp;                            case ColumnType.DOUBLE:
<b class="fc"><i class="no-highlight">1102</i>&nbsp;                                castFunctions.add(new CastDoubleToStrFunctionFactory.CastDoubleToStrFunction(</b>
<i class="no-highlight">1103</i>&nbsp;                                        new DoubleColumn(i),
<b class="fc"><i class="no-highlight">1104</i>&nbsp;                                        configuration.getDoubleToStrCastScale()</b>
<i class="no-highlight">1105</i>&nbsp;                                ));
<b class="fc"><i class="no-highlight">1106</i>&nbsp;                                break;</b>
<i class="no-highlight">1107</i>&nbsp;                            case ColumnType.STRING:
<b class="fc"><i class="no-highlight">1108</i>&nbsp;                                castFunctions.add(new StrColumn(i));</b>
<b class="fc"><i class="no-highlight">1109</i>&nbsp;                                break;</b>
<i class="no-highlight">1110</i>&nbsp;                            case ColumnType.UUID:
<b class="fc"><i class="no-highlight">1111</i>&nbsp;                                castFunctions.add(new CastUuidToStrFunctionFactory.Func(new UuidColumn(i)));</b>
<b class="fc"><i class="no-highlight">1112</i>&nbsp;                                break;</b>
<i class="no-highlight">1113</i>&nbsp;                            case ColumnType.SYMBOL:
<b class="fc"><i class="no-highlight">1114</i>&nbsp;                                castFunctions.add(</b>
<i class="no-highlight">1115</i>&nbsp;                                        new CastSymbolToStrFunctionFactory.CastSymbolToStrFunction(
<b class="fc"><i class="no-highlight">1116</i>&nbsp;                                                new SymbolColumn(i, castFromMetadata.isSymbolTableStatic(i))</b>
<i class="no-highlight">1117</i>&nbsp;                                        )
<i class="no-highlight">1118</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1119</i>&nbsp;                                break;</b>
<i class="no-highlight">1120</i>&nbsp;                            case ColumnType.LONG256:
<b class="fc"><i class="no-highlight">1121</i>&nbsp;                                castFunctions.add(</b>
<i class="no-highlight">1122</i>&nbsp;                                        new CastLong256ToStrFunctionFactory.CastLong256ToStrFunction(
<i class="no-highlight">1123</i>&nbsp;                                                new Long256Column(i)
<i class="no-highlight">1124</i>&nbsp;                                        )
<i class="no-highlight">1125</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1126</i>&nbsp;                                break;</b>
<i class="no-highlight">1127</i>&nbsp;                            case ColumnType.GEOBYTE:
<b class="fc"><i class="no-highlight">1128</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1129</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.getGeoByteToStrCastFunction(</b>
<i class="no-highlight">1130</i>&nbsp;                                                new GeoByteColumn(i, toTag),
<b class="fc"><i class="no-highlight">1131</i>&nbsp;                                                ColumnType.getGeoHashBits(fromType)</b>
<i class="no-highlight">1132</i>&nbsp;                                        )
<i class="no-highlight">1133</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1134</i>&nbsp;                                break;</b>
<i class="no-highlight">1135</i>&nbsp;                            case ColumnType.GEOSHORT:
<b class="fc"><i class="no-highlight">1136</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1137</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.getGeoShortToStrCastFunction(</b>
<i class="no-highlight">1138</i>&nbsp;                                                new GeoShortColumn(i, toTag),
<b class="fc"><i class="no-highlight">1139</i>&nbsp;                                                ColumnType.getGeoHashBits(castFromMetadata.getColumnType(i))</b>
<i class="no-highlight">1140</i>&nbsp;                                        )
<i class="no-highlight">1141</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1142</i>&nbsp;                                break;</b>
<i class="no-highlight">1143</i>&nbsp;                            case ColumnType.GEOINT:
<b class="fc"><i class="no-highlight">1144</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1145</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.getGeoIntToStrCastFunction(</b>
<i class="no-highlight">1146</i>&nbsp;                                                new GeoIntColumn(i, toTag),
<b class="fc"><i class="no-highlight">1147</i>&nbsp;                                                ColumnType.getGeoHashBits(castFromMetadata.getColumnType(i))</b>
<i class="no-highlight">1148</i>&nbsp;                                        )
<i class="no-highlight">1149</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1150</i>&nbsp;                                break;</b>
<i class="no-highlight">1151</i>&nbsp;                            case ColumnType.GEOLONG:
<b class="fc"><i class="no-highlight">1152</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1153</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.getGeoLongToStrCastFunction(</b>
<i class="no-highlight">1154</i>&nbsp;                                                new GeoLongColumn(i, toTag),
<b class="fc"><i class="no-highlight">1155</i>&nbsp;                                                ColumnType.getGeoHashBits(castFromMetadata.getColumnType(i))</b>
<i class="no-highlight">1156</i>&nbsp;                                        )
<i class="no-highlight">1157</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1158</i>&nbsp;                                break;</b>
<i class="no-highlight">1159</i>&nbsp;                            case ColumnType.BINARY:
<b class="fc"><i class="no-highlight">1160</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1161</i>&nbsp;                                        modelPosition,
<b class="fc"><i class="no-highlight">1162</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1163</i>&nbsp;                                        fromType,
<i class="no-highlight">1164</i>&nbsp;                                        toType
<i class="no-highlight">1165</i>&nbsp;                                );
<i class="no-highlight">1166</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">1167</i>&nbsp;                        break;</b>
<i class="no-highlight">1168</i>&nbsp;                    case ColumnType.SYMBOL:
<b class="nc"><i class="no-highlight">1169</i>&nbsp;                        castFunctions.add(new CastSymbolToStrFunctionFactory.CastSymbolToStrFunction(</b>
<i class="no-highlight">1170</i>&nbsp;                                new SymbolColumn(
<i class="no-highlight">1171</i>&nbsp;                                        i,
<b class="nc"><i class="no-highlight">1172</i>&nbsp;                                        castFromMetadata.isSymbolTableStatic(i)</b>
<i class="no-highlight">1173</i>&nbsp;                                )));
<b class="nc"><i class="no-highlight">1174</i>&nbsp;                        break;</b>
<i class="no-highlight">1175</i>&nbsp;                    case ColumnType.LONG256:
<b class="fc"><i class="no-highlight">1176</i>&nbsp;                        castFunctions.add(new Long256Column(i));</b>
<b class="fc"><i class="no-highlight">1177</i>&nbsp;                        break;</b>
<i class="no-highlight">1178</i>&nbsp;                    case ColumnType.GEOBYTE:
<b class="fc"><i class="no-highlight">1179</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1180</i>&nbsp;                            case ColumnType.STRING:
<b class="fc"><i class="no-highlight">1181</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1182</i>&nbsp;                                        CastStrToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1183</i>&nbsp;                                                0,
<i class="no-highlight">1184</i>&nbsp;                                                toType,
<i class="no-highlight">1185</i>&nbsp;                                                new StrColumn(i)
<i class="no-highlight">1186</i>&nbsp;                                        )
<i class="no-highlight">1187</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1188</i>&nbsp;                                break;</b>
<i class="no-highlight">1189</i>&nbsp;                            case ColumnType.GEOBYTE:
<b class="fc"><i class="no-highlight">1190</i>&nbsp;                                castFunctions.add(new GeoByteColumn(i, fromType));</b>
<b class="fc"><i class="no-highlight">1191</i>&nbsp;                                break;</b>
<i class="no-highlight">1192</i>&nbsp;                            case ColumnType.GEOSHORT:
<b class="fc"><i class="no-highlight">1193</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1194</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1195</i>&nbsp;                                                0,
<i class="no-highlight">1196</i>&nbsp;                                                new GeoShortColumn(i, fromType),
<i class="no-highlight">1197</i>&nbsp;                                                toType,
<i class="no-highlight">1198</i>&nbsp;                                                fromType
<i class="no-highlight">1199</i>&nbsp;                                        )
<i class="no-highlight">1200</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1201</i>&nbsp;                                break;</b>
<i class="no-highlight">1202</i>&nbsp;                            case ColumnType.GEOINT:
<b class="fc"><i class="no-highlight">1203</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1204</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1205</i>&nbsp;                                                0,
<i class="no-highlight">1206</i>&nbsp;                                                new GeoIntColumn(i, fromType),
<i class="no-highlight">1207</i>&nbsp;                                                toType,
<i class="no-highlight">1208</i>&nbsp;                                                fromType
<i class="no-highlight">1209</i>&nbsp;                                        )
<i class="no-highlight">1210</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1211</i>&nbsp;                                break;</b>
<i class="no-highlight">1212</i>&nbsp;                            case ColumnType.GEOLONG:
<b class="fc"><i class="no-highlight">1213</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1214</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1215</i>&nbsp;                                                0,
<i class="no-highlight">1216</i>&nbsp;                                                new GeoLongColumn(i, fromType),
<i class="no-highlight">1217</i>&nbsp;                                                toType,
<i class="no-highlight">1218</i>&nbsp;                                                fromType
<i class="no-highlight">1219</i>&nbsp;                                        )
<i class="no-highlight">1220</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1221</i>&nbsp;                                break;</b>
<i class="no-highlight">1222</i>&nbsp;                            default:
<b class="nc"><i class="no-highlight">1223</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1224</i>&nbsp;                                        modelPosition,
<b class="nc"><i class="no-highlight">1225</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1226</i>&nbsp;                                        fromType,
<i class="no-highlight">1227</i>&nbsp;                                        toType
<i class="no-highlight">1228</i>&nbsp;                                );
<i class="no-highlight">1229</i>&nbsp;                        }
<i class="no-highlight">1230</i>&nbsp;                        break;
<i class="no-highlight">1231</i>&nbsp;                    case ColumnType.GEOSHORT:
<b class="fc"><i class="no-highlight">1232</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1233</i>&nbsp;                            case ColumnType.STRING:
<b class="fc"><i class="no-highlight">1234</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1235</i>&nbsp;                                        CastStrToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1236</i>&nbsp;                                                0,
<i class="no-highlight">1237</i>&nbsp;                                                toType,
<i class="no-highlight">1238</i>&nbsp;                                                new StrColumn(i)
<i class="no-highlight">1239</i>&nbsp;                                        )
<i class="no-highlight">1240</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1241</i>&nbsp;                                break;</b>
<i class="no-highlight">1242</i>&nbsp;                            case ColumnType.GEOSHORT:
<b class="fc"><i class="no-highlight">1243</i>&nbsp;                                castFunctions.add(new GeoShortColumn(i, toType));</b>
<b class="fc"><i class="no-highlight">1244</i>&nbsp;                                break;</b>
<i class="no-highlight">1245</i>&nbsp;                            case ColumnType.GEOINT:
<b class="fc"><i class="no-highlight">1246</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1247</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1248</i>&nbsp;                                                0,
<i class="no-highlight">1249</i>&nbsp;                                                new GeoIntColumn(i, fromType),
<i class="no-highlight">1250</i>&nbsp;                                                toType,
<i class="no-highlight">1251</i>&nbsp;                                                fromType
<i class="no-highlight">1252</i>&nbsp;                                        )
<i class="no-highlight">1253</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1254</i>&nbsp;                                break;</b>
<i class="no-highlight">1255</i>&nbsp;                            case ColumnType.GEOLONG:
<b class="fc"><i class="no-highlight">1256</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1257</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1258</i>&nbsp;                                                0,
<i class="no-highlight">1259</i>&nbsp;                                                new GeoLongColumn(i, fromType),
<i class="no-highlight">1260</i>&nbsp;                                                toType,
<i class="no-highlight">1261</i>&nbsp;                                                fromType
<i class="no-highlight">1262</i>&nbsp;                                        )
<i class="no-highlight">1263</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1264</i>&nbsp;                                break;</b>
<i class="no-highlight">1265</i>&nbsp;                            default:
<b class="nc"><i class="no-highlight">1266</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1267</i>&nbsp;                                        modelPosition,
<b class="nc"><i class="no-highlight">1268</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1269</i>&nbsp;                                        fromType,
<i class="no-highlight">1270</i>&nbsp;                                        toType
<i class="no-highlight">1271</i>&nbsp;                                );
<i class="no-highlight">1272</i>&nbsp;                        }
<i class="no-highlight">1273</i>&nbsp;                        break;
<i class="no-highlight">1274</i>&nbsp;                    case ColumnType.GEOINT:
<b class="fc"><i class="no-highlight">1275</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1276</i>&nbsp;                            case ColumnType.STRING:
<b class="fc"><i class="no-highlight">1277</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1278</i>&nbsp;                                        CastStrToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1279</i>&nbsp;                                                0,
<i class="no-highlight">1280</i>&nbsp;                                                toType,
<i class="no-highlight">1281</i>&nbsp;                                                new StrColumn(i)
<i class="no-highlight">1282</i>&nbsp;                                        )
<i class="no-highlight">1283</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1284</i>&nbsp;                                break;</b>
<i class="no-highlight">1285</i>&nbsp;                            case ColumnType.GEOINT:
<b class="fc"><i class="no-highlight">1286</i>&nbsp;                                castFunctions.add(new GeoIntColumn(i, fromType));</b>
<b class="fc"><i class="no-highlight">1287</i>&nbsp;                                break;</b>
<i class="no-highlight">1288</i>&nbsp;                            case ColumnType.GEOLONG:
<b class="fc"><i class="no-highlight">1289</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1290</i>&nbsp;                                        CastGeoHashToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1291</i>&nbsp;                                                0,
<i class="no-highlight">1292</i>&nbsp;                                                new GeoLongColumn(i, fromType),
<i class="no-highlight">1293</i>&nbsp;                                                toType,
<i class="no-highlight">1294</i>&nbsp;                                                fromType
<i class="no-highlight">1295</i>&nbsp;                                        )
<i class="no-highlight">1296</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1297</i>&nbsp;                                break;</b>
<i class="no-highlight">1298</i>&nbsp;                            default:
<b class="nc"><i class="no-highlight">1299</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1300</i>&nbsp;                                        modelPosition,
<b class="nc"><i class="no-highlight">1301</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1302</i>&nbsp;                                        fromType,
<i class="no-highlight">1303</i>&nbsp;                                        toType
<i class="no-highlight">1304</i>&nbsp;                                );
<i class="no-highlight">1305</i>&nbsp;                        }
<i class="no-highlight">1306</i>&nbsp;                        break;
<i class="no-highlight">1307</i>&nbsp;                    case ColumnType.GEOLONG:
<b class="fc"><i class="no-highlight">1308</i>&nbsp;                        switch (fromTag) {</b>
<i class="no-highlight">1309</i>&nbsp;                            case ColumnType.STRING:
<b class="fc"><i class="no-highlight">1310</i>&nbsp;                                castFunctions.add(</b>
<b class="fc"><i class="no-highlight">1311</i>&nbsp;                                        CastStrToGeoHashFunctionFactory.newInstance(</b>
<i class="no-highlight">1312</i>&nbsp;                                                0,
<i class="no-highlight">1313</i>&nbsp;                                                toType,
<i class="no-highlight">1314</i>&nbsp;                                                new StrColumn(i)
<i class="no-highlight">1315</i>&nbsp;                                        )
<i class="no-highlight">1316</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1317</i>&nbsp;                                break;</b>
<i class="no-highlight">1318</i>&nbsp;                            case ColumnType.GEOLONG:
<b class="fc"><i class="no-highlight">1319</i>&nbsp;                                castFunctions.add(new GeoLongColumn(i, fromType));</b>
<b class="fc"><i class="no-highlight">1320</i>&nbsp;                                break;</b>
<i class="no-highlight">1321</i>&nbsp;                            default:
<b class="nc"><i class="no-highlight">1322</i>&nbsp;                                throw SqlException.unsupportedCast(</b>
<i class="no-highlight">1323</i>&nbsp;                                        modelPosition,
<b class="nc"><i class="no-highlight">1324</i>&nbsp;                                        castFromMetadata.getColumnName(i),</b>
<i class="no-highlight">1325</i>&nbsp;                                        fromType,
<i class="no-highlight">1326</i>&nbsp;                                        toType
<i class="no-highlight">1327</i>&nbsp;                                );
<i class="no-highlight">1328</i>&nbsp;                        }
<i class="no-highlight">1329</i>&nbsp;                        break;
<i class="no-highlight">1330</i>&nbsp;                    case ColumnType.BINARY:
<b class="fc"><i class="no-highlight">1331</i>&nbsp;                        castFunctions.add(new BinColumn(i));</b>
<i class="no-highlight">1332</i>&nbsp;                        break;
<i class="no-highlight">1333</i>&nbsp;                }
<i class="no-highlight">1334</i>&nbsp;            }
<i class="no-highlight">1335</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1336</i>&nbsp;        return castFunctions;</b>
<i class="no-highlight">1337</i>&nbsp;    }
<i class="no-highlight">1338</i>&nbsp;
<i class="no-highlight">1339</i>&nbsp;    private RecordCursorFactory generateFilter(RecordCursorFactory factory, QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">1340</i>&nbsp;        final ExpressionNode filter = model.getWhereClause();</b>
<b class="fc"><i class="no-highlight">1341</i>&nbsp;        return filter == null ? factory : generateFilter0(factory, model, executionContext, filter);</b>
<i class="no-highlight">1342</i>&nbsp;    }
<i class="no-highlight">1343</i>&nbsp;
<i class="no-highlight">1344</i>&nbsp;    @NotNull
<i class="no-highlight">1345</i>&nbsp;    private RecordCursorFactory generateFilter0(
<i class="no-highlight">1346</i>&nbsp;            RecordCursorFactory factory,
<i class="no-highlight">1347</i>&nbsp;            QueryModel model,
<i class="no-highlight">1348</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">1349</i>&nbsp;            ExpressionNode filterExpr
<i class="no-highlight">1350</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">1351</i>&nbsp;        backupWhereClause(filterExpr);//back up in case filters need to be compiled again</b>
<b class="fc"><i class="no-highlight">1352</i>&nbsp;        model.setWhereClause(null);</b>
<i class="no-highlight">1353</i>&nbsp;
<i class="no-highlight">1354</i>&nbsp;        final Function filter;
<i class="no-highlight">1355</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">1356</i>&nbsp;            filter = compileBooleanFilter(filterExpr, factory.getMetadata(), executionContext);</b>
<b class="fc"><i class="no-highlight">1357</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">1358</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">1359</i>&nbsp;            throw e;</b>
<b class="fc"><i class="no-highlight">1360</i>&nbsp;        }</b>
<i class="no-highlight">1361</i>&nbsp;
<b class="fc"><i class="no-highlight">1362</i>&nbsp;        if (filter.isConstant()) {</b>
<i class="no-highlight">1363</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">1364</i>&nbsp;                if (filter.getBool(null)) {</b>
<b class="fc"><i class="no-highlight">1365</i>&nbsp;                    return factory;</b>
<i class="no-highlight">1366</i>&nbsp;                }
<b class="fc"><i class="no-highlight">1367</i>&nbsp;                RecordMetadata metadata = factory.getMetadata();</b>
<b class="fc"><i class="no-highlight">1368</i>&nbsp;                assert (metadata instanceof GenericRecordMetadata);</b>
<b class="fc"><i class="no-highlight">1369</i>&nbsp;                Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">1370</i>&nbsp;                return new EmptyTableRecordCursorFactory(metadata);</b>
<i class="no-highlight">1371</i>&nbsp;            } finally {
<b class="fc"><i class="no-highlight">1372</i>&nbsp;                filter.close();</b>
<b class="nc"><i class="no-highlight">1373</i>&nbsp;            }</b>
<i class="no-highlight">1374</i>&nbsp;        }
<i class="no-highlight">1375</i>&nbsp;
<b class="fc"><i class="no-highlight">1376</i>&nbsp;        final boolean enableParallelFilter = executionContext.isParallelFilterEnabled();</b>
<b class="fc"><i class="no-highlight">1377</i>&nbsp;        final boolean preTouchColumns = configuration.isSqlParallelFilterPreTouchEnabled();</b>
<b class="fc"><i class="no-highlight">1378</i>&nbsp;        if (enableParallelFilter &amp;&amp; factory.supportPageFrameCursor()) {</b>
<i class="no-highlight">1379</i>&nbsp;
<b class="fc"><i class="no-highlight">1380</i>&nbsp;            final boolean useJit = executionContext.getJitMode() != SqlJitMode.JIT_MODE_DISABLED</b>
<b class="fc"><i class="no-highlight">1381</i>&nbsp;                    &amp;&amp; (!model.isUpdate() || executionContext.isWalApplication());</b>
<b class="fc"><i class="no-highlight">1382</i>&nbsp;            final boolean canCompile = factory.supportPageFrameCursor() &amp;&amp; JitUtil.isJitSupported();</b>
<b class="fc"><i class="no-highlight">1383</i>&nbsp;            if (useJit &amp;&amp; canCompile) {</b>
<b class="nc"><i class="no-highlight">1384</i>&nbsp;                CompiledFilter jitFilter = null;</b>
<i class="no-highlight">1385</i>&nbsp;                try {
<i class="no-highlight">1386</i>&nbsp;                    int jitOptions;
<b class="nc"><i class="no-highlight">1387</i>&nbsp;                    final ObjList&lt;Function&gt; bindVarFunctions = new ObjList&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">1388</i>&nbsp;                    try (PageFrameCursor cursor = factory.getPageFrameCursor(executionContext, ORDER_ANY)) {</b>
<b class="nc"><i class="no-highlight">1389</i>&nbsp;                        final boolean forceScalar = executionContext.getJitMode() == SqlJitMode.JIT_MODE_FORCE_SCALAR;</b>
<b class="nc"><i class="no-highlight">1390</i>&nbsp;                        jitIRSerializer.of(jitIRMem, executionContext, factory.getMetadata(), cursor, bindVarFunctions);</b>
<b class="nc"><i class="no-highlight">1391</i>&nbsp;                        jitOptions = jitIRSerializer.serialize(filterExpr, forceScalar, enableJitDebug, enableJitNullChecks);</b>
<b class="nc"><i class="no-highlight">1392</i>&nbsp;                    }</b>
<i class="no-highlight">1393</i>&nbsp;
<b class="nc"><i class="no-highlight">1394</i>&nbsp;                    jitFilter = new CompiledFilter();</b>
<b class="nc"><i class="no-highlight">1395</i>&nbsp;                    jitFilter.compile(jitIRMem, jitOptions);</b>
<i class="no-highlight">1396</i>&nbsp;
<b class="nc"><i class="no-highlight">1397</i>&nbsp;                    final Function limitLoFunction = getLimitLoFunctionOnly(model, executionContext);</b>
<b class="nc"><i class="no-highlight">1398</i>&nbsp;                    final int limitLoPos = model.getLimitAdviceLo() != null ? model.getLimitAdviceLo().position : 0;</b>
<i class="no-highlight">1399</i>&nbsp;
<b class="nc"><i class="no-highlight">1400</i>&nbsp;                    LOG.info()</b>
<b class="nc"><i class="no-highlight">1401</i>&nbsp;                            .$(&quot;JIT enabled for (sub)query [tableName=&quot;).utf8(model.getName())</b>
<b class="nc"><i class="no-highlight">1402</i>&nbsp;                            .$(&quot;, fd=&quot;).$(executionContext.getRequestFd()).$(&#39;]&#39;).$();</b>
<b class="nc"><i class="no-highlight">1403</i>&nbsp;                    return new AsyncJitFilteredRecordCursorFactory(</b>
<i class="no-highlight">1404</i>&nbsp;                            configuration,
<b class="nc"><i class="no-highlight">1405</i>&nbsp;                            executionContext.getMessageBus(),</b>
<i class="no-highlight">1406</i>&nbsp;                            factory,
<i class="no-highlight">1407</i>&nbsp;                            bindVarFunctions,
<i class="no-highlight">1408</i>&nbsp;                            filter,
<b class="nc"><i class="no-highlight">1409</i>&nbsp;                            compileWorkerFilterConditionally(</b>
<b class="nc"><i class="no-highlight">1410</i>&nbsp;                                    !filter.isReadThreadSafe(),</b>
<b class="nc"><i class="no-highlight">1411</i>&nbsp;                                    executionContext.getSharedWorkerCount(),</b>
<i class="no-highlight">1412</i>&nbsp;                                    filterExpr,
<b class="nc"><i class="no-highlight">1413</i>&nbsp;                                    factory.getMetadata(),</b>
<i class="no-highlight">1414</i>&nbsp;                                    executionContext
<i class="no-highlight">1415</i>&nbsp;                            ),
<i class="no-highlight">1416</i>&nbsp;                            jitFilter,
<i class="no-highlight">1417</i>&nbsp;                            reduceTaskPool,
<i class="no-highlight">1418</i>&nbsp;                            limitLoFunction,
<i class="no-highlight">1419</i>&nbsp;                            limitLoPos,
<i class="no-highlight">1420</i>&nbsp;                            preTouchColumns,
<b class="nc"><i class="no-highlight">1421</i>&nbsp;                            executionContext.getSharedWorkerCount()</b>
<i class="no-highlight">1422</i>&nbsp;                    );
<b class="nc"><i class="no-highlight">1423</i>&nbsp;                } catch (SqlException | LimitOverflowException ex) {</b>
<b class="nc"><i class="no-highlight">1424</i>&nbsp;                    Misc.free(jitFilter);</b>
<b class="nc"><i class="no-highlight">1425</i>&nbsp;                    LOG.debug()</b>
<b class="nc"><i class="no-highlight">1426</i>&nbsp;                            .$(&quot;JIT cannot be applied to (sub)query [tableName=&quot;).utf8(model.getName())</b>
<b class="nc"><i class="no-highlight">1427</i>&nbsp;                            .$(&quot;, ex=&quot;).$(ex.getFlyweightMessage())</b>
<b class="nc"><i class="no-highlight">1428</i>&nbsp;                            .$(&quot;, fd=&quot;).$(executionContext.getRequestFd()).$(&#39;]&#39;).$();</b>
<i class="no-highlight">1429</i>&nbsp;                } finally {
<b class="nc"><i class="no-highlight">1430</i>&nbsp;                    jitIRSerializer.clear();</b>
<b class="nc"><i class="no-highlight">1431</i>&nbsp;                    jitIRMem.truncate();</b>
<b class="nc"><i class="no-highlight">1432</i>&nbsp;                }</b>
<i class="no-highlight">1433</i>&nbsp;            }
<i class="no-highlight">1434</i>&nbsp;
<i class="no-highlight">1435</i>&nbsp;            // Use Java filter.
<i class="no-highlight">1436</i>&nbsp;            final Function limitLoFunction;
<i class="no-highlight">1437</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">1438</i>&nbsp;                limitLoFunction = getLimitLoFunctionOnly(model, executionContext);</b>
<b class="nc"><i class="no-highlight">1439</i>&nbsp;            } catch (Throwable e) {</b>
<b class="nc"><i class="no-highlight">1440</i>&nbsp;                Misc.free(filter);</b>
<b class="nc"><i class="no-highlight">1441</i>&nbsp;                Misc.free(factory);</b>
<b class="nc"><i class="no-highlight">1442</i>&nbsp;                throw e;</b>
<b class="fc"><i class="no-highlight">1443</i>&nbsp;            }</b>
<b class="fc"><i class="no-highlight">1444</i>&nbsp;            final int limitLoPos = model.getLimitAdviceLo() != null ? model.getLimitAdviceLo().position : 0;</b>
<b class="fc"><i class="no-highlight">1445</i>&nbsp;            return new AsyncFilteredRecordCursorFactory(</b>
<i class="no-highlight">1446</i>&nbsp;                    configuration,
<b class="fc"><i class="no-highlight">1447</i>&nbsp;                    executionContext.getMessageBus(),</b>
<i class="no-highlight">1448</i>&nbsp;                    factory,
<i class="no-highlight">1449</i>&nbsp;                    filter,
<i class="no-highlight">1450</i>&nbsp;                    reduceTaskPool,
<b class="fc"><i class="no-highlight">1451</i>&nbsp;                    compileWorkerFilterConditionally(</b>
<b class="fc"><i class="no-highlight">1452</i>&nbsp;                            !filter.isReadThreadSafe(),</b>
<b class="fc"><i class="no-highlight">1453</i>&nbsp;                            executionContext.getSharedWorkerCount(),</b>
<i class="no-highlight">1454</i>&nbsp;                            filterExpr,
<b class="fc"><i class="no-highlight">1455</i>&nbsp;                            factory.getMetadata(),</b>
<i class="no-highlight">1456</i>&nbsp;                            executionContext
<i class="no-highlight">1457</i>&nbsp;                    ),
<i class="no-highlight">1458</i>&nbsp;                    limitLoFunction,
<i class="no-highlight">1459</i>&nbsp;                    limitLoPos,
<i class="no-highlight">1460</i>&nbsp;                    preTouchColumns,
<b class="fc"><i class="no-highlight">1461</i>&nbsp;                    executionContext.getSharedWorkerCount()</b>
<i class="no-highlight">1462</i>&nbsp;            );
<i class="no-highlight">1463</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1464</i>&nbsp;        return new FilteredRecordCursorFactory(factory, filter);</b>
<i class="no-highlight">1465</i>&nbsp;    }
<i class="no-highlight">1466</i>&nbsp;
<i class="no-highlight">1467</i>&nbsp;    private RecordCursorFactory generateFunctionQuery(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">1468</i>&nbsp;        final Function function = model.getTableNameFunction();</b>
<b class="fc"><i class="no-highlight">1469</i>&nbsp;        if (function != null) {</b>
<i class="no-highlight">1470</i>&nbsp;            // We&#39;re transferring ownership of the function&#39;s factory to another factory
<i class="no-highlight">1471</i>&nbsp;            // setting function to NULL will prevent double-ownership.
<i class="no-highlight">1472</i>&nbsp;            // We should not release function itself, they typically just a lightweight factory wrapper.
<i class="no-highlight">1473</i>&nbsp;            // Releasing function will also release the factory, which we don&#39;t want to happen.
<b class="fc"><i class="no-highlight">1474</i>&nbsp;            model.setTableNameFunction(null);</b>
<b class="fc"><i class="no-highlight">1475</i>&nbsp;            return function.getRecordCursorFactory();</b>
<i class="no-highlight">1476</i>&nbsp;        } else {
<i class="no-highlight">1477</i>&nbsp;            // when function is null we have to recompile it from scratch, including creating new factory
<b class="fc"><i class="no-highlight">1478</i>&nbsp;            return TableUtils.createCursorFunction(functionParser, model, executionContext).getRecordCursorFactory();</b>
<i class="no-highlight">1479</i>&nbsp;        }
<i class="no-highlight">1480</i>&nbsp;    }
<i class="no-highlight">1481</i>&nbsp;
<i class="no-highlight">1482</i>&nbsp;    private RecordCursorFactory generateJoins(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">1483</i>&nbsp;        final ObjList&lt;QueryModel&gt; joinModels = model.getJoinModels();</b>
<b class="fc"><i class="no-highlight">1484</i>&nbsp;        IntList ordered = model.getOrderedJoinModels();</b>
<b class="fc"><i class="no-highlight">1485</i>&nbsp;        RecordCursorFactory master = null;</b>
<b class="fc"><i class="no-highlight">1486</i>&nbsp;        CharSequence masterAlias = null;</b>
<i class="no-highlight">1487</i>&nbsp;
<i class="no-highlight">1488</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">1489</i>&nbsp;            int n = ordered.size();</b>
<b class="fc"><i class="no-highlight">1490</i>&nbsp;            assert n &gt; 1;</b>
<b class="fc"><i class="no-highlight">1491</i>&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">1492</i>&nbsp;                int index = ordered.getQuick(i);</b>
<b class="fc"><i class="no-highlight">1493</i>&nbsp;                QueryModel slaveModel = joinModels.getQuick(index);</b>
<i class="no-highlight">1494</i>&nbsp;
<b class="fc"><i class="no-highlight">1495</i>&nbsp;                if (i &gt; 0) {</b>
<b class="fc"><i class="no-highlight">1496</i>&nbsp;                    executionContext.pushTimestampRequiredFlag(joinsRequiringTimestamp[slaveModel.getJoinType()]);</b>
<i class="no-highlight">1497</i>&nbsp;                } else { // i == 0
<i class="no-highlight">1498</i>&nbsp;                    // This is first model in the sequence of joins
<i class="no-highlight">1499</i>&nbsp;                    // TS requirement is symmetrical on both right and left sides
<i class="no-highlight">1500</i>&nbsp;                    // check if next join requires a timestamp
<b class="fc"><i class="no-highlight">1501</i>&nbsp;                    int nextJointType = joinModels.getQuick(ordered.getQuick(1)).getJoinType();</b>
<b class="fc"><i class="no-highlight">1502</i>&nbsp;                    executionContext.pushTimestampRequiredFlag(joinsRequiringTimestamp[nextJointType]);</b>
<i class="no-highlight">1503</i>&nbsp;                }
<i class="no-highlight">1504</i>&nbsp;
<b class="fc"><i class="no-highlight">1505</i>&nbsp;                RecordCursorFactory slave = null;</b>
<b class="fc"><i class="no-highlight">1506</i>&nbsp;                boolean releaseSlave = true;</b>
<i class="no-highlight">1507</i>&nbsp;                try {
<i class="no-highlight">1508</i>&nbsp;                    // compile
<b class="fc"><i class="no-highlight">1509</i>&nbsp;                    slave = generateQuery(slaveModel, executionContext, index &gt; 0);</b>
<i class="no-highlight">1510</i>&nbsp;
<i class="no-highlight">1511</i>&nbsp;                    // check if this is the root of joins
<b class="fc"><i class="no-highlight">1512</i>&nbsp;                    if (master == null) {</b>
<i class="no-highlight">1513</i>&nbsp;                        // This is an opportunistic check of order by clause
<i class="no-highlight">1514</i>&nbsp;                        // to determine if we can get away ordering main record source only
<i class="no-highlight">1515</i>&nbsp;                        // Ordering main record source could benefit from rowid access thus
<i class="no-highlight">1516</i>&nbsp;                        // making it faster compared to ordering of join record source that
<i class="no-highlight">1517</i>&nbsp;                        // doesn&#39;t allow rowid access.
<b class="fc"><i class="no-highlight">1518</i>&nbsp;                        master = slave;</b>
<b class="fc"><i class="no-highlight">1519</i>&nbsp;                        releaseSlave = false;</b>
<b class="fc"><i class="no-highlight">1520</i>&nbsp;                        masterAlias = slaveModel.getName();</b>
<i class="no-highlight">1521</i>&nbsp;                    } else {
<i class="no-highlight">1522</i>&nbsp;                        // not the root, join to &quot;master&quot;
<b class="fc"><i class="no-highlight">1523</i>&nbsp;                        final int joinType = slaveModel.getJoinType();</b>
<b class="fc"><i class="no-highlight">1524</i>&nbsp;                        final RecordMetadata masterMetadata = master.getMetadata();</b>
<b class="fc"><i class="no-highlight">1525</i>&nbsp;                        final RecordMetadata slaveMetadata = slave.getMetadata();</b>
<b class="fc"><i class="no-highlight">1526</i>&nbsp;                        Function filter = null;</b>
<i class="no-highlight">1527</i>&nbsp;                        JoinRecordMetadata joinMetadata;
<i class="no-highlight">1528</i>&nbsp;
<b class="fc"><i class="no-highlight">1529</i>&nbsp;                        switch (joinType) {</b>
<i class="no-highlight">1530</i>&nbsp;                            case JOIN_CROSS_LEFT:
<b class="fc"><i class="no-highlight">1531</i>&nbsp;                                assert slaveModel.getOuterJoinExpressionClause() != null;</b>
<b class="fc"><i class="no-highlight">1532</i>&nbsp;                                joinMetadata = createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1533</i>&nbsp;                                filter = functionParser.parseFunction(slaveModel.getOuterJoinExpressionClause(), joinMetadata, executionContext);</b>
<i class="no-highlight">1534</i>&nbsp;
<b class="fc"><i class="no-highlight">1535</i>&nbsp;                                master = new NestedLoopLeftJoinRecordCursorFactory(</b>
<i class="no-highlight">1536</i>&nbsp;                                        joinMetadata,
<i class="no-highlight">1537</i>&nbsp;                                        master,
<i class="no-highlight">1538</i>&nbsp;                                        slave,
<b class="fc"><i class="no-highlight">1539</i>&nbsp;                                        masterMetadata.getColumnCount(),</b>
<i class="no-highlight">1540</i>&nbsp;                                        filter,
<b class="fc"><i class="no-highlight">1541</i>&nbsp;                                        NullRecordFactory.getInstance(slaveMetadata)</b>
<i class="no-highlight">1542</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1543</i>&nbsp;                                masterAlias = null;</b>
<b class="fc"><i class="no-highlight">1544</i>&nbsp;                                break;</b>
<i class="no-highlight">1545</i>&nbsp;                            case JOIN_CROSS:
<b class="fc"><i class="no-highlight">1546</i>&nbsp;                                validateOuterJoinExpressions(slaveModel, &quot;CROSS&quot;);</b>
<b class="fc"><i class="no-highlight">1547</i>&nbsp;                                master = new CrossJoinRecordCursorFactory(</b>
<b class="fc"><i class="no-highlight">1548</i>&nbsp;                                        createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</b>
<i class="no-highlight">1549</i>&nbsp;                                        master,
<i class="no-highlight">1550</i>&nbsp;                                        slave,
<b class="fc"><i class="no-highlight">1551</i>&nbsp;                                        masterMetadata.getColumnCount()</b>
<i class="no-highlight">1552</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1553</i>&nbsp;                                masterAlias = null;</b>
<b class="fc"><i class="no-highlight">1554</i>&nbsp;                                break;</b>
<i class="no-highlight">1555</i>&nbsp;                            case JOIN_ASOF:
<b class="fc"><i class="no-highlight">1556</i>&nbsp;                                validateBothTimestamps(slaveModel, masterMetadata, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1557</i>&nbsp;                                validateOuterJoinExpressions(slaveModel, &quot;ASOF&quot;);</b>
<b class="fc"><i class="no-highlight">1558</i>&nbsp;                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1559</i>&nbsp;                                if (slave.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</b>
<b class="fc"><i class="no-highlight">1560</i>&nbsp;                                    if (listColumnFilterA.size() &gt; 0 &amp;&amp; listColumnFilterB.size() &gt; 0) {</b>
<b class="fc"><i class="no-highlight">1561</i>&nbsp;                                        master = createAsOfJoin(</b>
<b class="fc"><i class="no-highlight">1562</i>&nbsp;                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</b>
<i class="no-highlight">1563</i>&nbsp;                                                master,
<b class="fc"><i class="no-highlight">1564</i>&nbsp;                                                RecordSinkFactory.getInstance(</b>
<i class="no-highlight">1565</i>&nbsp;                                                        asm,
<i class="no-highlight">1566</i>&nbsp;                                                        masterMetadata,
<i class="no-highlight">1567</i>&nbsp;                                                        listColumnFilterB,
<i class="no-highlight">1568</i>&nbsp;                                                        true
<i class="no-highlight">1569</i>&nbsp;                                                ),
<i class="no-highlight">1570</i>&nbsp;                                                slave,
<b class="fc"><i class="no-highlight">1571</i>&nbsp;                                                RecordSinkFactory.getInstance(</b>
<i class="no-highlight">1572</i>&nbsp;                                                        asm,
<i class="no-highlight">1573</i>&nbsp;                                                        slaveMetadata,
<i class="no-highlight">1574</i>&nbsp;                                                        listColumnFilterA,
<i class="no-highlight">1575</i>&nbsp;                                                        true
<i class="no-highlight">1576</i>&nbsp;                                                ),
<b class="fc"><i class="no-highlight">1577</i>&nbsp;                                                masterMetadata.getColumnCount(),</b>
<b class="fc"><i class="no-highlight">1578</i>&nbsp;                                                slaveModel.getContext()</b>
<i class="no-highlight">1579</i>&nbsp;                                        );
<i class="no-highlight">1580</i>&nbsp;                                    } else {
<b class="fc"><i class="no-highlight">1581</i>&nbsp;                                        master = new AsOfJoinNoKeyRecordCursorFactory(</b>
<b class="fc"><i class="no-highlight">1582</i>&nbsp;                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</b>
<i class="no-highlight">1583</i>&nbsp;                                                master,
<i class="no-highlight">1584</i>&nbsp;                                                slave,
<b class="fc"><i class="no-highlight">1585</i>&nbsp;                                                masterMetadata.getColumnCount()</b>
<i class="no-highlight">1586</i>&nbsp;                                        );
<i class="no-highlight">1587</i>&nbsp;                                    }
<i class="no-highlight">1588</i>&nbsp;                                } else {
<b class="fc"><i class="no-highlight">1589</i>&nbsp;                                    master = createFullFatJoin(</b>
<i class="no-highlight">1590</i>&nbsp;                                            master,
<i class="no-highlight">1591</i>&nbsp;                                            masterMetadata,
<i class="no-highlight">1592</i>&nbsp;                                            masterAlias,
<i class="no-highlight">1593</i>&nbsp;                                            slave,
<i class="no-highlight">1594</i>&nbsp;                                            slaveMetadata,
<b class="fc"><i class="no-highlight">1595</i>&nbsp;                                            slaveModel.getName(),</b>
<b class="fc"><i class="no-highlight">1596</i>&nbsp;                                            slaveModel.getJoinKeywordPosition(),</b>
<i class="no-highlight">1597</i>&nbsp;                                            CREATE_FULL_FAT_AS_OF_JOIN,
<b class="fc"><i class="no-highlight">1598</i>&nbsp;                                            slaveModel.getContext()</b>
<i class="no-highlight">1599</i>&nbsp;                                    );
<i class="no-highlight">1600</i>&nbsp;                                }
<b class="fc"><i class="no-highlight">1601</i>&nbsp;                                masterAlias = null;</b>
<i class="no-highlight">1602</i>&nbsp;                                // if we fail after this step, master will release slave
<b class="fc"><i class="no-highlight">1603</i>&nbsp;                                releaseSlave = false;</b>
<b class="fc"><i class="no-highlight">1604</i>&nbsp;                                validateBothTimestampOrders(master, slave, slaveModel.getJoinKeywordPosition());</b>
<b class="fc"><i class="no-highlight">1605</i>&nbsp;                                break;</b>
<i class="no-highlight">1606</i>&nbsp;                            case JOIN_LT:
<b class="fc"><i class="no-highlight">1607</i>&nbsp;                                validateBothTimestamps(slaveModel, masterMetadata, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1608</i>&nbsp;                                validateOuterJoinExpressions(slaveModel, &quot;LT&quot;);</b>
<b class="fc"><i class="no-highlight">1609</i>&nbsp;                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1610</i>&nbsp;                                if (slave.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</b>
<b class="fc"><i class="no-highlight">1611</i>&nbsp;                                    if (listColumnFilterA.size() &gt; 0 &amp;&amp; listColumnFilterB.size() &gt; 0) {</b>
<b class="fc"><i class="no-highlight">1612</i>&nbsp;                                        master = createLtJoin(</b>
<b class="fc"><i class="no-highlight">1613</i>&nbsp;                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</b>
<i class="no-highlight">1614</i>&nbsp;                                                master,
<b class="fc"><i class="no-highlight">1615</i>&nbsp;                                                RecordSinkFactory.getInstance(</b>
<i class="no-highlight">1616</i>&nbsp;                                                        asm,
<i class="no-highlight">1617</i>&nbsp;                                                        masterMetadata,
<i class="no-highlight">1618</i>&nbsp;                                                        listColumnFilterB,
<i class="no-highlight">1619</i>&nbsp;                                                        true
<i class="no-highlight">1620</i>&nbsp;                                                ),
<i class="no-highlight">1621</i>&nbsp;                                                slave,
<b class="fc"><i class="no-highlight">1622</i>&nbsp;                                                RecordSinkFactory.getInstance(</b>
<i class="no-highlight">1623</i>&nbsp;                                                        asm,
<i class="no-highlight">1624</i>&nbsp;                                                        slaveMetadata,
<i class="no-highlight">1625</i>&nbsp;                                                        listColumnFilterA,
<i class="no-highlight">1626</i>&nbsp;                                                        true
<i class="no-highlight">1627</i>&nbsp;                                                ),
<b class="fc"><i class="no-highlight">1628</i>&nbsp;                                                masterMetadata.getColumnCount(),</b>
<b class="fc"><i class="no-highlight">1629</i>&nbsp;                                                slaveModel.getContext()</b>
<i class="no-highlight">1630</i>&nbsp;                                        );
<i class="no-highlight">1631</i>&nbsp;                                    } else {
<b class="fc"><i class="no-highlight">1632</i>&nbsp;                                        master = new LtJoinNoKeyRecordCursorFactory(</b>
<b class="fc"><i class="no-highlight">1633</i>&nbsp;                                                createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata),</b>
<i class="no-highlight">1634</i>&nbsp;                                                master,
<i class="no-highlight">1635</i>&nbsp;                                                slave,
<b class="fc"><i class="no-highlight">1636</i>&nbsp;                                                masterMetadata.getColumnCount()</b>
<i class="no-highlight">1637</i>&nbsp;                                        );
<i class="no-highlight">1638</i>&nbsp;                                    }
<i class="no-highlight">1639</i>&nbsp;                                } else {
<b class="fc"><i class="no-highlight">1640</i>&nbsp;                                    master = createFullFatJoin(</b>
<i class="no-highlight">1641</i>&nbsp;                                            master,
<i class="no-highlight">1642</i>&nbsp;                                            masterMetadata,
<i class="no-highlight">1643</i>&nbsp;                                            masterAlias,
<i class="no-highlight">1644</i>&nbsp;                                            slave,
<i class="no-highlight">1645</i>&nbsp;                                            slaveMetadata,
<b class="fc"><i class="no-highlight">1646</i>&nbsp;                                            slaveModel.getName(),</b>
<b class="fc"><i class="no-highlight">1647</i>&nbsp;                                            slaveModel.getJoinKeywordPosition(),</b>
<i class="no-highlight">1648</i>&nbsp;                                            CREATE_FULL_FAT_LT_JOIN,
<b class="fc"><i class="no-highlight">1649</i>&nbsp;                                            slaveModel.getContext()</b>
<i class="no-highlight">1650</i>&nbsp;                                    );
<i class="no-highlight">1651</i>&nbsp;                                }
<b class="fc"><i class="no-highlight">1652</i>&nbsp;                                masterAlias = null;</b>
<i class="no-highlight">1653</i>&nbsp;                                // if we fail after this step, master will release slave
<b class="fc"><i class="no-highlight">1654</i>&nbsp;                                releaseSlave = false;</b>
<b class="fc"><i class="no-highlight">1655</i>&nbsp;                                validateBothTimestampOrders(master, slave, slaveModel.getJoinKeywordPosition());</b>
<b class="fc"><i class="no-highlight">1656</i>&nbsp;                                break;</b>
<i class="no-highlight">1657</i>&nbsp;                            case JOIN_SPLICE:
<b class="fc"><i class="no-highlight">1658</i>&nbsp;                                validateBothTimestamps(slaveModel, masterMetadata, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1659</i>&nbsp;                                validateOuterJoinExpressions(slaveModel, &quot;SPLICE&quot;);</b>
<b class="fc"><i class="no-highlight">1660</i>&nbsp;                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1661</i>&nbsp;                                if (slave.recordCursorSupportsRandomAccess() &amp;&amp; master.recordCursorSupportsRandomAccess() &amp;&amp; !fullFatJoins) {</b>
<b class="fc"><i class="no-highlight">1662</i>&nbsp;                                    master = createSpliceJoin(</b>
<i class="no-highlight">1663</i>&nbsp;                                            // splice join result does not have timestamp
<b class="fc"><i class="no-highlight">1664</i>&nbsp;                                            createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata, -1),</b>
<i class="no-highlight">1665</i>&nbsp;                                            master,
<b class="fc"><i class="no-highlight">1666</i>&nbsp;                                            RecordSinkFactory.getInstance(</b>
<i class="no-highlight">1667</i>&nbsp;                                                    asm,
<i class="no-highlight">1668</i>&nbsp;                                                    masterMetadata,
<i class="no-highlight">1669</i>&nbsp;                                                    listColumnFilterB,
<i class="no-highlight">1670</i>&nbsp;                                                    true
<i class="no-highlight">1671</i>&nbsp;                                            ),
<i class="no-highlight">1672</i>&nbsp;                                            slave,
<b class="fc"><i class="no-highlight">1673</i>&nbsp;                                            RecordSinkFactory.getInstance(</b>
<i class="no-highlight">1674</i>&nbsp;                                                    asm,
<i class="no-highlight">1675</i>&nbsp;                                                    slaveMetadata,
<i class="no-highlight">1676</i>&nbsp;                                                    listColumnFilterA,
<i class="no-highlight">1677</i>&nbsp;                                                    true
<i class="no-highlight">1678</i>&nbsp;                                            ),
<b class="fc"><i class="no-highlight">1679</i>&nbsp;                                            masterMetadata.getColumnCount(),</b>
<b class="fc"><i class="no-highlight">1680</i>&nbsp;                                            slaveModel.getContext()</b>
<i class="no-highlight">1681</i>&nbsp;                                    );
<i class="no-highlight">1682</i>&nbsp;                                    // if we fail after this step, master will release slave
<b class="fc"><i class="no-highlight">1683</i>&nbsp;                                    releaseSlave = false;</b>
<b class="fc"><i class="no-highlight">1684</i>&nbsp;                                    validateBothTimestampOrders(master, slave, slaveModel.getJoinKeywordPosition());</b>
<i class="no-highlight">1685</i>&nbsp;                                } else {
<b class="nc"><i class="no-highlight">1686</i>&nbsp;                                    assert false;</b>
<i class="no-highlight">1687</i>&nbsp;                                }
<i class="no-highlight">1688</i>&nbsp;                                break;
<i class="no-highlight">1689</i>&nbsp;                            default:
<b class="fc"><i class="no-highlight">1690</i>&nbsp;                                processJoinContext(index == 1, slaveModel.getContext(), masterMetadata, slaveMetadata);</b>
<i class="no-highlight">1691</i>&nbsp;
<b class="fc"><i class="no-highlight">1692</i>&nbsp;                                joinMetadata = createJoinMetadata(masterAlias, masterMetadata, slaveModel.getName(), slaveMetadata);</b>
<b class="fc"><i class="no-highlight">1693</i>&nbsp;                                if (slaveModel.getOuterJoinExpressionClause() != null) {</b>
<b class="fc"><i class="no-highlight">1694</i>&nbsp;                                    filter = functionParser.parseFunction(slaveModel.getOuterJoinExpressionClause(), joinMetadata, executionContext);</b>
<i class="no-highlight">1695</i>&nbsp;                                }
<i class="no-highlight">1696</i>&nbsp;
<b class="fc"><i class="no-highlight">1697</i>&nbsp;                                if (joinType == JOIN_OUTER &amp;&amp;</b>
<b class="fc"><i class="no-highlight">1698</i>&nbsp;                                        filter != null &amp;&amp; filter.isConstant() &amp;&amp; !filter.getBool(null)) {</b>
<b class="fc"><i class="no-highlight">1699</i>&nbsp;                                    Misc.free(slave);</b>
<b class="fc"><i class="no-highlight">1700</i>&nbsp;                                    slave = new EmptyTableRecordCursorFactory(slaveMetadata);</b>
<i class="no-highlight">1701</i>&nbsp;                                }
<i class="no-highlight">1702</i>&nbsp;
<b class="fc"><i class="no-highlight">1703</i>&nbsp;                                if (joinType == JOIN_INNER) {</b>
<b class="fc"><i class="no-highlight">1704</i>&nbsp;                                    validateOuterJoinExpressions(slaveModel, &quot;INNER&quot;);</b>
<i class="no-highlight">1705</i>&nbsp;                                }
<i class="no-highlight">1706</i>&nbsp;
<b class="fc"><i class="no-highlight">1707</i>&nbsp;                                master = createHashJoin(</b>
<i class="no-highlight">1708</i>&nbsp;                                        joinMetadata,
<i class="no-highlight">1709</i>&nbsp;                                        master,
<i class="no-highlight">1710</i>&nbsp;                                        slave,
<i class="no-highlight">1711</i>&nbsp;                                        joinType,
<i class="no-highlight">1712</i>&nbsp;                                        filter,
<b class="fc"><i class="no-highlight">1713</i>&nbsp;                                        slaveModel.getContext()</b>
<i class="no-highlight">1714</i>&nbsp;                                );
<b class="fc"><i class="no-highlight">1715</i>&nbsp;                                masterAlias = null;</b>
<i class="no-highlight">1716</i>&nbsp;                                break;
<i class="no-highlight">1717</i>&nbsp;                        }
<i class="no-highlight">1718</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">1719</i>&nbsp;                } catch (Throwable th) {</b>
<b class="fc"><i class="no-highlight">1720</i>&nbsp;                    master = Misc.free(master);</b>
<b class="fc"><i class="no-highlight">1721</i>&nbsp;                    if (releaseSlave) {</b>
<b class="fc"><i class="no-highlight">1722</i>&nbsp;                        Misc.free(slave);</b>
<i class="no-highlight">1723</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">1724</i>&nbsp;                    throw th;</b>
<i class="no-highlight">1725</i>&nbsp;                } finally {
<b class="fc"><i class="no-highlight">1726</i>&nbsp;                    executionContext.popTimestampRequiredFlag();</b>
<b class="fc"><i class="no-highlight">1727</i>&nbsp;                }</b>
<i class="no-highlight">1728</i>&nbsp;
<i class="no-highlight">1729</i>&nbsp;                // check if there are post-filters
<b class="fc"><i class="no-highlight">1730</i>&nbsp;                ExpressionNode filterExpr = slaveModel.getPostJoinWhereClause();</b>
<b class="fc"><i class="no-highlight">1731</i>&nbsp;                if (filterExpr != null) {</b>
<b class="fc"><i class="no-highlight">1732</i>&nbsp;                    if (executionContext.isParallelFilterEnabled() &amp;&amp; master.supportPageFrameCursor()) {</b>
<b class="nc"><i class="no-highlight">1733</i>&nbsp;                        final Function filter = compileBooleanFilter(</b>
<i class="no-highlight">1734</i>&nbsp;                                filterExpr,
<b class="nc"><i class="no-highlight">1735</i>&nbsp;                                master.getMetadata(),</b>
<i class="no-highlight">1736</i>&nbsp;                                executionContext
<i class="no-highlight">1737</i>&nbsp;                        );
<i class="no-highlight">1738</i>&nbsp;
<b class="nc"><i class="no-highlight">1739</i>&nbsp;                        master = new AsyncFilteredRecordCursorFactory(</b>
<i class="no-highlight">1740</i>&nbsp;                                configuration,
<b class="nc"><i class="no-highlight">1741</i>&nbsp;                                executionContext.getMessageBus(),</b>
<i class="no-highlight">1742</i>&nbsp;                                master,
<i class="no-highlight">1743</i>&nbsp;                                filter,
<i class="no-highlight">1744</i>&nbsp;                                reduceTaskPool,
<b class="nc"><i class="no-highlight">1745</i>&nbsp;                                compileWorkerFilterConditionally(</b>
<b class="nc"><i class="no-highlight">1746</i>&nbsp;                                        !filter.isReadThreadSafe(),</b>
<b class="nc"><i class="no-highlight">1747</i>&nbsp;                                        executionContext.getSharedWorkerCount(),</b>
<i class="no-highlight">1748</i>&nbsp;                                        filterExpr,
<b class="nc"><i class="no-highlight">1749</i>&nbsp;                                        master.getMetadata(),</b>
<i class="no-highlight">1750</i>&nbsp;                                        executionContext
<i class="no-highlight">1751</i>&nbsp;                                ),
<i class="no-highlight">1752</i>&nbsp;                                null,
<i class="no-highlight">1753</i>&nbsp;                                0,
<i class="no-highlight">1754</i>&nbsp;                                false,
<b class="nc"><i class="no-highlight">1755</i>&nbsp;                                executionContext.getSharedWorkerCount()</b>
<i class="no-highlight">1756</i>&nbsp;                        );
<b class="nc"><i class="no-highlight">1757</i>&nbsp;                    } else {</b>
<b class="fc"><i class="no-highlight">1758</i>&nbsp;                        master = new FilteredRecordCursorFactory(</b>
<i class="no-highlight">1759</i>&nbsp;                                master,
<b class="fc"><i class="no-highlight">1760</i>&nbsp;                                functionParser.parseFunction(filterExpr, master.getMetadata(), executionContext)</b>
<i class="no-highlight">1761</i>&nbsp;                        );
<i class="no-highlight">1762</i>&nbsp;                    }
<i class="no-highlight">1763</i>&nbsp;                }
<i class="no-highlight">1764</i>&nbsp;            }
<i class="no-highlight">1765</i>&nbsp;
<i class="no-highlight">1766</i>&nbsp;            // unfortunately we had to go all out to create join metadata
<i class="no-highlight">1767</i>&nbsp;            // now it is time to check if we have constant conditions
<b class="fc"><i class="no-highlight">1768</i>&nbsp;            ExpressionNode constFilter = model.getConstWhereClause();</b>
<b class="fc"><i class="no-highlight">1769</i>&nbsp;            if (constFilter != null) {</b>
<b class="fc"><i class="no-highlight">1770</i>&nbsp;                Function function = functionParser.parseFunction(constFilter, null, executionContext);</b>
<b class="fc"><i class="no-highlight">1771</i>&nbsp;                if (!function.getBool(null)) {</b>
<i class="no-highlight">1772</i>&nbsp;                    // do not copy metadata here
<i class="no-highlight">1773</i>&nbsp;                    // this would have been JoinRecordMetadata, which is new instance anyway
<i class="no-highlight">1774</i>&nbsp;                    // we have to make sure that this metadata is safely transitioned
<i class="no-highlight">1775</i>&nbsp;                    // to empty cursor factory
<b class="fc"><i class="no-highlight">1776</i>&nbsp;                    JoinRecordMetadata metadata = (JoinRecordMetadata) master.getMetadata();</b>
<b class="fc"><i class="no-highlight">1777</i>&nbsp;                    metadata.incrementRefCount();</b>
<b class="fc"><i class="no-highlight">1778</i>&nbsp;                    RecordCursorFactory factory = new EmptyTableRecordCursorFactory(metadata);</b>
<b class="fc"><i class="no-highlight">1779</i>&nbsp;                    Misc.free(master);</b>
<b class="fc"><i class="no-highlight">1780</i>&nbsp;                    return factory;</b>
<i class="no-highlight">1781</i>&nbsp;                }
<i class="no-highlight">1782</i>&nbsp;            }
<b class="fc"><i class="no-highlight">1783</i>&nbsp;            return master;</b>
<b class="fc"><i class="no-highlight">1784</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">1785</i>&nbsp;            Misc.free(master);</b>
<b class="fc"><i class="no-highlight">1786</i>&nbsp;            throw e;</b>
<i class="no-highlight">1787</i>&nbsp;        }
<i class="no-highlight">1788</i>&nbsp;    }
<i class="no-highlight">1789</i>&nbsp;
<i class="no-highlight">1790</i>&nbsp;    @NotNull
<i class="no-highlight">1791</i>&nbsp;    private RecordCursorFactory generateLatestBy(RecordCursorFactory factory, QueryModel model) throws SqlException {
<b class="fc"><i class="no-highlight">1792</i>&nbsp;        final ObjList&lt;ExpressionNode&gt; latestBy = model.getLatestBy();</b>
<b class="fc"><i class="no-highlight">1793</i>&nbsp;        if (latestBy.size() == 0) {</b>
<b class="fc"><i class="no-highlight">1794</i>&nbsp;            return factory;</b>
<i class="no-highlight">1795</i>&nbsp;        }
<i class="no-highlight">1796</i>&nbsp;
<i class="no-highlight">1797</i>&nbsp;        // We require timestamp with any order.
<i class="no-highlight">1798</i>&nbsp;        final int timestampIndex;
<i class="no-highlight">1799</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">1800</i>&nbsp;            timestampIndex = getTimestampIndex(model, factory);</b>
<b class="fc"><i class="no-highlight">1801</i>&nbsp;            if (timestampIndex == -1) {</b>
<b class="fc"><i class="no-highlight">1802</i>&nbsp;                throw SqlException.$(model.getModelPosition(), &quot;latest by query does not provide dedicated TIMESTAMP column&quot;);</b>
<i class="no-highlight">1803</i>&nbsp;            }
<b class="fc"><i class="no-highlight">1804</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">1805</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">1806</i>&nbsp;            throw e;</b>
<b class="fc"><i class="no-highlight">1807</i>&nbsp;        }</b>
<i class="no-highlight">1808</i>&nbsp;
<b class="fc"><i class="no-highlight">1809</i>&nbsp;        final RecordMetadata metadata = factory.getMetadata();</b>
<b class="fc"><i class="no-highlight">1810</i>&nbsp;        prepareLatestByColumnIndexes(latestBy, metadata);</b>
<i class="no-highlight">1811</i>&nbsp;
<b class="fc"><i class="no-highlight">1812</i>&nbsp;        if (!factory.recordCursorSupportsRandomAccess()) {</b>
<b class="fc"><i class="no-highlight">1813</i>&nbsp;            return new LatestByRecordCursorFactory(</b>
<i class="no-highlight">1814</i>&nbsp;                    configuration,
<i class="no-highlight">1815</i>&nbsp;                    factory,
<b class="fc"><i class="no-highlight">1816</i>&nbsp;                    RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</b>
<i class="no-highlight">1817</i>&nbsp;                    keyTypes,
<i class="no-highlight">1818</i>&nbsp;                    timestampIndex
<i class="no-highlight">1819</i>&nbsp;            );
<i class="no-highlight">1820</i>&nbsp;        }
<i class="no-highlight">1821</i>&nbsp;
<b class="fc"><i class="no-highlight">1822</i>&nbsp;        boolean orderedByTimestampAsc = false;</b>
<b class="fc"><i class="no-highlight">1823</i>&nbsp;        final QueryModel nested = model.getNestedModel();</b>
<b class="fc"><i class="no-highlight">1824</i>&nbsp;        assert nested != null;</b>
<b class="fc"><i class="no-highlight">1825</i>&nbsp;        final LowerCaseCharSequenceIntHashMap orderBy = nested.getOrderHash();</b>
<b class="fc"><i class="no-highlight">1826</i>&nbsp;        CharSequence timestampColumn = metadata.getColumnName(timestampIndex);</b>
<b class="fc"><i class="no-highlight">1827</i>&nbsp;        if (orderBy.get(timestampColumn) == QueryModel.ORDER_DIRECTION_ASCENDING) {</b>
<i class="no-highlight">1828</i>&nbsp;            // ORDER BY the timestamp column case.
<b class="fc"><i class="no-highlight">1829</i>&nbsp;            orderedByTimestampAsc = true;</b>
<b class="fc"><i class="no-highlight">1830</i>&nbsp;        } else if (timestampIndex == metadata.getTimestampIndex() &amp;&amp; orderBy.size() == 0) {</b>
<i class="no-highlight">1831</i>&nbsp;            // Empty ORDER BY, but the timestamp column in the designated timestamp.
<b class="fc"><i class="no-highlight">1832</i>&nbsp;            orderedByTimestampAsc = true;</b>
<i class="no-highlight">1833</i>&nbsp;        }
<i class="no-highlight">1834</i>&nbsp;
<b class="fc"><i class="no-highlight">1835</i>&nbsp;        return new LatestByLightRecordCursorFactory(</b>
<i class="no-highlight">1836</i>&nbsp;                configuration,
<i class="no-highlight">1837</i>&nbsp;                factory,
<b class="fc"><i class="no-highlight">1838</i>&nbsp;                RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</b>
<i class="no-highlight">1839</i>&nbsp;                keyTypes,
<i class="no-highlight">1840</i>&nbsp;                timestampIndex,
<i class="no-highlight">1841</i>&nbsp;                orderedByTimestampAsc
<i class="no-highlight">1842</i>&nbsp;        );
<i class="no-highlight">1843</i>&nbsp;    }
<i class="no-highlight">1844</i>&nbsp;
<i class="no-highlight">1845</i>&nbsp;    @NotNull
<i class="no-highlight">1846</i>&nbsp;    private RecordCursorFactory generateLatestByTableQuery(
<i class="no-highlight">1847</i>&nbsp;            QueryModel model,
<i class="no-highlight">1848</i>&nbsp;            @Transient TableReader reader,
<i class="no-highlight">1849</i>&nbsp;            RecordMetadata metadata,
<i class="no-highlight">1850</i>&nbsp;            TableToken tableToken,
<i class="no-highlight">1851</i>&nbsp;            IntrinsicModel intrinsicModel,
<i class="no-highlight">1852</i>&nbsp;            Function filter,
<i class="no-highlight">1853</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">1854</i>&nbsp;            int timestampIndex,
<i class="no-highlight">1855</i>&nbsp;            @NotNull IntList columnIndexes,
<i class="no-highlight">1856</i>&nbsp;            @NotNull IntList columnSizes,
<i class="no-highlight">1857</i>&nbsp;            @NotNull LongList prefixes
<i class="no-highlight">1858</i>&nbsp;    ) throws SqlException {
<i class="no-highlight">1859</i>&nbsp;        final DataFrameCursorFactory dataFrameCursorFactory;
<b class="fc"><i class="no-highlight">1860</i>&nbsp;        if (intrinsicModel.hasIntervalFilters()) {</b>
<b class="fc"><i class="no-highlight">1861</i>&nbsp;            dataFrameCursorFactory = new IntervalBwdDataFrameCursorFactory(</b>
<i class="no-highlight">1862</i>&nbsp;                    tableToken,
<b class="fc"><i class="no-highlight">1863</i>&nbsp;                    model.getTableId(),</b>
<b class="fc"><i class="no-highlight">1864</i>&nbsp;                    model.getTableVersion(),</b>
<b class="fc"><i class="no-highlight">1865</i>&nbsp;                    intrinsicModel.buildIntervalModel(),</b>
<i class="no-highlight">1866</i>&nbsp;                    timestampIndex,
<b class="fc"><i class="no-highlight">1867</i>&nbsp;                    GenericRecordMetadata.deepCopyOf(reader.getMetadata())</b>
<i class="no-highlight">1868</i>&nbsp;            );
<i class="no-highlight">1869</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1870</i>&nbsp;            dataFrameCursorFactory = new FullBwdDataFrameCursorFactory(</b>
<i class="no-highlight">1871</i>&nbsp;                    tableToken,
<b class="fc"><i class="no-highlight">1872</i>&nbsp;                    model.getTableId(),</b>
<b class="fc"><i class="no-highlight">1873</i>&nbsp;                    model.getTableVersion(),</b>
<b class="fc"><i class="no-highlight">1874</i>&nbsp;                    GenericRecordMetadata.deepCopyOf(reader.getMetadata())</b>
<i class="no-highlight">1875</i>&nbsp;            );
<i class="no-highlight">1876</i>&nbsp;        }
<i class="no-highlight">1877</i>&nbsp;
<b class="fc"><i class="no-highlight">1878</i>&nbsp;        assert model.getLatestBy() != null &amp;&amp; model.getLatestBy().size() &gt; 0;</b>
<b class="fc"><i class="no-highlight">1879</i>&nbsp;        ObjList&lt;ExpressionNode&gt; latestBy = new ObjList&lt;&gt;(model.getLatestBy().size());</b>
<b class="fc"><i class="no-highlight">1880</i>&nbsp;        latestBy.addAll(model.getLatestBy());</b>
<b class="fc"><i class="no-highlight">1881</i>&nbsp;        final ExpressionNode latestByNode = latestBy.get(0);</b>
<b class="fc"><i class="no-highlight">1882</i>&nbsp;        final int latestByIndex = metadata.getColumnIndexQuiet(latestByNode.token);</b>
<b class="fc"><i class="no-highlight">1883</i>&nbsp;        final boolean indexed = metadata.isColumnIndexed(latestByIndex);</b>
<i class="no-highlight">1884</i>&nbsp;
<i class="no-highlight">1885</i>&nbsp;        // &#39;latest by&#39; clause takes over the filter and the latest by nodes,
<i class="no-highlight">1886</i>&nbsp;        // so that the later generateFilter() and generateLatestBy() are no-op
<b class="fc"><i class="no-highlight">1887</i>&nbsp;        model.setWhereClause(null);</b>
<b class="fc"><i class="no-highlight">1888</i>&nbsp;        model.getLatestBy().clear();</b>
<i class="no-highlight">1889</i>&nbsp;
<i class="no-highlight">1890</i>&nbsp;        // if there are &gt; 1 columns in the latest by statement, we cannot use indexes
<b class="fc"><i class="no-highlight">1891</i>&nbsp;        if (latestBy.size() &gt; 1 || !ColumnType.isSymbol(metadata.getColumnType(latestByIndex))) {</b>
<b class="fc"><i class="no-highlight">1892</i>&nbsp;            boolean symbolKeysOnly = true;</b>
<b class="fc"><i class="no-highlight">1893</i>&nbsp;            for (int i = 0, n = keyTypes.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">1894</i>&nbsp;                symbolKeysOnly &amp;= ColumnType.isSymbol(keyTypes.getColumnType(i));</b>
<i class="no-highlight">1895</i>&nbsp;            }
<b class="fc"><i class="no-highlight">1896</i>&nbsp;            if (symbolKeysOnly) {</b>
<b class="fc"><i class="no-highlight">1897</i>&nbsp;                final IntList partitionByColumnIndexes = new IntList(listColumnFilterA.size());</b>
<b class="fc"><i class="no-highlight">1898</i>&nbsp;                for (int i = 0, n = listColumnFilterA.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">1899</i>&nbsp;                    partitionByColumnIndexes.add(listColumnFilterA.getColumnIndexFactored(i));</b>
<i class="no-highlight">1900</i>&nbsp;                }
<b class="fc"><i class="no-highlight">1901</i>&nbsp;                final IntList partitionBySymbolCounts = symbolEstimator.estimate(</b>
<i class="no-highlight">1902</i>&nbsp;                        model,
<i class="no-highlight">1903</i>&nbsp;                        intrinsicModel.filter,
<i class="no-highlight">1904</i>&nbsp;                        metadata,
<i class="no-highlight">1905</i>&nbsp;                        partitionByColumnIndexes
<i class="no-highlight">1906</i>&nbsp;                );
<b class="fc"><i class="no-highlight">1907</i>&nbsp;                return new LatestByAllSymbolsFilteredRecordCursorFactory(</b>
<i class="no-highlight">1908</i>&nbsp;                        metadata,
<i class="no-highlight">1909</i>&nbsp;                        configuration,
<i class="no-highlight">1910</i>&nbsp;                        dataFrameCursorFactory,
<b class="fc"><i class="no-highlight">1911</i>&nbsp;                        RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</b>
<i class="no-highlight">1912</i>&nbsp;                        keyTypes,
<i class="no-highlight">1913</i>&nbsp;                        partitionByColumnIndexes,
<i class="no-highlight">1914</i>&nbsp;                        partitionBySymbolCounts,
<i class="no-highlight">1915</i>&nbsp;                        filter,
<i class="no-highlight">1916</i>&nbsp;                        columnIndexes
<i class="no-highlight">1917</i>&nbsp;                );
<i class="no-highlight">1918</i>&nbsp;            }
<b class="fc"><i class="no-highlight">1919</i>&nbsp;            return new LatestByAllFilteredRecordCursorFactory(</b>
<i class="no-highlight">1920</i>&nbsp;                    metadata,
<i class="no-highlight">1921</i>&nbsp;                    configuration,
<i class="no-highlight">1922</i>&nbsp;                    dataFrameCursorFactory,
<b class="fc"><i class="no-highlight">1923</i>&nbsp;                    RecordSinkFactory.getInstance(asm, metadata, listColumnFilterA, false),</b>
<i class="no-highlight">1924</i>&nbsp;                    keyTypes,
<i class="no-highlight">1925</i>&nbsp;                    filter,
<i class="no-highlight">1926</i>&nbsp;                    columnIndexes
<i class="no-highlight">1927</i>&nbsp;            );
<i class="no-highlight">1928</i>&nbsp;        }
<i class="no-highlight">1929</i>&nbsp;
<b class="fc"><i class="no-highlight">1930</i>&nbsp;        if (intrinsicModel.keyColumn != null) {</b>
<i class="no-highlight">1931</i>&nbsp;            // key column must always be the same as latest by column
<b class="fc"><i class="no-highlight">1932</i>&nbsp;            assert latestByIndex == metadata.getColumnIndexQuiet(intrinsicModel.keyColumn);</b>
<i class="no-highlight">1933</i>&nbsp;
<b class="fc"><i class="no-highlight">1934</i>&nbsp;            if (intrinsicModel.keySubQuery != null) {</b>
<i class="no-highlight">1935</i>&nbsp;                final RecordCursorFactory rcf;
<i class="no-highlight">1936</i>&nbsp;                final Record.CharSequenceFunction func;
<i class="no-highlight">1937</i>&nbsp;                try {
<b class="fc"><i class="no-highlight">1938</i>&nbsp;                    rcf = generate(intrinsicModel.keySubQuery, executionContext);</b>
<b class="fc"><i class="no-highlight">1939</i>&nbsp;                    func = validateSubQueryColumnAndGetGetter(intrinsicModel, rcf.getMetadata());</b>
<b class="fc"><i class="no-highlight">1940</i>&nbsp;                } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">1941</i>&nbsp;                    Misc.free(dataFrameCursorFactory);</b>
<b class="fc"><i class="no-highlight">1942</i>&nbsp;                    throw e;</b>
<b class="fc"><i class="no-highlight">1943</i>&nbsp;                }</b>
<i class="no-highlight">1944</i>&nbsp;
<b class="fc"><i class="no-highlight">1945</i>&nbsp;                return new LatestBySubQueryRecordCursorFactory(</b>
<i class="no-highlight">1946</i>&nbsp;                        configuration,
<i class="no-highlight">1947</i>&nbsp;                        metadata,
<i class="no-highlight">1948</i>&nbsp;                        dataFrameCursorFactory,
<i class="no-highlight">1949</i>&nbsp;                        latestByIndex,
<i class="no-highlight">1950</i>&nbsp;                        rcf,
<i class="no-highlight">1951</i>&nbsp;                        filter,
<i class="no-highlight">1952</i>&nbsp;                        indexed,
<i class="no-highlight">1953</i>&nbsp;                        func,
<i class="no-highlight">1954</i>&nbsp;                        columnIndexes
<i class="no-highlight">1955</i>&nbsp;                );
<i class="no-highlight">1956</i>&nbsp;            }
<i class="no-highlight">1957</i>&nbsp;
<b class="fc"><i class="no-highlight">1958</i>&nbsp;            final int nKeyValues = intrinsicModel.keyValueFuncs.size();</b>
<b class="fc"><i class="no-highlight">1959</i>&nbsp;            final int nExcludedKeyValues = intrinsicModel.keyExcludedValueFuncs.size();</b>
<b class="fc"><i class="no-highlight">1960</i>&nbsp;            if (indexed &amp;&amp; nExcludedKeyValues == 0) {</b>
<b class="fc"><i class="no-highlight">1961</i>&nbsp;                assert nKeyValues &gt; 0;</b>
<i class="no-highlight">1962</i>&nbsp;                // deal with key values as a list
<i class="no-highlight">1963</i>&nbsp;                // 1. resolve each value of the list to &quot;int&quot;
<i class="no-highlight">1964</i>&nbsp;                // 2. get first row in index for each value (stream)
<i class="no-highlight">1965</i>&nbsp;
<b class="fc"><i class="no-highlight">1966</i>&nbsp;                final SymbolMapReader symbolMapReader = reader.getSymbolMapReader(columnIndexes.getQuick(latestByIndex));</b>
<i class="no-highlight">1967</i>&nbsp;                final RowCursorFactory rcf;
<b class="fc"><i class="no-highlight">1968</i>&nbsp;                if (nKeyValues == 1) {</b>
<b class="fc"><i class="no-highlight">1969</i>&nbsp;                    final Function symbolValueFunc = intrinsicModel.keyValueFuncs.get(0);</b>
<b class="fc"><i class="no-highlight">1970</i>&nbsp;                    final int symbol = symbolValueFunc.isRuntimeConstant()</b>
<b class="fc"><i class="no-highlight">1971</i>&nbsp;                            ? SymbolTable.VALUE_NOT_FOUND</b>
<b class="fc"><i class="no-highlight">1972</i>&nbsp;                            : symbolMapReader.keyOf(symbolValueFunc.getStr(null));</b>
<i class="no-highlight">1973</i>&nbsp;
<b class="fc"><i class="no-highlight">1974</i>&nbsp;                    if (filter == null) {</b>
<b class="fc"><i class="no-highlight">1975</i>&nbsp;                        if (symbol == SymbolTable.VALUE_NOT_FOUND) {</b>
<b class="fc"><i class="no-highlight">1976</i>&nbsp;                            rcf = new LatestByValueDeferredIndexedRowCursorFactory(</b>
<b class="fc"><i class="no-highlight">1977</i>&nbsp;                                    columnIndexes.getQuick(latestByIndex),</b>
<i class="no-highlight">1978</i>&nbsp;                                    symbolValueFunc,
<i class="no-highlight">1979</i>&nbsp;                                    false
<i class="no-highlight">1980</i>&nbsp;                            );
<i class="no-highlight">1981</i>&nbsp;                        } else {
<b class="fc"><i class="no-highlight">1982</i>&nbsp;                            rcf = new LatestByValueIndexedRowCursorFactory(</b>
<b class="fc"><i class="no-highlight">1983</i>&nbsp;                                    columnIndexes.getQuick(latestByIndex),</b>
<i class="no-highlight">1984</i>&nbsp;                                    symbol,
<i class="no-highlight">1985</i>&nbsp;                                    false
<i class="no-highlight">1986</i>&nbsp;                            );
<i class="no-highlight">1987</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">1988</i>&nbsp;                        return new DataFrameRecordCursorFactory(</b>
<i class="no-highlight">1989</i>&nbsp;                                configuration,
<i class="no-highlight">1990</i>&nbsp;                                metadata,
<i class="no-highlight">1991</i>&nbsp;                                dataFrameCursorFactory,
<i class="no-highlight">1992</i>&nbsp;                                rcf,
<i class="no-highlight">1993</i>&nbsp;                                false,
<i class="no-highlight">1994</i>&nbsp;                                null,
<i class="no-highlight">1995</i>&nbsp;                                false,
<i class="no-highlight">1996</i>&nbsp;                                columnIndexes,
<i class="no-highlight">1997</i>&nbsp;                                columnSizes,
<i class="no-highlight">1998</i>&nbsp;                                true
<i class="no-highlight">1999</i>&nbsp;                        );
<i class="no-highlight">2000</i>&nbsp;                    }
<i class="no-highlight">2001</i>&nbsp;
<b class="fc"><i class="no-highlight">2002</i>&nbsp;                    if (symbol == SymbolTable.VALUE_NOT_FOUND) {</b>
<b class="fc"><i class="no-highlight">2003</i>&nbsp;                        return new LatestByValueDeferredIndexedFilteredRecordCursorFactory(</b>
<i class="no-highlight">2004</i>&nbsp;                                metadata,
<i class="no-highlight">2005</i>&nbsp;                                dataFrameCursorFactory,
<i class="no-highlight">2006</i>&nbsp;                                latestByIndex,
<i class="no-highlight">2007</i>&nbsp;                                symbolValueFunc,
<i class="no-highlight">2008</i>&nbsp;                                filter,
<i class="no-highlight">2009</i>&nbsp;                                columnIndexes
<i class="no-highlight">2010</i>&nbsp;                        );
<i class="no-highlight">2011</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">2012</i>&nbsp;                    return new LatestByValueIndexedFilteredRecordCursorFactory(</b>
<i class="no-highlight">2013</i>&nbsp;                            metadata,
<i class="no-highlight">2014</i>&nbsp;                            dataFrameCursorFactory,
<i class="no-highlight">2015</i>&nbsp;                            latestByIndex,
<i class="no-highlight">2016</i>&nbsp;                            symbol,
<i class="no-highlight">2017</i>&nbsp;                            filter,
<i class="no-highlight">2018</i>&nbsp;                            columnIndexes
<i class="no-highlight">2019</i>&nbsp;                    );
<i class="no-highlight">2020</i>&nbsp;                }
<i class="no-highlight">2021</i>&nbsp;
<b class="fc"><i class="no-highlight">2022</i>&nbsp;                return new LatestByValuesIndexedFilteredRecordCursorFactory(</b>
<i class="no-highlight">2023</i>&nbsp;                        configuration,
<i class="no-highlight">2024</i>&nbsp;                        metadata,
<i class="no-highlight">2025</i>&nbsp;                        dataFrameCursorFactory,
<i class="no-highlight">2026</i>&nbsp;                        latestByIndex,
<i class="no-highlight">2027</i>&nbsp;                        intrinsicModel.keyValueFuncs,
<i class="no-highlight">2028</i>&nbsp;                        symbolMapReader,
<i class="no-highlight">2029</i>&nbsp;                        filter,
<i class="no-highlight">2030</i>&nbsp;                        columnIndexes
<i class="no-highlight">2031</i>&nbsp;                );
<i class="no-highlight">2032</i>&nbsp;            }
<i class="no-highlight">2033</i>&nbsp;
<b class="fc"><i class="no-highlight">2034</i>&nbsp;            assert nKeyValues &gt; 0 || nExcludedKeyValues &gt; 0;</b>
<i class="no-highlight">2035</i>&nbsp;
<i class="no-highlight">2036</i>&nbsp;            // we have &quot;latest by&quot; column values, but no index
<i class="no-highlight">2037</i>&nbsp;
<b class="fc"><i class="no-highlight">2038</i>&nbsp;            if (nKeyValues &gt; 1 || nExcludedKeyValues &gt; 0) {</b>
<b class="fc"><i class="no-highlight">2039</i>&nbsp;                return new LatestByDeferredListValuesFilteredRecordCursorFactory(</b>
<i class="no-highlight">2040</i>&nbsp;                        configuration,
<i class="no-highlight">2041</i>&nbsp;                        metadata,
<i class="no-highlight">2042</i>&nbsp;                        dataFrameCursorFactory,
<i class="no-highlight">2043</i>&nbsp;                        latestByIndex,
<i class="no-highlight">2044</i>&nbsp;                        intrinsicModel.keyValueFuncs,
<i class="no-highlight">2045</i>&nbsp;                        intrinsicModel.keyExcludedValueFuncs,
<i class="no-highlight">2046</i>&nbsp;                        filter,
<i class="no-highlight">2047</i>&nbsp;                        columnIndexes
<i class="no-highlight">2048</i>&nbsp;                );
<i class="no-highlight">2049</i>&nbsp;            }
<i class="no-highlight">2050</i>&nbsp;
<b class="fc"><i class="no-highlight">2051</i>&nbsp;            assert nExcludedKeyValues == 0;</b>
<i class="no-highlight">2052</i>&nbsp;
<i class="no-highlight">2053</i>&nbsp;            // we have a single symbol key
<b class="fc"><i class="no-highlight">2054</i>&nbsp;            final Function symbolKeyFunc = intrinsicModel.keyValueFuncs.get(0);</b>
<b class="fc"><i class="no-highlight">2055</i>&nbsp;            final SymbolMapReader symbolMapReader = reader.getSymbolMapReader(columnIndexes.getQuick(latestByIndex));</b>
<b class="fc"><i class="no-highlight">2056</i>&nbsp;            final int symbolKey = symbolKeyFunc.isRuntimeConstant()</b>
<b class="fc"><i class="no-highlight">2057</i>&nbsp;                    ? SymbolTable.VALUE_NOT_FOUND</b>
<b class="fc"><i class="no-highlight">2058</i>&nbsp;                    : symbolMapReader.keyOf(symbolKeyFunc.getStr(null));</b>
<b class="fc"><i class="no-highlight">2059</i>&nbsp;            if (symbolKey == SymbolTable.VALUE_NOT_FOUND) {</b>
<b class="fc"><i class="no-highlight">2060</i>&nbsp;                return new LatestByValueDeferredFilteredRecordCursorFactory(</b>
<i class="no-highlight">2061</i>&nbsp;                        metadata,
<i class="no-highlight">2062</i>&nbsp;                        dataFrameCursorFactory,
<i class="no-highlight">2063</i>&nbsp;                        latestByIndex,
<i class="no-highlight">2064</i>&nbsp;                        symbolKeyFunc,
<i class="no-highlight">2065</i>&nbsp;                        filter,
<i class="no-highlight">2066</i>&nbsp;                        columnIndexes
<i class="no-highlight">2067</i>&nbsp;                );
<i class="no-highlight">2068</i>&nbsp;            }
<i class="no-highlight">2069</i>&nbsp;
<b class="fc"><i class="no-highlight">2070</i>&nbsp;            return new LatestByValueFilteredRecordCursorFactory(</b>
<i class="no-highlight">2071</i>&nbsp;                    metadata,
<i class="no-highlight">2072</i>&nbsp;                    dataFrameCursorFactory,
<i class="no-highlight">2073</i>&nbsp;                    latestByIndex,
<i class="no-highlight">2074</i>&nbsp;                    symbolKey,
<i class="no-highlight">2075</i>&nbsp;                    filter,
<i class="no-highlight">2076</i>&nbsp;                    columnIndexes
<i class="no-highlight">2077</i>&nbsp;            );
<i class="no-highlight">2078</i>&nbsp;        }
<i class="no-highlight">2079</i>&nbsp;        // we select all values of &quot;latest by&quot; column
<i class="no-highlight">2080</i>&nbsp;
<b class="fc"><i class="no-highlight">2081</i>&nbsp;        assert intrinsicModel.keyValueFuncs.size() == 0;</b>
<i class="no-highlight">2082</i>&nbsp;        // get the latest rows for all values of &quot;latest by&quot; column
<i class="no-highlight">2083</i>&nbsp;
<b class="fc"><i class="no-highlight">2084</i>&nbsp;        if (indexed &amp;&amp; filter == null) {</b>
<b class="fc"><i class="no-highlight">2085</i>&nbsp;            return new LatestByAllIndexedRecordCursorFactory(</b>
<i class="no-highlight">2086</i>&nbsp;                    metadata,
<i class="no-highlight">2087</i>&nbsp;                    configuration,
<i class="no-highlight">2088</i>&nbsp;                    dataFrameCursorFactory,
<i class="no-highlight">2089</i>&nbsp;                    latestByIndex,
<i class="no-highlight">2090</i>&nbsp;                    columnIndexes,
<i class="no-highlight">2091</i>&nbsp;                    prefixes
<i class="no-highlight">2092</i>&nbsp;            );
<i class="no-highlight">2093</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">2094</i>&nbsp;            return new LatestByDeferredListValuesFilteredRecordCursorFactory(</b>
<i class="no-highlight">2095</i>&nbsp;                    configuration,
<i class="no-highlight">2096</i>&nbsp;                    metadata,
<i class="no-highlight">2097</i>&nbsp;                    dataFrameCursorFactory,
<i class="no-highlight">2098</i>&nbsp;                    latestByIndex,
<i class="no-highlight">2099</i>&nbsp;                    filter,
<i class="no-highlight">2100</i>&nbsp;                    columnIndexes
<i class="no-highlight">2101</i>&nbsp;            );
<i class="no-highlight">2102</i>&nbsp;        }
<i class="no-highlight">2103</i>&nbsp;    }
<i class="no-highlight">2104</i>&nbsp;
<i class="no-highlight">2105</i>&nbsp;    private RecordCursorFactory generateLimit(
<i class="no-highlight">2106</i>&nbsp;            RecordCursorFactory factory,
<i class="no-highlight">2107</i>&nbsp;            QueryModel model,
<i class="no-highlight">2108</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">2109</i>&nbsp;    ) throws SqlException {
<i class="no-highlight">2110</i>&nbsp;
<b class="fc"><i class="no-highlight">2111</i>&nbsp;        if (factory.followedLimitAdvice()) {</b>
<b class="fc"><i class="no-highlight">2112</i>&nbsp;            return factory;</b>
<i class="no-highlight">2113</i>&nbsp;        }
<i class="no-highlight">2114</i>&nbsp;
<b class="fc"><i class="no-highlight">2115</i>&nbsp;        ExpressionNode limitLo = model.getLimitLo();</b>
<b class="fc"><i class="no-highlight">2116</i>&nbsp;        ExpressionNode limitHi = model.getLimitHi();</b>
<i class="no-highlight">2117</i>&nbsp;
<i class="no-highlight">2118</i>&nbsp;        // we&#39;ve to check model otherwise we could be skipping limit in outer query that&#39;s actually different from the one in inner query!
<b class="fc"><i class="no-highlight">2119</i>&nbsp;        if ((limitLo == null &amp;&amp; limitHi == null) || (factory.implementsLimit() &amp;&amp; model.isLimitImplemented())) {</b>
<b class="fc"><i class="no-highlight">2120</i>&nbsp;            return factory;</b>
<i class="no-highlight">2121</i>&nbsp;        }
<i class="no-highlight">2122</i>&nbsp;
<i class="no-highlight">2123</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2124</i>&nbsp;            final Function loFunc = getLoFunction(model, executionContext);</b>
<b class="fc"><i class="no-highlight">2125</i>&nbsp;            final Function hiFunc = getHiFunction(model, executionContext);</b>
<i class="no-highlight">2126</i>&nbsp;
<b class="fc"><i class="no-highlight">2127</i>&nbsp;            return new LimitRecordCursorFactory(factory, loFunc, hiFunc);</b>
<b class="fc"><i class="no-highlight">2128</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">2129</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">2130</i>&nbsp;            throw e;</b>
<i class="no-highlight">2131</i>&nbsp;        }
<i class="no-highlight">2132</i>&nbsp;    }
<i class="no-highlight">2133</i>&nbsp;
<i class="no-highlight">2134</i>&nbsp;    private RecordCursorFactory generateNoSelect(
<i class="no-highlight">2135</i>&nbsp;            QueryModel model,
<i class="no-highlight">2136</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">2137</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">2138</i>&nbsp;        ExpressionNode tableNameExpr = model.getTableNameExpr();</b>
<b class="fc"><i class="no-highlight">2139</i>&nbsp;        if (tableNameExpr != null) {</b>
<b class="fc"><i class="no-highlight">2140</i>&nbsp;            if (tableNameExpr.type == FUNCTION) {</b>
<b class="fc"><i class="no-highlight">2141</i>&nbsp;                return generateFunctionQuery(model, executionContext);</b>
<i class="no-highlight">2142</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">2143</i>&nbsp;                return generateTableQuery(model, executionContext);</b>
<i class="no-highlight">2144</i>&nbsp;            }
<i class="no-highlight">2145</i>&nbsp;        }
<b class="fc"><i class="no-highlight">2146</i>&nbsp;        return generateSubQuery(model, executionContext);</b>
<i class="no-highlight">2147</i>&nbsp;    }
<i class="no-highlight">2148</i>&nbsp;
<i class="no-highlight">2149</i>&nbsp;    private RecordCursorFactory generateOrderBy(
<i class="no-highlight">2150</i>&nbsp;            RecordCursorFactory recordCursorFactory,
<i class="no-highlight">2151</i>&nbsp;            QueryModel model,
<i class="no-highlight">2152</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">2153</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">2154</i>&nbsp;        if (recordCursorFactory.followedOrderByAdvice()) {</b>
<b class="fc"><i class="no-highlight">2155</i>&nbsp;            return recordCursorFactory;</b>
<i class="no-highlight">2156</i>&nbsp;        }
<i class="no-highlight">2157</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2158</i>&nbsp;            final LowerCaseCharSequenceIntHashMap orderBy = model.getOrderHash();</b>
<b class="fc"><i class="no-highlight">2159</i>&nbsp;            final ObjList&lt;CharSequence&gt; columnNames = orderBy.keys();</b>
<b class="fc"><i class="no-highlight">2160</i>&nbsp;            final int orderByColumnCount = columnNames.size();</b>
<i class="no-highlight">2161</i>&nbsp;
<b class="fc"><i class="no-highlight">2162</i>&nbsp;            if (orderByColumnCount &gt; 0) {</b>
<i class="no-highlight">2163</i>&nbsp;
<b class="fc"><i class="no-highlight">2164</i>&nbsp;                final RecordMetadata metadata = recordCursorFactory.getMetadata();</b>
<b class="fc"><i class="no-highlight">2165</i>&nbsp;                final int timestampIndex = metadata.getTimestampIndex();</b>
<i class="no-highlight">2166</i>&nbsp;
<b class="fc"><i class="no-highlight">2167</i>&nbsp;                listColumnFilterA.clear();</b>
<b class="fc"><i class="no-highlight">2168</i>&nbsp;                intHashSet.clear();</b>
<i class="no-highlight">2169</i>&nbsp;
<i class="no-highlight">2170</i>&nbsp;                // column index sign indicates direction
<i class="no-highlight">2171</i>&nbsp;                // therefore 0 index is not allowed
<b class="fc"><i class="no-highlight">2172</i>&nbsp;                for (int i = 0; i &lt; orderByColumnCount; i++) {</b>
<b class="fc"><i class="no-highlight">2173</i>&nbsp;                    final CharSequence column = columnNames.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2174</i>&nbsp;                    int index = metadata.getColumnIndexQuiet(column);</b>
<i class="no-highlight">2175</i>&nbsp;
<i class="no-highlight">2176</i>&nbsp;                    // check if column type is supported
<b class="fc"><i class="no-highlight">2177</i>&nbsp;                    if (ColumnType.isBinary(metadata.getColumnType(index))) {</b>
<i class="no-highlight">2178</i>&nbsp;                        // find position of offending column
<i class="no-highlight">2179</i>&nbsp;
<b class="fc"><i class="no-highlight">2180</i>&nbsp;                        ObjList&lt;ExpressionNode&gt; nodes = model.getOrderBy();</b>
<b class="fc"><i class="no-highlight">2181</i>&nbsp;                        int position = 0;</b>
<b class="fc"><i class="no-highlight">2182</i>&nbsp;                        for (int j = 0, y = nodes.size(); j &lt; y; j++) {</b>
<b class="fc"><i class="no-highlight">2183</i>&nbsp;                            if (Chars.equals(column, nodes.getQuick(i).token)) {</b>
<b class="fc"><i class="no-highlight">2184</i>&nbsp;                                position = nodes.getQuick(i).position;</b>
<b class="fc"><i class="no-highlight">2185</i>&nbsp;                                break;</b>
<i class="no-highlight">2186</i>&nbsp;                            }
<i class="no-highlight">2187</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">2188</i>&nbsp;                        throw SqlException.$(position, &quot;unsupported column type: &quot;).put(ColumnType.nameOf(metadata.getColumnType(index)));</b>
<i class="no-highlight">2189</i>&nbsp;                    }
<i class="no-highlight">2190</i>&nbsp;
<i class="no-highlight">2191</i>&nbsp;                    // we also maintain unique set of column indexes for better performance
<b class="fc"><i class="no-highlight">2192</i>&nbsp;                    if (intHashSet.add(index)) {</b>
<b class="fc"><i class="no-highlight">2193</i>&nbsp;                        if (orderBy.get(column) == QueryModel.ORDER_DIRECTION_DESCENDING) {</b>
<b class="fc"><i class="no-highlight">2194</i>&nbsp;                            listColumnFilterA.add(-index - 1);</b>
<i class="no-highlight">2195</i>&nbsp;                        } else {
<b class="fc"><i class="no-highlight">2196</i>&nbsp;                            listColumnFilterA.add(index + 1);</b>
<i class="no-highlight">2197</i>&nbsp;                        }
<i class="no-highlight">2198</i>&nbsp;                    }
<i class="no-highlight">2199</i>&nbsp;                }
<i class="no-highlight">2200</i>&nbsp;
<i class="no-highlight">2201</i>&nbsp;                // if first column index is the same as timestamp of underling record cursor factory
<i class="no-highlight">2202</i>&nbsp;                // we could have two possibilities:
<i class="no-highlight">2203</i>&nbsp;                // 1. if we only have one column to order by - the cursor would already be ordered
<i class="no-highlight">2204</i>&nbsp;                //    by timestamp (either ASC or DESC); we have nothing to do
<i class="no-highlight">2205</i>&nbsp;                // 2. metadata of the new cursor will have the timestamp
<b class="fc"><i class="no-highlight">2206</i>&nbsp;                if (timestampIndex != -1) {</b>
<b class="fc"><i class="no-highlight">2207</i>&nbsp;                    CharSequence column = columnNames.getQuick(0);</b>
<b class="fc"><i class="no-highlight">2208</i>&nbsp;                    int index = metadata.getColumnIndexQuiet(column);</b>
<b class="fc"><i class="no-highlight">2209</i>&nbsp;                    if (index == timestampIndex) {</b>
<b class="fc"><i class="no-highlight">2210</i>&nbsp;                        if (orderByColumnCount == 1) {</b>
<b class="fc"><i class="no-highlight">2211</i>&nbsp;                            if (orderBy.get(column) == QueryModel.ORDER_DIRECTION_ASCENDING) {</b>
<b class="fc"><i class="no-highlight">2212</i>&nbsp;                                return recordCursorFactory;</b>
<b class="fc"><i class="no-highlight">2213</i>&nbsp;                            } else if (orderBy.get(column) == ORDER_DIRECTION_DESCENDING &amp;&amp;</b>
<b class="fc"><i class="no-highlight">2214</i>&nbsp;                                    recordCursorFactory.hasDescendingOrder()) {</b>
<b class="fc"><i class="no-highlight">2215</i>&nbsp;                                return recordCursorFactory;</b>
<i class="no-highlight">2216</i>&nbsp;                            }
<i class="no-highlight">2217</i>&nbsp;                        }
<i class="no-highlight">2218</i>&nbsp;                    }
<i class="no-highlight">2219</i>&nbsp;                }
<i class="no-highlight">2220</i>&nbsp;
<b class="fc"><i class="no-highlight">2221</i>&nbsp;                RecordMetadata orderedMetadata = GenericRecordMetadata.copyOfSansTimestamp(metadata);</b>
<b class="fc"><i class="no-highlight">2222</i>&nbsp;                final Function loFunc = getLoFunction(model, executionContext);</b>
<b class="fc"><i class="no-highlight">2223</i>&nbsp;                final Function hiFunc = getHiFunction(model, executionContext);</b>
<i class="no-highlight">2224</i>&nbsp;
<b class="fc"><i class="no-highlight">2225</i>&nbsp;                if (recordCursorFactory.recordCursorSupportsRandomAccess()) {</b>
<b class="fc"><i class="no-highlight">2226</i>&nbsp;                    if (canBeOptimized(model, executionContext, loFunc, hiFunc)) {</b>
<b class="fc"><i class="no-highlight">2227</i>&nbsp;                        model.setLimitImplemented(true);</b>
<b class="fc"><i class="no-highlight">2228</i>&nbsp;                        return new LimitedSizeSortedLightRecordCursorFactory(</b>
<i class="no-highlight">2229</i>&nbsp;                                configuration,
<i class="no-highlight">2230</i>&nbsp;                                orderedMetadata,
<i class="no-highlight">2231</i>&nbsp;                                recordCursorFactory,
<b class="fc"><i class="no-highlight">2232</i>&nbsp;                                recordComparatorCompiler.compile(metadata, listColumnFilterA),</b>
<i class="no-highlight">2233</i>&nbsp;                                loFunc,
<i class="no-highlight">2234</i>&nbsp;                                hiFunc,
<b class="fc"><i class="no-highlight">2235</i>&nbsp;                                listColumnFilterA.copy()</b>
<i class="no-highlight">2236</i>&nbsp;                        );
<i class="no-highlight">2237</i>&nbsp;                    } else {
<b class="fc"><i class="no-highlight">2238</i>&nbsp;                        return new SortedLightRecordCursorFactory(</b>
<i class="no-highlight">2239</i>&nbsp;                                configuration,
<i class="no-highlight">2240</i>&nbsp;                                orderedMetadata,
<i class="no-highlight">2241</i>&nbsp;                                recordCursorFactory,
<b class="fc"><i class="no-highlight">2242</i>&nbsp;                                recordComparatorCompiler.compile(metadata, listColumnFilterA),</b>
<b class="fc"><i class="no-highlight">2243</i>&nbsp;                                listColumnFilterA.copy()</b>
<i class="no-highlight">2244</i>&nbsp;                        );
<i class="no-highlight">2245</i>&nbsp;                    }
<i class="no-highlight">2246</i>&nbsp;                }
<i class="no-highlight">2247</i>&nbsp;
<i class="no-highlight">2248</i>&nbsp;                // when base record cursor does not support random access
<i class="no-highlight">2249</i>&nbsp;                // we have to copy entire record into ordered structure
<i class="no-highlight">2250</i>&nbsp;
<b class="fc"><i class="no-highlight">2251</i>&nbsp;                entityColumnFilter.of(orderedMetadata.getColumnCount());</b>
<b class="fc"><i class="no-highlight">2252</i>&nbsp;                return new SortedRecordCursorFactory(</b>
<i class="no-highlight">2253</i>&nbsp;                        configuration,
<i class="no-highlight">2254</i>&nbsp;                        orderedMetadata,
<i class="no-highlight">2255</i>&nbsp;                        recordCursorFactory,
<b class="fc"><i class="no-highlight">2256</i>&nbsp;                        RecordSinkFactory.getInstance(</b>
<i class="no-highlight">2257</i>&nbsp;                                asm,
<i class="no-highlight">2258</i>&nbsp;                                orderedMetadata,
<i class="no-highlight">2259</i>&nbsp;                                entityColumnFilter,
<i class="no-highlight">2260</i>&nbsp;                                false
<i class="no-highlight">2261</i>&nbsp;                        ),
<b class="fc"><i class="no-highlight">2262</i>&nbsp;                        recordComparatorCompiler.compile(metadata, listColumnFilterA),</b>
<b class="fc"><i class="no-highlight">2263</i>&nbsp;                        listColumnFilterA.copy()</b>
<i class="no-highlight">2264</i>&nbsp;                );
<i class="no-highlight">2265</i>&nbsp;            }
<i class="no-highlight">2266</i>&nbsp;
<b class="fc"><i class="no-highlight">2267</i>&nbsp;            return recordCursorFactory;</b>
<b class="fc"><i class="no-highlight">2268</i>&nbsp;        } catch (SqlException | CairoException e) {</b>
<b class="fc"><i class="no-highlight">2269</i>&nbsp;            recordCursorFactory.close();</b>
<b class="fc"><i class="no-highlight">2270</i>&nbsp;            throw e;</b>
<i class="no-highlight">2271</i>&nbsp;        }
<i class="no-highlight">2272</i>&nbsp;    }
<i class="no-highlight">2273</i>&nbsp;
<i class="no-highlight">2274</i>&nbsp;    private RecordCursorFactory generateQuery(QueryModel model, SqlExecutionContext executionContext, boolean processJoins) throws SqlException {
<b class="fc"><i class="no-highlight">2275</i>&nbsp;        RecordCursorFactory factory = generateQuery0(model, executionContext, processJoins);</b>
<b class="fc"><i class="no-highlight">2276</i>&nbsp;        if (model.getUnionModel() != null) {</b>
<b class="fc"><i class="no-highlight">2277</i>&nbsp;            return generateSetFactory(model, factory, executionContext);</b>
<i class="no-highlight">2278</i>&nbsp;        }
<i class="no-highlight">2279</i>&nbsp;
<b class="fc"><i class="no-highlight">2280</i>&nbsp;        return factory;</b>
<i class="no-highlight">2281</i>&nbsp;    }
<i class="no-highlight">2282</i>&nbsp;
<i class="no-highlight">2283</i>&nbsp;    private RecordCursorFactory generateQuery0(QueryModel model, SqlExecutionContext executionContext, boolean processJoins) throws SqlException {
<b class="fc"><i class="no-highlight">2284</i>&nbsp;        return generateLimit(</b>
<b class="fc"><i class="no-highlight">2285</i>&nbsp;                generateOrderBy(</b>
<b class="fc"><i class="no-highlight">2286</i>&nbsp;                        generateLatestBy(</b>
<b class="fc"><i class="no-highlight">2287</i>&nbsp;                                generateFilter(</b>
<b class="fc"><i class="no-highlight">2288</i>&nbsp;                                        generateSelect(</b>
<i class="no-highlight">2289</i>&nbsp;                                                model,
<i class="no-highlight">2290</i>&nbsp;                                                executionContext,
<i class="no-highlight">2291</i>&nbsp;                                                processJoins
<i class="no-highlight">2292</i>&nbsp;                                        ),
<i class="no-highlight">2293</i>&nbsp;                                        model,
<i class="no-highlight">2294</i>&nbsp;                                        executionContext
<i class="no-highlight">2295</i>&nbsp;                                ),
<i class="no-highlight">2296</i>&nbsp;                                model
<i class="no-highlight">2297</i>&nbsp;                        ),
<i class="no-highlight">2298</i>&nbsp;                        model,
<i class="no-highlight">2299</i>&nbsp;                        executionContext
<i class="no-highlight">2300</i>&nbsp;                ),
<i class="no-highlight">2301</i>&nbsp;                model,
<i class="no-highlight">2302</i>&nbsp;                executionContext
<i class="no-highlight">2303</i>&nbsp;        );
<i class="no-highlight">2304</i>&nbsp;    }
<i class="no-highlight">2305</i>&nbsp;
<i class="no-highlight">2306</i>&nbsp;    @NotNull
<i class="no-highlight">2307</i>&nbsp;    private RecordCursorFactory generateSampleBy(
<i class="no-highlight">2308</i>&nbsp;            QueryModel model,
<i class="no-highlight">2309</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">2310</i>&nbsp;            ExpressionNode sampleByNode,
<i class="no-highlight">2311</i>&nbsp;            ExpressionNode sampleByUnits
<i class="no-highlight">2312</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">2313</i>&nbsp;        final ExpressionNode timezoneName = model.getSampleByTimezoneName();</b>
<i class="no-highlight">2314</i>&nbsp;        final Function timezoneNameFunc;
<i class="no-highlight">2315</i>&nbsp;        final int timezoneNameFuncPos;
<b class="fc"><i class="no-highlight">2316</i>&nbsp;        final ExpressionNode offset = model.getSampleByOffset();</b>
<i class="no-highlight">2317</i>&nbsp;        final Function offsetFunc;
<i class="no-highlight">2318</i>&nbsp;        final int offsetFuncPos;
<i class="no-highlight">2319</i>&nbsp;
<b class="fc"><i class="no-highlight">2320</i>&nbsp;        if (timezoneName != null) {</b>
<b class="fc"><i class="no-highlight">2321</i>&nbsp;            timezoneNameFunc = functionParser.parseFunction(</b>
<i class="no-highlight">2322</i>&nbsp;                    timezoneName,
<i class="no-highlight">2323</i>&nbsp;                    EmptyRecordMetadata.INSTANCE,
<i class="no-highlight">2324</i>&nbsp;                    executionContext
<i class="no-highlight">2325</i>&nbsp;            );
<b class="fc"><i class="no-highlight">2326</i>&nbsp;            timezoneNameFuncPos = timezoneName.position;</b>
<i class="no-highlight">2327</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">2328</i>&nbsp;            timezoneNameFunc = StrConstant.NULL;</b>
<b class="fc"><i class="no-highlight">2329</i>&nbsp;            timezoneNameFuncPos = 0;</b>
<i class="no-highlight">2330</i>&nbsp;        }
<i class="no-highlight">2331</i>&nbsp;
<b class="fc"><i class="no-highlight">2332</i>&nbsp;        if (ColumnType.isUndefined(timezoneNameFunc.getType())) {</b>
<b class="fc"><i class="no-highlight">2333</i>&nbsp;            timezoneNameFunc.assignType(ColumnType.STRING, executionContext.getBindVariableService());</b>
<b class="fc"><i class="no-highlight">2334</i>&nbsp;        } else if ((!timezoneNameFunc.isConstant() &amp;&amp; !timezoneNameFunc.isRuntimeConstant())</b>
<b class="fc"><i class="no-highlight">2335</i>&nbsp;                || !ColumnType.isAssignableFrom(timezoneNameFunc.getType(), ColumnType.STRING)) {</b>
<b class="fc"><i class="no-highlight">2336</i>&nbsp;            throw SqlException.$(timezoneNameFuncPos, &quot;timezone must be a constant expression of STRING or CHAR type&quot;);</b>
<i class="no-highlight">2337</i>&nbsp;        }
<i class="no-highlight">2338</i>&nbsp;
<b class="fc"><i class="no-highlight">2339</i>&nbsp;        if (offset != null) {</b>
<b class="fc"><i class="no-highlight">2340</i>&nbsp;            offsetFunc = functionParser.parseFunction(</b>
<i class="no-highlight">2341</i>&nbsp;                    offset,
<i class="no-highlight">2342</i>&nbsp;                    EmptyRecordMetadata.INSTANCE,
<i class="no-highlight">2343</i>&nbsp;                    executionContext
<i class="no-highlight">2344</i>&nbsp;            );
<b class="fc"><i class="no-highlight">2345</i>&nbsp;            offsetFuncPos = offset.position;</b>
<i class="no-highlight">2346</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">2347</i>&nbsp;            offsetFunc = StrConstant.NULL;</b>
<b class="fc"><i class="no-highlight">2348</i>&nbsp;            offsetFuncPos = 0;</b>
<i class="no-highlight">2349</i>&nbsp;        }
<i class="no-highlight">2350</i>&nbsp;
<b class="fc"><i class="no-highlight">2351</i>&nbsp;        if (ColumnType.isUndefined(offsetFunc.getType())) {</b>
<b class="fc"><i class="no-highlight">2352</i>&nbsp;            offsetFunc.assignType(ColumnType.STRING, executionContext.getBindVariableService());</b>
<b class="fc"><i class="no-highlight">2353</i>&nbsp;        } else if ((!offsetFunc.isConstant() &amp;&amp; !offsetFunc.isRuntimeConstant())</b>
<b class="fc"><i class="no-highlight">2354</i>&nbsp;                || !ColumnType.isAssignableFrom(offsetFunc.getType(), ColumnType.STRING)) {</b>
<b class="fc"><i class="no-highlight">2355</i>&nbsp;            throw SqlException.$(offsetFuncPos, &quot;offset must be a constant expression of STRING or CHAR type&quot;);</b>
<i class="no-highlight">2356</i>&nbsp;        }
<i class="no-highlight">2357</i>&nbsp;
<b class="fc"><i class="no-highlight">2358</i>&nbsp;        RecordCursorFactory factory = null;</b>
<i class="no-highlight">2359</i>&nbsp;        // We require timestamp with asc order.
<i class="no-highlight">2360</i>&nbsp;        final int timestampIndex;
<i class="no-highlight">2361</i>&nbsp;        // Require timestamp in sub-query when it&#39;s not additionally specified as timestamp(col).
<b class="fc"><i class="no-highlight">2362</i>&nbsp;        executionContext.pushTimestampRequiredFlag(model.getTimestamp() == null);</b>
<i class="no-highlight">2363</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2364</i>&nbsp;            factory = generateSubQuery(model, executionContext);</b>
<b class="fc"><i class="no-highlight">2365</i>&nbsp;            timestampIndex = getTimestampIndex(model, factory);</b>
<b class="fc"><i class="no-highlight">2366</i>&nbsp;            if (timestampIndex == -1 || factory.hasDescendingOrder()) {</b>
<b class="fc"><i class="no-highlight">2367</i>&nbsp;                throw SqlException.$(model.getModelPosition(), &quot;base query does not provide ASC order over dedicated TIMESTAMP column&quot;);</b>
<i class="no-highlight">2368</i>&nbsp;            }
<b class="fc"><i class="no-highlight">2369</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">2370</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">2371</i>&nbsp;            throw e;</b>
<i class="no-highlight">2372</i>&nbsp;        } finally {
<b class="fc"><i class="no-highlight">2373</i>&nbsp;            executionContext.popTimestampRequiredFlag();</b>
<b class="fc"><i class="no-highlight">2374</i>&nbsp;        }</b>
<i class="no-highlight">2375</i>&nbsp;
<b class="fc"><i class="no-highlight">2376</i>&nbsp;        final RecordMetadata metadata = factory.getMetadata();</b>
<b class="fc"><i class="no-highlight">2377</i>&nbsp;        final ObjList&lt;ExpressionNode&gt; sampleByFill = model.getSampleByFill();</b>
<i class="no-highlight">2378</i>&nbsp;        final TimestampSampler timestampSampler;
<b class="fc"><i class="no-highlight">2379</i>&nbsp;        final int fillCount = sampleByFill.size();</b>
<i class="no-highlight">2380</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2381</i>&nbsp;            if (sampleByUnits == null) {</b>
<b class="fc"><i class="no-highlight">2382</i>&nbsp;                timestampSampler = TimestampSamplerFactory.getInstance(sampleByNode.token, sampleByNode.position);</b>
<i class="no-highlight">2383</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">2384</i>&nbsp;                Function sampleByPeriod = functionParser.parseFunction(</b>
<i class="no-highlight">2385</i>&nbsp;                        sampleByNode,
<i class="no-highlight">2386</i>&nbsp;                        EmptyRecordMetadata.INSTANCE,
<i class="no-highlight">2387</i>&nbsp;                        executionContext
<i class="no-highlight">2388</i>&nbsp;                );
<b class="fc"><i class="no-highlight">2389</i>&nbsp;                if (!sampleByPeriod.isConstant() || (sampleByPeriod.getType() != ColumnType.LONG &amp;&amp; sampleByPeriod.getType() != ColumnType.INT)) {</b>
<b class="fc"><i class="no-highlight">2390</i>&nbsp;                    Misc.free(sampleByPeriod);</b>
<b class="fc"><i class="no-highlight">2391</i>&nbsp;                    throw SqlException.$(sampleByNode.position, &quot;sample by period must be a constant expression of INT or LONG type&quot;);</b>
<i class="no-highlight">2392</i>&nbsp;                }
<b class="fc"><i class="no-highlight">2393</i>&nbsp;                long period = sampleByPeriod.getLong(null);</b>
<b class="fc"><i class="no-highlight">2394</i>&nbsp;                sampleByPeriod.close();</b>
<b class="fc"><i class="no-highlight">2395</i>&nbsp;                timestampSampler = TimestampSamplerFactory.getInstance(period, sampleByUnits.token, sampleByUnits.position);</b>
<i class="no-highlight">2396</i>&nbsp;            }
<i class="no-highlight">2397</i>&nbsp;
<b class="fc"><i class="no-highlight">2398</i>&nbsp;            keyTypes.clear();</b>
<b class="fc"><i class="no-highlight">2399</i>&nbsp;            valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">2400</i>&nbsp;            listColumnFilterA.clear();</b>
<i class="no-highlight">2401</i>&nbsp;
<b class="fc"><i class="no-highlight">2402</i>&nbsp;            if (fillCount == 1 &amp;&amp; Chars.equalsLowerCaseAscii(sampleByFill.getQuick(0).token, &quot;linear&quot;)) {</b>
<i class="no-highlight">2403</i>&nbsp;
<b class="fc"><i class="no-highlight">2404</i>&nbsp;                final int columnCount = metadata.getColumnCount();</b>
<b class="fc"><i class="no-highlight">2405</i>&nbsp;                final ObjList&lt;GroupByFunction&gt; groupByFunctions = new ObjList&lt;&gt;(columnCount);</b>
<b class="fc"><i class="no-highlight">2406</i>&nbsp;                final ObjList&lt;Function&gt; recordFunctions = new ObjList&lt;&gt;(columnCount);</b>
<i class="no-highlight">2407</i>&nbsp;
<b class="fc"><i class="no-highlight">2408</i>&nbsp;                valueTypes.add(ColumnType.BYTE); // gap flag</b>
<i class="no-highlight">2409</i>&nbsp;
<b class="fc"><i class="no-highlight">2410</i>&nbsp;                GroupByUtils.prepareGroupByFunctions(</b>
<i class="no-highlight">2411</i>&nbsp;                        model,
<i class="no-highlight">2412</i>&nbsp;                        metadata,
<i class="no-highlight">2413</i>&nbsp;                        functionParser,
<i class="no-highlight">2414</i>&nbsp;                        executionContext,
<i class="no-highlight">2415</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2416</i>&nbsp;                        groupByFunctionPositions,
<i class="no-highlight">2417</i>&nbsp;                        valueTypes
<i class="no-highlight">2418</i>&nbsp;                );
<i class="no-highlight">2419</i>&nbsp;
<b class="fc"><i class="no-highlight">2420</i>&nbsp;                final GenericRecordMetadata groupByMetadata = new GenericRecordMetadata();</b>
<b class="fc"><i class="no-highlight">2421</i>&nbsp;                GroupByUtils.prepareGroupByRecordFunctions(</b>
<i class="no-highlight">2422</i>&nbsp;                        model,
<i class="no-highlight">2423</i>&nbsp;                        metadata,
<i class="no-highlight">2424</i>&nbsp;                        listColumnFilterA,
<i class="no-highlight">2425</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2426</i>&nbsp;                        groupByFunctionPositions,
<i class="no-highlight">2427</i>&nbsp;                        recordFunctions,
<i class="no-highlight">2428</i>&nbsp;                        recordFunctionPositions,
<i class="no-highlight">2429</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">2430</i>&nbsp;                        keyTypes,
<b class="fc"><i class="no-highlight">2431</i>&nbsp;                        valueTypes.getColumnCount(),</b>
<i class="no-highlight">2432</i>&nbsp;                        false,
<i class="no-highlight">2433</i>&nbsp;                        timestampIndex
<i class="no-highlight">2434</i>&nbsp;                );
<i class="no-highlight">2435</i>&nbsp;
<b class="fc"><i class="no-highlight">2436</i>&nbsp;                return new SampleByInterpolateRecordCursorFactory(</b>
<i class="no-highlight">2437</i>&nbsp;                        asm,
<i class="no-highlight">2438</i>&nbsp;                        configuration,
<i class="no-highlight">2439</i>&nbsp;                        factory,
<i class="no-highlight">2440</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">2441</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2442</i>&nbsp;                        recordFunctions,
<i class="no-highlight">2443</i>&nbsp;                        timestampSampler,
<i class="no-highlight">2444</i>&nbsp;                        model,
<i class="no-highlight">2445</i>&nbsp;                        listColumnFilterA,
<i class="no-highlight">2446</i>&nbsp;                        keyTypes,
<i class="no-highlight">2447</i>&nbsp;                        valueTypes,
<i class="no-highlight">2448</i>&nbsp;                        entityColumnFilter,
<i class="no-highlight">2449</i>&nbsp;                        groupByFunctionPositions,
<i class="no-highlight">2450</i>&nbsp;                        timestampIndex
<i class="no-highlight">2451</i>&nbsp;                );
<i class="no-highlight">2452</i>&nbsp;            }
<i class="no-highlight">2453</i>&nbsp;
<b class="fc"><i class="no-highlight">2454</i>&nbsp;            final int columnCount = model.getColumns().size();</b>
<b class="fc"><i class="no-highlight">2455</i>&nbsp;            final ObjList&lt;GroupByFunction&gt; groupByFunctions = new ObjList&lt;&gt;(columnCount);</b>
<b class="fc"><i class="no-highlight">2456</i>&nbsp;            valueTypes.add(ColumnType.TIMESTAMP); // first value is always timestamp</b>
<i class="no-highlight">2457</i>&nbsp;
<b class="fc"><i class="no-highlight">2458</i>&nbsp;            GroupByUtils.prepareGroupByFunctions(</b>
<i class="no-highlight">2459</i>&nbsp;                    model,
<i class="no-highlight">2460</i>&nbsp;                    metadata,
<i class="no-highlight">2461</i>&nbsp;                    functionParser,
<i class="no-highlight">2462</i>&nbsp;                    executionContext,
<i class="no-highlight">2463</i>&nbsp;                    groupByFunctions,
<i class="no-highlight">2464</i>&nbsp;                    groupByFunctionPositions,
<i class="no-highlight">2465</i>&nbsp;                    valueTypes
<i class="no-highlight">2466</i>&nbsp;            );
<i class="no-highlight">2467</i>&nbsp;
<b class="fc"><i class="no-highlight">2468</i>&nbsp;            final ObjList&lt;Function&gt; recordFunctions = new ObjList&lt;&gt;(columnCount);</b>
<b class="fc"><i class="no-highlight">2469</i>&nbsp;            final GenericRecordMetadata groupByMetadata = new GenericRecordMetadata();</b>
<i class="no-highlight">2470</i>&nbsp;
<b class="fc"><i class="no-highlight">2471</i>&nbsp;            GroupByUtils.prepareGroupByRecordFunctions(</b>
<i class="no-highlight">2472</i>&nbsp;                    model,
<i class="no-highlight">2473</i>&nbsp;                    metadata,
<i class="no-highlight">2474</i>&nbsp;                    listColumnFilterA,
<i class="no-highlight">2475</i>&nbsp;                    groupByFunctions,
<i class="no-highlight">2476</i>&nbsp;                    groupByFunctionPositions,
<i class="no-highlight">2477</i>&nbsp;                    recordFunctions,
<i class="no-highlight">2478</i>&nbsp;                    recordFunctionPositions,
<i class="no-highlight">2479</i>&nbsp;                    groupByMetadata,
<i class="no-highlight">2480</i>&nbsp;                    keyTypes,
<b class="fc"><i class="no-highlight">2481</i>&nbsp;                    valueTypes.getColumnCount(),</b>
<i class="no-highlight">2482</i>&nbsp;                    false,
<i class="no-highlight">2483</i>&nbsp;                    timestampIndex
<i class="no-highlight">2484</i>&nbsp;            );
<i class="no-highlight">2485</i>&nbsp;
<i class="no-highlight">2486</i>&nbsp;
<b class="fc"><i class="no-highlight">2487</i>&nbsp;            boolean isFillNone = fillCount == 0 || fillCount == 1 &amp;&amp; Chars.equalsLowerCaseAscii(sampleByFill.getQuick(0).token, &quot;none&quot;);</b>
<b class="fc"><i class="no-highlight">2488</i>&nbsp;            boolean allGroupsFirstLast = isFillNone &amp;&amp; allGroupsFirstLastWithSingleSymbolFilter(model, metadata);</b>
<b class="fc"><i class="no-highlight">2489</i>&nbsp;            if (allGroupsFirstLast) {</b>
<b class="fc"><i class="no-highlight">2490</i>&nbsp;                SingleSymbolFilter symbolFilter = factory.convertToSampleByIndexDataFrameCursorFactory();</b>
<b class="fc"><i class="no-highlight">2491</i>&nbsp;                if (symbolFilter != null) {</b>
<b class="fc"><i class="no-highlight">2492</i>&nbsp;                    return new SampleByFirstLastRecordCursorFactory(</b>
<i class="no-highlight">2493</i>&nbsp;                            factory,
<i class="no-highlight">2494</i>&nbsp;                            timestampSampler,
<i class="no-highlight">2495</i>&nbsp;                            groupByMetadata,
<b class="fc"><i class="no-highlight">2496</i>&nbsp;                            model.getColumns(),</b>
<i class="no-highlight">2497</i>&nbsp;                            metadata,
<i class="no-highlight">2498</i>&nbsp;                            timezoneNameFunc,
<i class="no-highlight">2499</i>&nbsp;                            timezoneNameFuncPos,
<i class="no-highlight">2500</i>&nbsp;                            offsetFunc,
<i class="no-highlight">2501</i>&nbsp;                            offsetFuncPos,
<i class="no-highlight">2502</i>&nbsp;                            timestampIndex,
<i class="no-highlight">2503</i>&nbsp;                            symbolFilter,
<b class="fc"><i class="no-highlight">2504</i>&nbsp;                            configuration.getSampleByIndexSearchPageSize()</b>
<i class="no-highlight">2505</i>&nbsp;                    );
<i class="no-highlight">2506</i>&nbsp;                }
<i class="no-highlight">2507</i>&nbsp;            }
<i class="no-highlight">2508</i>&nbsp;
<b class="fc"><i class="no-highlight">2509</i>&nbsp;            if (fillCount == 1 &amp;&amp; Chars.equalsLowerCaseAscii(sampleByFill.getQuick(0).token, &quot;prev&quot;)) {</b>
<b class="fc"><i class="no-highlight">2510</i>&nbsp;                if (keyTypes.getColumnCount() == 0) {</b>
<b class="fc"><i class="no-highlight">2511</i>&nbsp;                    return new SampleByFillPrevNotKeyedRecordCursorFactory(</b>
<i class="no-highlight">2512</i>&nbsp;                            asm,
<i class="no-highlight">2513</i>&nbsp;                            factory,
<i class="no-highlight">2514</i>&nbsp;                            timestampSampler,
<i class="no-highlight">2515</i>&nbsp;                            groupByMetadata,
<i class="no-highlight">2516</i>&nbsp;                            groupByFunctions,
<i class="no-highlight">2517</i>&nbsp;                            recordFunctions,
<i class="no-highlight">2518</i>&nbsp;                            timestampIndex,
<b class="fc"><i class="no-highlight">2519</i>&nbsp;                            valueTypes.getColumnCount(),</b>
<i class="no-highlight">2520</i>&nbsp;                            timezoneNameFunc,
<i class="no-highlight">2521</i>&nbsp;                            timezoneNameFuncPos,
<i class="no-highlight">2522</i>&nbsp;                            offsetFunc,
<i class="no-highlight">2523</i>&nbsp;                            offsetFuncPos
<i class="no-highlight">2524</i>&nbsp;                    );
<i class="no-highlight">2525</i>&nbsp;                }
<i class="no-highlight">2526</i>&nbsp;
<b class="fc"><i class="no-highlight">2527</i>&nbsp;                return new SampleByFillPrevRecordCursorFactory(</b>
<i class="no-highlight">2528</i>&nbsp;                        asm,
<i class="no-highlight">2529</i>&nbsp;                        configuration,
<i class="no-highlight">2530</i>&nbsp;                        factory,
<i class="no-highlight">2531</i>&nbsp;                        timestampSampler,
<i class="no-highlight">2532</i>&nbsp;                        listColumnFilterA,
<i class="no-highlight">2533</i>&nbsp;                        keyTypes,
<i class="no-highlight">2534</i>&nbsp;                        valueTypes,
<i class="no-highlight">2535</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">2536</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2537</i>&nbsp;                        recordFunctions,
<i class="no-highlight">2538</i>&nbsp;                        timestampIndex,
<i class="no-highlight">2539</i>&nbsp;                        timezoneNameFunc,
<i class="no-highlight">2540</i>&nbsp;                        timezoneNameFuncPos,
<i class="no-highlight">2541</i>&nbsp;                        offsetFunc,
<i class="no-highlight">2542</i>&nbsp;                        offsetFuncPos
<i class="no-highlight">2543</i>&nbsp;                );
<i class="no-highlight">2544</i>&nbsp;            }
<i class="no-highlight">2545</i>&nbsp;
<b class="fc"><i class="no-highlight">2546</i>&nbsp;            if (isFillNone) {</b>
<i class="no-highlight">2547</i>&nbsp;
<b class="fc"><i class="no-highlight">2548</i>&nbsp;                if (keyTypes.getColumnCount() == 0) {</b>
<i class="no-highlight">2549</i>&nbsp;                    // this sample by is not keyed
<b class="fc"><i class="no-highlight">2550</i>&nbsp;                    return new SampleByFillNoneNotKeyedRecordCursorFactory(</b>
<i class="no-highlight">2551</i>&nbsp;                            asm,
<i class="no-highlight">2552</i>&nbsp;                            factory,
<i class="no-highlight">2553</i>&nbsp;                            timestampSampler,
<i class="no-highlight">2554</i>&nbsp;                            groupByMetadata,
<i class="no-highlight">2555</i>&nbsp;                            groupByFunctions,
<i class="no-highlight">2556</i>&nbsp;                            recordFunctions,
<b class="fc"><i class="no-highlight">2557</i>&nbsp;                            valueTypes.getColumnCount(),</b>
<i class="no-highlight">2558</i>&nbsp;                            timestampIndex,
<i class="no-highlight">2559</i>&nbsp;                            timezoneNameFunc,
<i class="no-highlight">2560</i>&nbsp;                            timezoneNameFuncPos,
<i class="no-highlight">2561</i>&nbsp;                            offsetFunc,
<i class="no-highlight">2562</i>&nbsp;                            offsetFuncPos
<i class="no-highlight">2563</i>&nbsp;                    );
<i class="no-highlight">2564</i>&nbsp;                }
<i class="no-highlight">2565</i>&nbsp;
<b class="fc"><i class="no-highlight">2566</i>&nbsp;                return new SampleByFillNoneRecordCursorFactory(</b>
<i class="no-highlight">2567</i>&nbsp;                        asm,
<i class="no-highlight">2568</i>&nbsp;                        configuration,
<i class="no-highlight">2569</i>&nbsp;                        factory,
<i class="no-highlight">2570</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">2571</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2572</i>&nbsp;                        recordFunctions,
<i class="no-highlight">2573</i>&nbsp;                        timestampSampler,
<i class="no-highlight">2574</i>&nbsp;                        listColumnFilterA,
<i class="no-highlight">2575</i>&nbsp;                        keyTypes,
<i class="no-highlight">2576</i>&nbsp;                        valueTypes,
<i class="no-highlight">2577</i>&nbsp;                        timestampIndex,
<i class="no-highlight">2578</i>&nbsp;                        timezoneNameFunc,
<i class="no-highlight">2579</i>&nbsp;                        timezoneNameFuncPos,
<i class="no-highlight">2580</i>&nbsp;                        offsetFunc,
<i class="no-highlight">2581</i>&nbsp;                        offsetFuncPos
<i class="no-highlight">2582</i>&nbsp;                );
<i class="no-highlight">2583</i>&nbsp;            }
<i class="no-highlight">2584</i>&nbsp;
<b class="fc"><i class="no-highlight">2585</i>&nbsp;            if (fillCount == 1 &amp;&amp; isNullKeyword(sampleByFill.getQuick(0).token)) {</b>
<b class="fc"><i class="no-highlight">2586</i>&nbsp;                if (keyTypes.getColumnCount() == 0) {</b>
<b class="fc"><i class="no-highlight">2587</i>&nbsp;                    return new SampleByFillNullNotKeyedRecordCursorFactory(</b>
<i class="no-highlight">2588</i>&nbsp;                            asm,
<i class="no-highlight">2589</i>&nbsp;                            factory,
<i class="no-highlight">2590</i>&nbsp;                            timestampSampler,
<i class="no-highlight">2591</i>&nbsp;                            groupByMetadata,
<i class="no-highlight">2592</i>&nbsp;                            groupByFunctions,
<i class="no-highlight">2593</i>&nbsp;                            recordFunctions,
<i class="no-highlight">2594</i>&nbsp;                            recordFunctionPositions,
<b class="fc"><i class="no-highlight">2595</i>&nbsp;                            valueTypes.getColumnCount(),</b>
<i class="no-highlight">2596</i>&nbsp;                            timestampIndex,
<i class="no-highlight">2597</i>&nbsp;                            timezoneNameFunc,
<i class="no-highlight">2598</i>&nbsp;                            timezoneNameFuncPos,
<i class="no-highlight">2599</i>&nbsp;                            offsetFunc,
<i class="no-highlight">2600</i>&nbsp;                            offsetFuncPos
<i class="no-highlight">2601</i>&nbsp;                    );
<i class="no-highlight">2602</i>&nbsp;                }
<i class="no-highlight">2603</i>&nbsp;
<b class="fc"><i class="no-highlight">2604</i>&nbsp;                return new SampleByFillNullRecordCursorFactory(</b>
<i class="no-highlight">2605</i>&nbsp;                        asm,
<i class="no-highlight">2606</i>&nbsp;                        configuration,
<i class="no-highlight">2607</i>&nbsp;                        factory,
<i class="no-highlight">2608</i>&nbsp;                        timestampSampler,
<i class="no-highlight">2609</i>&nbsp;                        listColumnFilterA,
<i class="no-highlight">2610</i>&nbsp;                        keyTypes,
<i class="no-highlight">2611</i>&nbsp;                        valueTypes,
<i class="no-highlight">2612</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">2613</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2614</i>&nbsp;                        recordFunctions,
<i class="no-highlight">2615</i>&nbsp;                        recordFunctionPositions,
<i class="no-highlight">2616</i>&nbsp;                        timestampIndex,
<i class="no-highlight">2617</i>&nbsp;                        timezoneNameFunc,
<i class="no-highlight">2618</i>&nbsp;                        timezoneNameFuncPos,
<i class="no-highlight">2619</i>&nbsp;                        offsetFunc,
<i class="no-highlight">2620</i>&nbsp;                        offsetFuncPos
<i class="no-highlight">2621</i>&nbsp;                );
<i class="no-highlight">2622</i>&nbsp;            }
<i class="no-highlight">2623</i>&nbsp;
<b class="fc"><i class="no-highlight">2624</i>&nbsp;            assert fillCount &gt; 0;</b>
<i class="no-highlight">2625</i>&nbsp;
<b class="fc"><i class="no-highlight">2626</i>&nbsp;            if (keyTypes.getColumnCount() == 0) {</b>
<b class="fc"><i class="no-highlight">2627</i>&nbsp;                return new SampleByFillValueNotKeyedRecordCursorFactory(</b>
<i class="no-highlight">2628</i>&nbsp;                        asm,
<i class="no-highlight">2629</i>&nbsp;                        factory,
<i class="no-highlight">2630</i>&nbsp;                        timestampSampler,
<i class="no-highlight">2631</i>&nbsp;                        sampleByFill,
<i class="no-highlight">2632</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">2633</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">2634</i>&nbsp;                        recordFunctions,
<i class="no-highlight">2635</i>&nbsp;                        recordFunctionPositions,
<b class="fc"><i class="no-highlight">2636</i>&nbsp;                        valueTypes.getColumnCount(),</b>
<i class="no-highlight">2637</i>&nbsp;                        timestampIndex,
<i class="no-highlight">2638</i>&nbsp;                        timezoneNameFunc,
<i class="no-highlight">2639</i>&nbsp;                        timezoneNameFuncPos,
<i class="no-highlight">2640</i>&nbsp;                        offsetFunc,
<i class="no-highlight">2641</i>&nbsp;                        offsetFuncPos
<i class="no-highlight">2642</i>&nbsp;                );
<i class="no-highlight">2643</i>&nbsp;            }
<i class="no-highlight">2644</i>&nbsp;
<b class="fc"><i class="no-highlight">2645</i>&nbsp;            return new SampleByFillValueRecordCursorFactory(</b>
<i class="no-highlight">2646</i>&nbsp;                    asm,
<i class="no-highlight">2647</i>&nbsp;                    configuration,
<i class="no-highlight">2648</i>&nbsp;                    factory,
<i class="no-highlight">2649</i>&nbsp;                    timestampSampler,
<i class="no-highlight">2650</i>&nbsp;                    listColumnFilterA,
<i class="no-highlight">2651</i>&nbsp;                    sampleByFill,
<i class="no-highlight">2652</i>&nbsp;                    keyTypes,
<i class="no-highlight">2653</i>&nbsp;                    valueTypes,
<i class="no-highlight">2654</i>&nbsp;                    groupByMetadata,
<i class="no-highlight">2655</i>&nbsp;                    groupByFunctions,
<i class="no-highlight">2656</i>&nbsp;                    recordFunctions,
<i class="no-highlight">2657</i>&nbsp;                    recordFunctionPositions,
<i class="no-highlight">2658</i>&nbsp;                    timestampIndex,
<i class="no-highlight">2659</i>&nbsp;                    timezoneNameFunc,
<i class="no-highlight">2660</i>&nbsp;                    timezoneNameFuncPos,
<i class="no-highlight">2661</i>&nbsp;                    offsetFunc,
<i class="no-highlight">2662</i>&nbsp;                    offsetFuncPos
<i class="no-highlight">2663</i>&nbsp;            );
<b class="fc"><i class="no-highlight">2664</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">2665</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">2666</i>&nbsp;            throw e;</b>
<i class="no-highlight">2667</i>&nbsp;        }
<i class="no-highlight">2668</i>&nbsp;    }
<i class="no-highlight">2669</i>&nbsp;
<i class="no-highlight">2670</i>&nbsp;    private RecordCursorFactory generateSelect(
<i class="no-highlight">2671</i>&nbsp;            QueryModel model,
<i class="no-highlight">2672</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">2673</i>&nbsp;            boolean processJoins
<i class="no-highlight">2674</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">2675</i>&nbsp;        switch (model.getSelectModelType()) {</b>
<i class="no-highlight">2676</i>&nbsp;            case QueryModel.SELECT_MODEL_CHOOSE:
<b class="fc"><i class="no-highlight">2677</i>&nbsp;                return generateSelectChoose(model, executionContext);</b>
<i class="no-highlight">2678</i>&nbsp;            case QueryModel.SELECT_MODEL_GROUP_BY:
<b class="fc"><i class="no-highlight">2679</i>&nbsp;                return generateSelectGroupBy(model, executionContext);</b>
<i class="no-highlight">2680</i>&nbsp;            case QueryModel.SELECT_MODEL_VIRTUAL:
<b class="fc"><i class="no-highlight">2681</i>&nbsp;                return generateSelectVirtual(model, executionContext);</b>
<i class="no-highlight">2682</i>&nbsp;            case QueryModel.SELECT_MODEL_ANALYTIC:
<b class="fc"><i class="no-highlight">2683</i>&nbsp;                return generateSelectAnalytic(model, executionContext);</b>
<i class="no-highlight">2684</i>&nbsp;            case QueryModel.SELECT_MODEL_DISTINCT:
<b class="fc"><i class="no-highlight">2685</i>&nbsp;                return generateSelectDistinct(model, executionContext);</b>
<i class="no-highlight">2686</i>&nbsp;            case QueryModel.SELECT_MODEL_CURSOR:
<b class="fc"><i class="no-highlight">2687</i>&nbsp;                return generateSelectCursor(model, executionContext);</b>
<i class="no-highlight">2688</i>&nbsp;            default:
<b class="fc"><i class="no-highlight">2689</i>&nbsp;                if (model.getJoinModels().size() &gt; 1 &amp;&amp; processJoins) {</b>
<b class="fc"><i class="no-highlight">2690</i>&nbsp;                    return generateJoins(model, executionContext);</b>
<i class="no-highlight">2691</i>&nbsp;                }
<b class="fc"><i class="no-highlight">2692</i>&nbsp;                return generateNoSelect(model, executionContext);</b>
<i class="no-highlight">2693</i>&nbsp;        }
<i class="no-highlight">2694</i>&nbsp;    }
<i class="no-highlight">2695</i>&nbsp;
<i class="no-highlight">2696</i>&nbsp;    private RecordCursorFactory generateSelectAnalytic(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">2697</i>&nbsp;        final RecordCursorFactory base = generateSubQuery(model, executionContext);</b>
<b class="fc"><i class="no-highlight">2698</i>&nbsp;        final RecordMetadata baseMetadata = base.getMetadata();</b>
<b class="fc"><i class="no-highlight">2699</i>&nbsp;        final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</b>
<b class="fc"><i class="no-highlight">2700</i>&nbsp;        final int columnCount = columns.size();</b>
<b class="fc"><i class="no-highlight">2701</i>&nbsp;        groupedAnalytic.clear();</b>
<b class="fc"><i class="no-highlight">2702</i>&nbsp;        ObjList&lt;AnalyticFunction&gt; naturalOrderFunctions = null;</b>
<i class="no-highlight">2703</i>&nbsp;
<b class="fc"><i class="no-highlight">2704</i>&nbsp;        valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">2705</i>&nbsp;        ArrayColumnTypes chainTypes = valueTypes;</b>
<b class="fc"><i class="no-highlight">2706</i>&nbsp;        GenericRecordMetadata chainMetadata = new GenericRecordMetadata();</b>
<b class="fc"><i class="no-highlight">2707</i>&nbsp;        GenericRecordMetadata factoryMetadata = new GenericRecordMetadata();</b>
<i class="no-highlight">2708</i>&nbsp;
<b class="fc"><i class="no-highlight">2709</i>&nbsp;        listColumnFilterA.clear();</b>
<b class="fc"><i class="no-highlight">2710</i>&nbsp;        listColumnFilterB.clear();</b>
<i class="no-highlight">2711</i>&nbsp;
<i class="no-highlight">2712</i>&nbsp;        // we need two passes over columns because partitionBy and orderBy clauses of
<i class="no-highlight">2713</i>&nbsp;        // the analytical function must reference the metadata of &quot;this&quot; factory.
<i class="no-highlight">2714</i>&nbsp;
<i class="no-highlight">2715</i>&nbsp;        // pass #1 assembles metadata of non-analytic columns
<i class="no-highlight">2716</i>&nbsp;
<i class="no-highlight">2717</i>&nbsp;        // set of column indexes in the base metadata that has already been added to the main
<i class="no-highlight">2718</i>&nbsp;        // metadata instance
<b class="fc"><i class="no-highlight">2719</i>&nbsp;        intHashSet.clear();</b>
<b class="fc"><i class="no-highlight">2720</i>&nbsp;        final IntList columnIndexes = new IntList();</b>
<b class="fc"><i class="no-highlight">2721</i>&nbsp;        for (int i = 0; i &lt; columnCount; i++) {</b>
<b class="fc"><i class="no-highlight">2722</i>&nbsp;            final QueryColumn qc = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2723</i>&nbsp;            if (!(qc instanceof AnalyticColumn)) {</b>
<b class="fc"><i class="no-highlight">2724</i>&nbsp;                final int columnIndex = baseMetadata.getColumnIndexQuiet(qc.getAst().token);</b>
<b class="fc"><i class="no-highlight">2725</i>&nbsp;                final TableColumnMetadata m = AbstractRecordMetadata.copyOf(baseMetadata, columnIndex);</b>
<b class="fc"><i class="no-highlight">2726</i>&nbsp;                chainMetadata.add(i, m);</b>
<b class="fc"><i class="no-highlight">2727</i>&nbsp;                factoryMetadata.add(i, m);</b>
<b class="fc"><i class="no-highlight">2728</i>&nbsp;                chainTypes.add(i, m.getType());</b>
<b class="fc"><i class="no-highlight">2729</i>&nbsp;                listColumnFilterA.extendAndSet(i, i + 1);</b>
<b class="fc"><i class="no-highlight">2730</i>&nbsp;                listColumnFilterB.extendAndSet(i, columnIndex);</b>
<b class="fc"><i class="no-highlight">2731</i>&nbsp;                intHashSet.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">2732</i>&nbsp;                columnIndexes.extendAndSet(i, columnIndex);</b>
<i class="no-highlight">2733</i>&nbsp;            }
<i class="no-highlight">2734</i>&nbsp;        }
<i class="no-highlight">2735</i>&nbsp;
<i class="no-highlight">2736</i>&nbsp;        // pass #2 - add remaining base metadata column that are not in intHashSet already
<i class="no-highlight">2737</i>&nbsp;        // we need to pay attention to stepping over analytic column slots
<i class="no-highlight">2738</i>&nbsp;        // Chain metadata is assembled in such way that all columns the factory
<i class="no-highlight">2739</i>&nbsp;        // needs to provide are at the beginning of the metadata so the record the factory cursor
<i class="no-highlight">2740</i>&nbsp;        // returns can be chain record, because the chain record is always longer than record needed out of the
<i class="no-highlight">2741</i>&nbsp;        // cursor and relevant columns are 0..n limited by factory metadata
<i class="no-highlight">2742</i>&nbsp;
<b class="fc"><i class="no-highlight">2743</i>&nbsp;        int addAt = columnCount;</b>
<b class="fc"><i class="no-highlight">2744</i>&nbsp;        for (int i = 0, n = baseMetadata.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">2745</i>&nbsp;            if (intHashSet.excludes(i)) {</b>
<b class="fc"><i class="no-highlight">2746</i>&nbsp;                final TableColumnMetadata m = AbstractRecordMetadata.copyOf(baseMetadata, i);</b>
<b class="fc"><i class="no-highlight">2747</i>&nbsp;                chainMetadata.add(addAt, m);</b>
<b class="fc"><i class="no-highlight">2748</i>&nbsp;                chainTypes.add(addAt, m.getType());</b>
<b class="fc"><i class="no-highlight">2749</i>&nbsp;                listColumnFilterA.extendAndSet(addAt, addAt + 1);</b>
<b class="fc"><i class="no-highlight">2750</i>&nbsp;                listColumnFilterB.extendAndSet(addAt, i);</b>
<b class="fc"><i class="no-highlight">2751</i>&nbsp;                columnIndexes.extendAndSet(addAt, i);</b>
<b class="fc"><i class="no-highlight">2752</i>&nbsp;                addAt++;</b>
<i class="no-highlight">2753</i>&nbsp;            }
<i class="no-highlight">2754</i>&nbsp;        }
<i class="no-highlight">2755</i>&nbsp;
<i class="no-highlight">2756</i>&nbsp;        // pass #3 assembles analytic column metadata into a list
<i class="no-highlight">2757</i>&nbsp;        // not main metadata to avoid partitionBy functions accidentally looking up
<i class="no-highlight">2758</i>&nbsp;        // analytic columns recursively
<i class="no-highlight">2759</i>&nbsp;
<b class="fc"><i class="no-highlight">2760</i>&nbsp;        deferredAnalyticMetadata.clear();</b>
<b class="fc"><i class="no-highlight">2761</i>&nbsp;        for (int i = 0; i &lt; columnCount; i++) {</b>
<b class="fc"><i class="no-highlight">2762</i>&nbsp;            final QueryColumn qc = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2763</i>&nbsp;            if (qc instanceof AnalyticColumn) {</b>
<b class="fc"><i class="no-highlight">2764</i>&nbsp;                final AnalyticColumn ac = (AnalyticColumn) qc;</b>
<b class="fc"><i class="no-highlight">2765</i>&nbsp;                final ExpressionNode ast = qc.getAst();</b>
<b class="fc"><i class="no-highlight">2766</i>&nbsp;                if (ast.paramCount &gt; 1) {</b>
<b class="fc"><i class="no-highlight">2767</i>&nbsp;                    Misc.free(base);</b>
<b class="fc"><i class="no-highlight">2768</i>&nbsp;                    throw SqlException.$(ast.position, &quot;too many arguments&quot;);</b>
<i class="no-highlight">2769</i>&nbsp;                }
<i class="no-highlight">2770</i>&nbsp;
<b class="fc"><i class="no-highlight">2771</i>&nbsp;                ObjList&lt;Function&gt; partitionBy = null;</b>
<b class="fc"><i class="no-highlight">2772</i>&nbsp;                int psz = ac.getPartitionBy().size();</b>
<b class="fc"><i class="no-highlight">2773</i>&nbsp;                if (psz &gt; 0) {</b>
<b class="fc"><i class="no-highlight">2774</i>&nbsp;                    partitionBy = new ObjList&lt;&gt;(psz);</b>
<b class="fc"><i class="no-highlight">2775</i>&nbsp;                    for (int j = 0; j &lt; psz; j++) {</b>
<b class="fc"><i class="no-highlight">2776</i>&nbsp;                        partitionBy.add(</b>
<b class="fc"><i class="no-highlight">2777</i>&nbsp;                                functionParser.parseFunction(ac.getPartitionBy().getQuick(j), chainMetadata, executionContext)</b>
<i class="no-highlight">2778</i>&nbsp;                        );
<i class="no-highlight">2779</i>&nbsp;                    }
<i class="no-highlight">2780</i>&nbsp;                }
<i class="no-highlight">2781</i>&nbsp;
<i class="no-highlight">2782</i>&nbsp;                final VirtualRecord partitionByRecord;
<i class="no-highlight">2783</i>&nbsp;                final RecordSink partitionBySink;
<i class="no-highlight">2784</i>&nbsp;
<b class="fc"><i class="no-highlight">2785</i>&nbsp;                if (partitionBy != null) {</b>
<b class="fc"><i class="no-highlight">2786</i>&nbsp;                    partitionByRecord = new VirtualRecord(partitionBy);</b>
<b class="fc"><i class="no-highlight">2787</i>&nbsp;                    keyTypes.clear();</b>
<b class="fc"><i class="no-highlight">2788</i>&nbsp;                    final int partitionByCount = partitionBy.size();</b>
<i class="no-highlight">2789</i>&nbsp;
<b class="fc"><i class="no-highlight">2790</i>&nbsp;                    for (int j = 0; j &lt; partitionByCount; j++) {</b>
<b class="fc"><i class="no-highlight">2791</i>&nbsp;                        keyTypes.add(partitionBy.getQuick(j).getType());</b>
<i class="no-highlight">2792</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">2793</i>&nbsp;                    entityColumnFilter.of(partitionByCount);</b>
<i class="no-highlight">2794</i>&nbsp;                    // create sink
<b class="fc"><i class="no-highlight">2795</i>&nbsp;                    partitionBySink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">2796</i>&nbsp;                            asm,
<i class="no-highlight">2797</i>&nbsp;                            keyTypes,
<i class="no-highlight">2798</i>&nbsp;                            entityColumnFilter,
<i class="no-highlight">2799</i>&nbsp;                            false
<i class="no-highlight">2800</i>&nbsp;                    );
<b class="fc"><i class="no-highlight">2801</i>&nbsp;                } else {</b>
<b class="fc"><i class="no-highlight">2802</i>&nbsp;                    partitionByRecord = null;</b>
<b class="fc"><i class="no-highlight">2803</i>&nbsp;                    partitionBySink = null;</b>
<i class="no-highlight">2804</i>&nbsp;                }
<i class="no-highlight">2805</i>&nbsp;
<i class="no-highlight">2806</i>&nbsp;
<b class="fc"><i class="no-highlight">2807</i>&nbsp;                final int osz = ac.getOrderBy().size();</b>
<b class="fc"><i class="no-highlight">2808</i>&nbsp;                executionContext.configureAnalyticContext(</b>
<i class="no-highlight">2809</i>&nbsp;                        partitionByRecord,
<i class="no-highlight">2810</i>&nbsp;                        partitionBySink,
<i class="no-highlight">2811</i>&nbsp;                        keyTypes,
<i class="no-highlight">2812</i>&nbsp;                        osz &gt; 0,
<b class="fc"><i class="no-highlight">2813</i>&nbsp;                        base.recordCursorSupportsRandomAccess()</b>
<i class="no-highlight">2814</i>&nbsp;                );
<i class="no-highlight">2815</i>&nbsp;                final Function f;
<i class="no-highlight">2816</i>&nbsp;                try {
<b class="fc"><i class="no-highlight">2817</i>&nbsp;                    f = functionParser.parseFunction(ast, baseMetadata, executionContext);</b>
<b class="fc"><i class="no-highlight">2818</i>&nbsp;                    if (!(f instanceof AnalyticFunction)) {</b>
<b class="fc"><i class="no-highlight">2819</i>&nbsp;                        Misc.free(base);</b>
<b class="fc"><i class="no-highlight">2820</i>&nbsp;                        throw SqlException.$(ast.position, &quot;non-analytic function called in analytic context&quot;);</b>
<i class="no-highlight">2821</i>&nbsp;                    }
<i class="no-highlight">2822</i>&nbsp;                } finally {
<b class="fc"><i class="no-highlight">2823</i>&nbsp;                    executionContext.clearAnalyticContext();</b>
<b class="fc"><i class="no-highlight">2824</i>&nbsp;                }</b>
<i class="no-highlight">2825</i>&nbsp;
<b class="fc"><i class="no-highlight">2826</i>&nbsp;                AnalyticFunction analyticFunction = (AnalyticFunction) f;</b>
<i class="no-highlight">2827</i>&nbsp;
<i class="no-highlight">2828</i>&nbsp;                // analyze order by clause on the current model and optimise out
<i class="no-highlight">2829</i>&nbsp;                // order by on analytic function if it matches the one on the model
<b class="fc"><i class="no-highlight">2830</i>&nbsp;                final LowerCaseCharSequenceIntHashMap orderHash = model.getOrderHash();</b>
<i class="no-highlight">2831</i>&nbsp;                boolean dismissOrder;
<b class="fc"><i class="no-highlight">2832</i>&nbsp;                if (osz &gt; 0 &amp;&amp; orderHash.size() &gt; 0) {</b>
<b class="fc"><i class="no-highlight">2833</i>&nbsp;                    dismissOrder = true;</b>
<b class="fc"><i class="no-highlight">2834</i>&nbsp;                    for (int j = 0; j &lt; osz; j++) {</b>
<b class="fc"><i class="no-highlight">2835</i>&nbsp;                        ExpressionNode node = ac.getOrderBy().getQuick(j);</b>
<b class="fc"><i class="no-highlight">2836</i>&nbsp;                        int direction = ac.getOrderByDirection().getQuick(j);</b>
<b class="fc"><i class="no-highlight">2837</i>&nbsp;                        if (orderHash.get(node.token) != direction) {</b>
<b class="nc"><i class="no-highlight">2838</i>&nbsp;                            dismissOrder = false;</b>
<b class="nc"><i class="no-highlight">2839</i>&nbsp;                            break;</b>
<i class="no-highlight">2840</i>&nbsp;                        }
<i class="no-highlight">2841</i>&nbsp;                    }
<i class="no-highlight">2842</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">2843</i>&nbsp;                    dismissOrder = false;</b>
<i class="no-highlight">2844</i>&nbsp;                }
<i class="no-highlight">2845</i>&nbsp;
<b class="fc"><i class="no-highlight">2846</i>&nbsp;                if (osz &gt; 0 &amp;&amp; !dismissOrder) {</b>
<b class="fc"><i class="no-highlight">2847</i>&nbsp;                    IntList order = toOrderIndices(chainMetadata, ac.getOrderBy(), ac.getOrderByDirection());</b>
<i class="no-highlight">2848</i>&nbsp;                    // init comparator if we need
<b class="fc"><i class="no-highlight">2849</i>&nbsp;                    analyticFunction.initRecordComparator(recordComparatorCompiler, chainTypes, order);</b>
<b class="fc"><i class="no-highlight">2850</i>&nbsp;                    ObjList&lt;AnalyticFunction&gt; funcs = groupedAnalytic.get(order);</b>
<b class="fc"><i class="no-highlight">2851</i>&nbsp;                    if (funcs == null) {</b>
<b class="fc"><i class="no-highlight">2852</i>&nbsp;                        groupedAnalytic.put(order, funcs = new ObjList&lt;&gt;());</b>
<i class="no-highlight">2853</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">2854</i>&nbsp;                    funcs.add(analyticFunction);</b>
<b class="fc"><i class="no-highlight">2855</i>&nbsp;                } else {</b>
<b class="fc"><i class="no-highlight">2856</i>&nbsp;                    if (naturalOrderFunctions == null) {</b>
<b class="fc"><i class="no-highlight">2857</i>&nbsp;                        naturalOrderFunctions = new ObjList&lt;&gt;();</b>
<i class="no-highlight">2858</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">2859</i>&nbsp;                    naturalOrderFunctions.add(analyticFunction);</b>
<i class="no-highlight">2860</i>&nbsp;                }
<i class="no-highlight">2861</i>&nbsp;
<b class="fc"><i class="no-highlight">2862</i>&nbsp;                analyticFunction.setColumnIndex(i);</b>
<i class="no-highlight">2863</i>&nbsp;
<b class="fc"><i class="no-highlight">2864</i>&nbsp;                deferredAnalyticMetadata.extendAndSet(i, new TableColumnMetadata(</b>
<b class="fc"><i class="no-highlight">2865</i>&nbsp;                        Chars.toString(qc.getAlias()),</b>
<b class="fc"><i class="no-highlight">2866</i>&nbsp;                        analyticFunction.getType(),</b>
<i class="no-highlight">2867</i>&nbsp;                        false,
<i class="no-highlight">2868</i>&nbsp;                        0,
<i class="no-highlight">2869</i>&nbsp;                        false,
<i class="no-highlight">2870</i>&nbsp;                        null
<i class="no-highlight">2871</i>&nbsp;                ));
<i class="no-highlight">2872</i>&nbsp;
<b class="fc"><i class="no-highlight">2873</i>&nbsp;                listColumnFilterA.extendAndSet(i, -i - 1);</b>
<i class="no-highlight">2874</i>&nbsp;            }
<i class="no-highlight">2875</i>&nbsp;        }
<i class="no-highlight">2876</i>&nbsp;
<i class="no-highlight">2877</i>&nbsp;        // after all columns are processed we can re-insert deferred metadata
<b class="fc"><i class="no-highlight">2878</i>&nbsp;        for (int i = 0, n = deferredAnalyticMetadata.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">2879</i>&nbsp;            TableColumnMetadata m = deferredAnalyticMetadata.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2880</i>&nbsp;            if (m != null) {</b>
<b class="fc"><i class="no-highlight">2881</i>&nbsp;                chainTypes.add(i, m.getType());</b>
<b class="fc"><i class="no-highlight">2882</i>&nbsp;                factoryMetadata.add(i, m);</b>
<i class="no-highlight">2883</i>&nbsp;            }
<i class="no-highlight">2884</i>&nbsp;        }
<i class="no-highlight">2885</i>&nbsp;
<b class="fc"><i class="no-highlight">2886</i>&nbsp;        final ObjList&lt;RecordComparator&gt; analyticComparators = new ObjList&lt;&gt;(groupedAnalytic.size());</b>
<b class="fc"><i class="no-highlight">2887</i>&nbsp;        final ObjList&lt;ObjList&lt;AnalyticFunction&gt;&gt; functionGroups = new ObjList&lt;&gt;(groupedAnalytic.size());</b>
<b class="fc"><i class="no-highlight">2888</i>&nbsp;        for (ObjObjHashMap.Entry&lt;IntList, ObjList&lt;AnalyticFunction&gt;&gt; e : groupedAnalytic) {</b>
<b class="fc"><i class="no-highlight">2889</i>&nbsp;            analyticComparators.add(recordComparatorCompiler.compile(chainTypes, e.key));</b>
<b class="fc"><i class="no-highlight">2890</i>&nbsp;            functionGroups.add(e.value);</b>
<b class="fc"><i class="no-highlight">2891</i>&nbsp;        }</b>
<i class="no-highlight">2892</i>&nbsp;
<b class="fc"><i class="no-highlight">2893</i>&nbsp;        final RecordSink recordSink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">2894</i>&nbsp;                asm,
<i class="no-highlight">2895</i>&nbsp;                chainTypes,
<i class="no-highlight">2896</i>&nbsp;                listColumnFilterA,
<i class="no-highlight">2897</i>&nbsp;                false,
<i class="no-highlight">2898</i>&nbsp;                listColumnFilterB
<i class="no-highlight">2899</i>&nbsp;        );
<i class="no-highlight">2900</i>&nbsp;
<b class="fc"><i class="no-highlight">2901</i>&nbsp;        return new CachedAnalyticRecordCursorFactory(</b>
<i class="no-highlight">2902</i>&nbsp;                configuration,
<i class="no-highlight">2903</i>&nbsp;                base,
<i class="no-highlight">2904</i>&nbsp;                recordSink,
<i class="no-highlight">2905</i>&nbsp;                factoryMetadata,
<i class="no-highlight">2906</i>&nbsp;                chainTypes,
<i class="no-highlight">2907</i>&nbsp;                analyticComparators,
<i class="no-highlight">2908</i>&nbsp;                functionGroups,
<i class="no-highlight">2909</i>&nbsp;                naturalOrderFunctions,
<i class="no-highlight">2910</i>&nbsp;                columnIndexes
<i class="no-highlight">2911</i>&nbsp;        );
<i class="no-highlight">2912</i>&nbsp;    }
<i class="no-highlight">2913</i>&nbsp;
<i class="no-highlight">2914</i>&nbsp;    private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">2915</i>&nbsp;        final RecordCursorFactory factory = generateSubQuery(model, executionContext);</b>
<i class="no-highlight">2916</i>&nbsp;
<b class="fc"><i class="no-highlight">2917</i>&nbsp;        final RecordMetadata metadata = factory.getMetadata();</b>
<b class="fc"><i class="no-highlight">2918</i>&nbsp;        final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</b>
<b class="fc"><i class="no-highlight">2919</i>&nbsp;        final int selectColumnCount = columns.size();</b>
<b class="fc"><i class="no-highlight">2920</i>&nbsp;        final ExpressionNode timestamp = model.getTimestamp();</b>
<i class="no-highlight">2921</i>&nbsp;
<i class="no-highlight">2922</i>&nbsp;        // If this is update query and column types don&#39;t match exactly
<i class="no-highlight">2923</i>&nbsp;        // to the column type of table to be updated we have to fall back to
<i class="no-highlight">2924</i>&nbsp;        // select-virtual
<b class="fc"><i class="no-highlight">2925</i>&nbsp;        if (model.isUpdate()) {</b>
<b class="fc"><i class="no-highlight">2926</i>&nbsp;            boolean columnTypeMismatch = false;</b>
<b class="fc"><i class="no-highlight">2927</i>&nbsp;            ObjList&lt;CharSequence&gt; updateColumnNames = model.getUpdateTableColumnNames();</b>
<b class="fc"><i class="no-highlight">2928</i>&nbsp;            IntList updateColumnTypes = model.getUpdateTableColumnTypes();</b>
<i class="no-highlight">2929</i>&nbsp;
<b class="fc"><i class="no-highlight">2930</i>&nbsp;            for (int i = 0, n = columns.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">2931</i>&nbsp;                QueryColumn queryColumn = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2932</i>&nbsp;                CharSequence columnName = queryColumn.getAlias();</b>
<b class="fc"><i class="no-highlight">2933</i>&nbsp;                int index = metadata.getColumnIndexQuiet(queryColumn.getAst().token);</b>
<b class="fc"><i class="no-highlight">2934</i>&nbsp;                assert index &gt; -1 : &quot;wtf? &quot; + queryColumn.getAst().token;</b>
<i class="no-highlight">2935</i>&nbsp;
<b class="fc"><i class="no-highlight">2936</i>&nbsp;                int updateColumnIndex = updateColumnNames.indexOf(columnName);</b>
<b class="fc"><i class="no-highlight">2937</i>&nbsp;                int updateColumnType = updateColumnTypes.get(updateColumnIndex);</b>
<i class="no-highlight">2938</i>&nbsp;
<b class="fc"><i class="no-highlight">2939</i>&nbsp;                if (updateColumnType != metadata.getColumnType(index)) {</b>
<b class="fc"><i class="no-highlight">2940</i>&nbsp;                    columnTypeMismatch = true;</b>
<b class="fc"><i class="no-highlight">2941</i>&nbsp;                    break;</b>
<i class="no-highlight">2942</i>&nbsp;                }
<i class="no-highlight">2943</i>&nbsp;            }
<i class="no-highlight">2944</i>&nbsp;
<b class="fc"><i class="no-highlight">2945</i>&nbsp;            if (columnTypeMismatch) {</b>
<b class="fc"><i class="no-highlight">2946</i>&nbsp;                return generateSelectVirtualWithSubQuery(model, executionContext, factory);</b>
<i class="no-highlight">2947</i>&nbsp;            }
<i class="no-highlight">2948</i>&nbsp;        }
<i class="no-highlight">2949</i>&nbsp;
<i class="no-highlight">2950</i>&nbsp;        boolean entity;
<i class="no-highlight">2951</i>&nbsp;        // the model is considered entity when it doesn&#39;t add any value to its nested model
<i class="no-highlight">2952</i>&nbsp;        //
<b class="fc"><i class="no-highlight">2953</i>&nbsp;        if (timestamp == null &amp;&amp; metadata.getColumnCount() == selectColumnCount) {</b>
<b class="fc"><i class="no-highlight">2954</i>&nbsp;            entity = true;</b>
<b class="fc"><i class="no-highlight">2955</i>&nbsp;            for (int i = 0; i &lt; selectColumnCount; i++) {</b>
<b class="fc"><i class="no-highlight">2956</i>&nbsp;                QueryColumn qc = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2957</i>&nbsp;                if (</b>
<b class="fc"><i class="no-highlight">2958</i>&nbsp;                        !Chars.equals(metadata.getColumnName(i), qc.getAst().token) ||</b>
<b class="fc"><i class="no-highlight">2959</i>&nbsp;                                qc.getAlias() != null &amp;&amp; !(Chars.equals(qc.getAlias(), qc.getAst().token))</b>
<i class="no-highlight">2960</i>&nbsp;                ) {
<b class="fc"><i class="no-highlight">2961</i>&nbsp;                    entity = false;</b>
<b class="fc"><i class="no-highlight">2962</i>&nbsp;                    break;</b>
<i class="no-highlight">2963</i>&nbsp;                }
<i class="no-highlight">2964</i>&nbsp;            }
<i class="no-highlight">2965</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">2966</i>&nbsp;            entity = false;</b>
<i class="no-highlight">2967</i>&nbsp;        }
<i class="no-highlight">2968</i>&nbsp;
<b class="fc"><i class="no-highlight">2969</i>&nbsp;        if (entity) {</b>
<b class="fc"><i class="no-highlight">2970</i>&nbsp;            return factory;</b>
<i class="no-highlight">2971</i>&nbsp;        }
<i class="no-highlight">2972</i>&nbsp;
<i class="no-highlight">2973</i>&nbsp;        // We require timestamp with asc order.
<i class="no-highlight">2974</i>&nbsp;        final int timestampIndex;
<i class="no-highlight">2975</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2976</i>&nbsp;            timestampIndex = getTimestampIndex(model, factory);</b>
<b class="fc"><i class="no-highlight">2977</i>&nbsp;            if (executionContext.isTimestampRequired() &amp;&amp; (timestampIndex == -1 || factory.hasDescendingOrder())) {</b>
<b class="fc"><i class="no-highlight">2978</i>&nbsp;                throw SqlException.$(model.getModelPosition(), &quot;ASC order over TIMESTAMP column is required but not provided&quot;);</b>
<i class="no-highlight">2979</i>&nbsp;            }
<b class="fc"><i class="no-highlight">2980</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">2981</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">2982</i>&nbsp;            throw e;</b>
<b class="fc"><i class="no-highlight">2983</i>&nbsp;        }</b>
<i class="no-highlight">2984</i>&nbsp;
<b class="fc"><i class="no-highlight">2985</i>&nbsp;        final IntList columnCrossIndex = new IntList(selectColumnCount);</b>
<b class="fc"><i class="no-highlight">2986</i>&nbsp;        final GenericRecordMetadata selectMetadata = new GenericRecordMetadata();</b>
<b class="fc"><i class="no-highlight">2987</i>&nbsp;        boolean timestampSet = false;</b>
<b class="fc"><i class="no-highlight">2988</i>&nbsp;        for (int i = 0; i &lt; selectColumnCount; i++) {</b>
<b class="fc"><i class="no-highlight">2989</i>&nbsp;            final QueryColumn queryColumn = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">2990</i>&nbsp;            int index = metadata.getColumnIndexQuiet(queryColumn.getAst().token);</b>
<b class="fc"><i class="no-highlight">2991</i>&nbsp;            assert index &gt; -1 : &quot;wtf? &quot; + queryColumn.getAst().token;</b>
<b class="fc"><i class="no-highlight">2992</i>&nbsp;            columnCrossIndex.add(index);</b>
<i class="no-highlight">2993</i>&nbsp;
<b class="fc"><i class="no-highlight">2994</i>&nbsp;            if (queryColumn.getAlias() == null) {</b>
<b class="nc"><i class="no-highlight">2995</i>&nbsp;                selectMetadata.add(AbstractRecordMetadata.copyOf(metadata, index));</b>
<i class="no-highlight">2996</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">2997</i>&nbsp;                selectMetadata.add(</b>
<i class="no-highlight">2998</i>&nbsp;                        new TableColumnMetadata(
<b class="fc"><i class="no-highlight">2999</i>&nbsp;                                Chars.toString(queryColumn.getAlias()),</b>
<b class="fc"><i class="no-highlight">3000</i>&nbsp;                                metadata.getColumnType(index),</b>
<b class="fc"><i class="no-highlight">3001</i>&nbsp;                                metadata.isColumnIndexed(index),</b>
<b class="fc"><i class="no-highlight">3002</i>&nbsp;                                metadata.getIndexValueBlockCapacity(index),</b>
<b class="fc"><i class="no-highlight">3003</i>&nbsp;                                metadata.isSymbolTableStatic(index),</b>
<b class="fc"><i class="no-highlight">3004</i>&nbsp;                                metadata.getMetadata(index)</b>
<i class="no-highlight">3005</i>&nbsp;                        )
<i class="no-highlight">3006</i>&nbsp;                );
<i class="no-highlight">3007</i>&nbsp;            }
<i class="no-highlight">3008</i>&nbsp;
<b class="fc"><i class="no-highlight">3009</i>&nbsp;            if (index == timestampIndex) {</b>
<b class="fc"><i class="no-highlight">3010</i>&nbsp;                selectMetadata.setTimestampIndex(i);</b>
<b class="fc"><i class="no-highlight">3011</i>&nbsp;                timestampSet = true;</b>
<i class="no-highlight">3012</i>&nbsp;            }
<i class="no-highlight">3013</i>&nbsp;        }
<i class="no-highlight">3014</i>&nbsp;
<b class="fc"><i class="no-highlight">3015</i>&nbsp;        if (!timestampSet &amp;&amp; executionContext.isTimestampRequired()) {</b>
<b class="fc"><i class="no-highlight">3016</i>&nbsp;            selectMetadata.add(AbstractRecordMetadata.copyOf(metadata, timestampIndex));</b>
<b class="fc"><i class="no-highlight">3017</i>&nbsp;            selectMetadata.setTimestampIndex(selectMetadata.getColumnCount() - 1);</b>
<b class="fc"><i class="no-highlight">3018</i>&nbsp;            columnCrossIndex.add(timestampIndex);</b>
<i class="no-highlight">3019</i>&nbsp;        }
<i class="no-highlight">3020</i>&nbsp;
<b class="fc"><i class="no-highlight">3021</i>&nbsp;        return new SelectedRecordCursorFactory(selectMetadata, columnCrossIndex, factory);</b>
<i class="no-highlight">3022</i>&nbsp;    }
<i class="no-highlight">3023</i>&nbsp;
<i class="no-highlight">3024</i>&nbsp;    private RecordCursorFactory generateSelectCursor(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<i class="no-highlight">3025</i>&nbsp;        // sql parser ensures this type of model always has only one column
<b class="fc"><i class="no-highlight">3026</i>&nbsp;        return new RecordAsAFieldRecordCursorFactory(</b>
<b class="fc"><i class="no-highlight">3027</i>&nbsp;                generate(model.getNestedModel(), executionContext),</b>
<b class="fc"><i class="no-highlight">3028</i>&nbsp;                model.getColumns().getQuick(0).getAlias()</b>
<i class="no-highlight">3029</i>&nbsp;        );
<i class="no-highlight">3030</i>&nbsp;    }
<i class="no-highlight">3031</i>&nbsp;
<i class="no-highlight">3032</i>&nbsp;    private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<i class="no-highlight">3033</i>&nbsp;
<i class="no-highlight">3034</i>&nbsp;        QueryModel twoDeepNested;
<i class="no-highlight">3035</i>&nbsp;        ExpressionNode tableNameEn;
<i class="no-highlight">3036</i>&nbsp;
<b class="fc"><i class="no-highlight">3037</i>&nbsp;        if (</b>
<b class="fc"><i class="no-highlight">3038</i>&nbsp;                model.getColumns().size() == 1</b>
<b class="fc"><i class="no-highlight">3039</i>&nbsp;                        &amp;&amp; model.getNestedModel() != null</b>
<b class="fc"><i class="no-highlight">3040</i>&nbsp;                        &amp;&amp; model.getNestedModel().getSelectModelType() == QueryModel.SELECT_MODEL_CHOOSE</b>
<b class="fc"><i class="no-highlight">3041</i>&nbsp;                        &amp;&amp; (twoDeepNested = model.getNestedModel().getNestedModel()) != null</b>
<b class="fc"><i class="no-highlight">3042</i>&nbsp;                        &amp;&amp; twoDeepNested.getLatestBy().size() == 0</b>
<b class="fc"><i class="no-highlight">3043</i>&nbsp;                        &amp;&amp; (tableNameEn = twoDeepNested.getTableNameExpr()) != null</b>
<b class="fc"><i class="no-highlight">3044</i>&nbsp;                        &amp;&amp; twoDeepNested.getWhereClause() == null</b>
<i class="no-highlight">3045</i>&nbsp;        ) {
<b class="fc"><i class="no-highlight">3046</i>&nbsp;            CharSequence tableName = tableNameEn.token;</b>
<b class="fc"><i class="no-highlight">3047</i>&nbsp;            TableToken tableToken = executionContext.getTableToken(tableName);</b>
<b class="fc"><i class="no-highlight">3048</i>&nbsp;            try (TableReader reader = executionContext.getReader(tableToken)) {</b>
<b class="fc"><i class="no-highlight">3049</i>&nbsp;                CharSequence columnName = model.getBottomUpColumnNames().get(0);</b>
<b class="fc"><i class="no-highlight">3050</i>&nbsp;                TableReaderMetadata readerMetadata = reader.getMetadata();</b>
<b class="fc"><i class="no-highlight">3051</i>&nbsp;                int columnIndex = readerMetadata.getColumnIndex(columnName);</b>
<b class="fc"><i class="no-highlight">3052</i>&nbsp;                int columnType = readerMetadata.getColumnType(columnIndex);</b>
<i class="no-highlight">3053</i>&nbsp;
<b class="fc"><i class="no-highlight">3054</i>&nbsp;                final GenericRecordMetadata distinctColumnMetadata = new GenericRecordMetadata();</b>
<b class="fc"><i class="no-highlight">3055</i>&nbsp;                distinctColumnMetadata.add(AbstractRecordMetadata.copyOf(readerMetadata, columnIndex));</b>
<b class="fc"><i class="no-highlight">3056</i>&nbsp;                if (ColumnType.isSymbol(columnType) || columnType == ColumnType.INT) {</b>
<i class="no-highlight">3057</i>&nbsp;
<b class="fc"><i class="no-highlight">3058</i>&nbsp;                    final RecordCursorFactory factory = generateSubQuery(model.getNestedModel(), executionContext);</b>
<i class="no-highlight">3059</i>&nbsp;
<b class="fc"><i class="no-highlight">3060</i>&nbsp;                    if (factory.supportPageFrameCursor()) {</b>
<i class="no-highlight">3061</i>&nbsp;                        try {
<b class="fc"><i class="no-highlight">3062</i>&nbsp;                            return new DistinctKeyRecordCursorFactory(</b>
<b class="fc"><i class="no-highlight">3063</i>&nbsp;                                    engine.getConfiguration(),</b>
<i class="no-highlight">3064</i>&nbsp;                                    factory,
<i class="no-highlight">3065</i>&nbsp;                                    distinctColumnMetadata,
<i class="no-highlight">3066</i>&nbsp;                                    arrayColumnTypes,
<i class="no-highlight">3067</i>&nbsp;                                    tempVaf,
<b class="fc"><i class="no-highlight">3068</i>&nbsp;                                    executionContext.getSharedWorkerCount(),</b>
<i class="no-highlight">3069</i>&nbsp;                                    tempSymbolSkewIndexes
<i class="no-highlight">3070</i>&nbsp;                            );
<b class="fc"><i class="no-highlight">3071</i>&nbsp;                        } catch (Throwable t) {</b>
<b class="fc"><i class="no-highlight">3072</i>&nbsp;                            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">3073</i>&nbsp;                            throw t;</b>
<i class="no-highlight">3074</i>&nbsp;                        }
<i class="no-highlight">3075</i>&nbsp;                    } else {
<i class="no-highlight">3076</i>&nbsp;                        // Shouldn&#39;t really happen, we cannot recompile below, QueryModel is changed during compilation
<b class="nc"><i class="no-highlight">3077</i>&nbsp;                        Misc.free(factory);</b>
<b class="nc"><i class="no-highlight">3078</i>&nbsp;                        throw CairoException.critical(0).put(&quot;Optimization error, incorrect path chosen, please contact support.&quot;);</b>
<i class="no-highlight">3079</i>&nbsp;                    }
<i class="no-highlight">3080</i>&nbsp;                }
<b class="fc"><i class="no-highlight">3081</i>&nbsp;            }</b>
<i class="no-highlight">3082</i>&nbsp;        }
<i class="no-highlight">3083</i>&nbsp;
<b class="fc"><i class="no-highlight">3084</i>&nbsp;        final RecordCursorFactory factory = generateSubQuery(model, executionContext);</b>
<i class="no-highlight">3085</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">3086</i>&nbsp;            if (factory.recordCursorSupportsRandomAccess() &amp;&amp; factory.getMetadata().getTimestampIndex() != -1) {</b>
<b class="fc"><i class="no-highlight">3087</i>&nbsp;                return new DistinctTimeSeriesRecordCursorFactory(</b>
<i class="no-highlight">3088</i>&nbsp;                        configuration,
<i class="no-highlight">3089</i>&nbsp;                        factory,
<i class="no-highlight">3090</i>&nbsp;                        entityColumnFilter,
<i class="no-highlight">3091</i>&nbsp;                        asm
<i class="no-highlight">3092</i>&nbsp;                );
<i class="no-highlight">3093</i>&nbsp;            }
<b class="fc"><i class="no-highlight">3094</i>&nbsp;            return new DistinctRecordCursorFactory(</b>
<i class="no-highlight">3095</i>&nbsp;                    configuration,
<i class="no-highlight">3096</i>&nbsp;                    factory,
<i class="no-highlight">3097</i>&nbsp;                    entityColumnFilter,
<i class="no-highlight">3098</i>&nbsp;                    asm
<i class="no-highlight">3099</i>&nbsp;            );
<b class="nc"><i class="no-highlight">3100</i>&nbsp;        } catch (Throwable e) {</b>
<b class="nc"><i class="no-highlight">3101</i>&nbsp;            factory.close();</b>
<b class="nc"><i class="no-highlight">3102</i>&nbsp;            throw e;</b>
<i class="no-highlight">3103</i>&nbsp;        }
<i class="no-highlight">3104</i>&nbsp;    }
<i class="no-highlight">3105</i>&nbsp;
<i class="no-highlight">3106</i>&nbsp;    private RecordCursorFactory generateSelectGroupBy(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">3107</i>&nbsp;        final ExpressionNode sampleByNode = model.getSampleBy();</b>
<b class="fc"><i class="no-highlight">3108</i>&nbsp;        if (sampleByNode != null) {</b>
<b class="fc"><i class="no-highlight">3109</i>&nbsp;            return generateSampleBy(model, executionContext, sampleByNode, model.getSampleByUnit());</b>
<i class="no-highlight">3110</i>&nbsp;        }
<i class="no-highlight">3111</i>&nbsp;
<b class="fc"><i class="no-highlight">3112</i>&nbsp;        RecordCursorFactory factory = null;</b>
<i class="no-highlight">3113</i>&nbsp;        try {
<i class="no-highlight">3114</i>&nbsp;            ObjList&lt;QueryColumn&gt; columns;
<i class="no-highlight">3115</i>&nbsp;            ExpressionNode columnExpr;
<i class="no-highlight">3116</i>&nbsp;
<i class="no-highlight">3117</i>&nbsp;            // generate special case plan for &quot;select count() from somewhere&quot;
<b class="fc"><i class="no-highlight">3118</i>&nbsp;            columns = model.getColumns();</b>
<b class="fc"><i class="no-highlight">3119</i>&nbsp;            if (columns.size() == 1) {</b>
<b class="fc"><i class="no-highlight">3120</i>&nbsp;                CharSequence columnName = columns.getQuick(0).getName();</b>
<b class="fc"><i class="no-highlight">3121</i>&nbsp;                columnExpr = columns.getQuick(0).getAst();</b>
<b class="fc"><i class="no-highlight">3122</i>&nbsp;                if (columnExpr.type == FUNCTION &amp;&amp; columnExpr.paramCount == 0 &amp;&amp; isCountKeyword(columnExpr.token)) {</b>
<i class="no-highlight">3123</i>&nbsp;                    // check if count() was not aliased, if it was, we need to generate new metadata, bummer
<b class="fc"><i class="no-highlight">3124</i>&nbsp;                    final RecordMetadata metadata = isCountKeyword(columnName) ? CountRecordCursorFactory.DEFAULT_COUNT_METADATA :</b>
<b class="fc"><i class="no-highlight">3125</i>&nbsp;                            new GenericRecordMetadata().add(new TableColumnMetadata(Chars.toString(columnName), ColumnType.LONG));</b>
<b class="fc"><i class="no-highlight">3126</i>&nbsp;                    return new CountRecordCursorFactory(metadata, generateSubQuery(model, executionContext));</b>
<i class="no-highlight">3127</i>&nbsp;                }
<i class="no-highlight">3128</i>&nbsp;            }
<i class="no-highlight">3129</i>&nbsp;
<b class="fc"><i class="no-highlight">3130</i>&nbsp;            tempKeyIndexesInBase.clear();</b>
<b class="fc"><i class="no-highlight">3131</i>&nbsp;            tempKeyIndex.clear();</b>
<b class="fc"><i class="no-highlight">3132</i>&nbsp;            arrayColumnTypes.clear();</b>
<b class="fc"><i class="no-highlight">3133</i>&nbsp;            tempKeyKinds.clear();</b>
<i class="no-highlight">3134</i>&nbsp;
<b class="fc"><i class="no-highlight">3135</i>&nbsp;            boolean pageFramingSupported = false;</b>
<b class="fc"><i class="no-highlight">3136</i>&nbsp;            boolean specialCaseKeys = false;</b>
<i class="no-highlight">3137</i>&nbsp;
<i class="no-highlight">3138</i>&nbsp;            // check for special case time function aggregations
<b class="fc"><i class="no-highlight">3139</i>&nbsp;            final QueryModel nested = model.getNestedModel();</b>
<b class="fc"><i class="no-highlight">3140</i>&nbsp;            assert nested != null;</b>
<i class="no-highlight">3141</i>&nbsp;            // check if underlying model has reference to hour(column) function
<b class="fc"><i class="no-highlight">3142</i>&nbsp;            if (</b>
<b class="fc"><i class="no-highlight">3143</i>&nbsp;                    nested.getSelectModelType() == QueryModel.SELECT_MODEL_VIRTUAL</b>
<b class="fc"><i class="no-highlight">3144</i>&nbsp;                            &amp;&amp; (columnExpr = nested.getColumns().getQuick(0).getAst()).type == FUNCTION</b>
<b class="fc"><i class="no-highlight">3145</i>&nbsp;                            &amp;&amp; isHourKeyword(columnExpr.token)</b>
<i class="no-highlight">3146</i>&nbsp;                            &amp;&amp; columnExpr.paramCount == 1
<i class="no-highlight">3147</i>&nbsp;                            &amp;&amp; columnExpr.rhs.type == LITERAL
<i class="no-highlight">3148</i>&nbsp;            ) {
<b class="fc"><i class="no-highlight">3149</i>&nbsp;                specialCaseKeys = true;</b>
<b class="fc"><i class="no-highlight">3150</i>&nbsp;                QueryModel.backupWhereClause(expressionNodePool, model);</b>
<b class="fc"><i class="no-highlight">3151</i>&nbsp;                factory = generateSubQuery(nested, executionContext);</b>
<b class="fc"><i class="no-highlight">3152</i>&nbsp;                pageFramingSupported = factory.supportPageFrameCursor();</b>
<b class="fc"><i class="no-highlight">3153</i>&nbsp;                if (pageFramingSupported) {</b>
<i class="no-highlight">3154</i>&nbsp;
<i class="no-highlight">3155</i>&nbsp;                    // find position of the hour() argument in the factory meta
<b class="fc"><i class="no-highlight">3156</i>&nbsp;                    tempKeyIndexesInBase.add(factory.getMetadata().getColumnIndex(columnExpr.rhs.token));</b>
<i class="no-highlight">3157</i>&nbsp;
<i class="no-highlight">3158</i>&nbsp;                    // find position of hour() alias in selected columns
<i class="no-highlight">3159</i>&nbsp;                    // also make sure there are no other literal column than our function reference
<b class="fc"><i class="no-highlight">3160</i>&nbsp;                    final CharSequence functionColumnName = columns.getQuick(0).getName();</b>
<b class="fc"><i class="no-highlight">3161</i>&nbsp;                    for (int i = 0, n = columns.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">3162</i>&nbsp;                        columnExpr = columns.getQuick(i).getAst();</b>
<b class="fc"><i class="no-highlight">3163</i>&nbsp;                        if (columnExpr.type == LITERAL) {</b>
<b class="fc"><i class="no-highlight">3164</i>&nbsp;                            if (Chars.equals(columnExpr.token, functionColumnName)) {</b>
<b class="fc"><i class="no-highlight">3165</i>&nbsp;                                tempKeyIndex.add(i);</b>
<i class="no-highlight">3166</i>&nbsp;                                // storage dimension for Rosti is INT when we use hour(). This function produces INT.
<b class="fc"><i class="no-highlight">3167</i>&nbsp;                                tempKeyKinds.add(GKK_HOUR_INT);</b>
<b class="fc"><i class="no-highlight">3168</i>&nbsp;                                arrayColumnTypes.add(ColumnType.INT);</b>
<i class="no-highlight">3169</i>&nbsp;                            } else {
<i class="no-highlight">3170</i>&nbsp;                                // there is something else here, fallback to default implementation
<b class="nc"><i class="no-highlight">3171</i>&nbsp;                                pageFramingSupported = false;</b>
<b class="nc"><i class="no-highlight">3172</i>&nbsp;                                break;</b>
<i class="no-highlight">3173</i>&nbsp;                            }
<i class="no-highlight">3174</i>&nbsp;                        }
<i class="no-highlight">3175</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">3176</i>&nbsp;                } else {</b>
<b class="fc"><i class="no-highlight">3177</i>&nbsp;                    factory = Misc.free(factory);</b>
<i class="no-highlight">3178</i>&nbsp;                }
<i class="no-highlight">3179</i>&nbsp;            }
<i class="no-highlight">3180</i>&nbsp;
<b class="fc"><i class="no-highlight">3181</i>&nbsp;            if (factory == null) {</b>
<b class="fc"><i class="no-highlight">3182</i>&nbsp;                if (specialCaseKeys) {</b>
<b class="fc"><i class="no-highlight">3183</i>&nbsp;                    QueryModel.restoreWhereClause(expressionNodePool, model);</b>
<i class="no-highlight">3184</i>&nbsp;                }
<b class="fc"><i class="no-highlight">3185</i>&nbsp;                factory = generateSubQuery(model, executionContext);</b>
<b class="fc"><i class="no-highlight">3186</i>&nbsp;                pageFramingSupported = factory.supportPageFrameCursor();</b>
<i class="no-highlight">3187</i>&nbsp;            }
<i class="no-highlight">3188</i>&nbsp;
<b class="fc"><i class="no-highlight">3189</i>&nbsp;            RecordMetadata metadata = factory.getMetadata();</b>
<i class="no-highlight">3190</i>&nbsp;
<i class="no-highlight">3191</i>&nbsp;            // Inspect model for possibility of vector aggregate intrinsics.
<b class="fc"><i class="no-highlight">3192</i>&nbsp;            if (pageFramingSupported &amp;&amp; assembleKeysAndFunctionReferences(columns, metadata, !specialCaseKeys)) {</b>
<i class="no-highlight">3193</i>&nbsp;                // Create metadata from everything we&#39;ve gathered.
<b class="fc"><i class="no-highlight">3194</i>&nbsp;                GenericRecordMetadata meta = new GenericRecordMetadata();</b>
<i class="no-highlight">3195</i>&nbsp;
<i class="no-highlight">3196</i>&nbsp;                // Start with keys.
<b class="fc"><i class="no-highlight">3197</i>&nbsp;                for (int i = 0, n = tempKeyIndex.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">3198</i>&nbsp;                    final int indexInThis = tempKeyIndex.getQuick(i);</b>
<b class="fc"><i class="no-highlight">3199</i>&nbsp;                    final int indexInBase = tempKeyIndexesInBase.getQuick(i);</b>
<b class="fc"><i class="no-highlight">3200</i>&nbsp;                    final int type = arrayColumnTypes.getColumnType(i);</b>
<i class="no-highlight">3201</i>&nbsp;
<b class="fc"><i class="no-highlight">3202</i>&nbsp;                    if (ColumnType.isSymbol(type)) {</b>
<b class="fc"><i class="no-highlight">3203</i>&nbsp;                        meta.add(</b>
<i class="no-highlight">3204</i>&nbsp;                                indexInThis,
<i class="no-highlight">3205</i>&nbsp;                                new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3206</i>&nbsp;                                        Chars.toString(columns.getQuick(indexInThis).getName()),</b>
<i class="no-highlight">3207</i>&nbsp;                                        type,
<i class="no-highlight">3208</i>&nbsp;                                        false,
<i class="no-highlight">3209</i>&nbsp;                                        0,
<b class="fc"><i class="no-highlight">3210</i>&nbsp;                                        metadata.isSymbolTableStatic(indexInBase),</b>
<i class="no-highlight">3211</i>&nbsp;                                        null
<i class="no-highlight">3212</i>&nbsp;                                )
<i class="no-highlight">3213</i>&nbsp;                        );
<i class="no-highlight">3214</i>&nbsp;                    } else {
<b class="fc"><i class="no-highlight">3215</i>&nbsp;                        meta.add(</b>
<i class="no-highlight">3216</i>&nbsp;                                indexInThis,
<i class="no-highlight">3217</i>&nbsp;                                new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3218</i>&nbsp;                                        Chars.toString(columns.getQuick(indexInThis).getName()),</b>
<i class="no-highlight">3219</i>&nbsp;                                        type,
<i class="no-highlight">3220</i>&nbsp;                                        null
<i class="no-highlight">3221</i>&nbsp;                                )
<i class="no-highlight">3222</i>&nbsp;                        );
<i class="no-highlight">3223</i>&nbsp;                    }
<i class="no-highlight">3224</i>&nbsp;                }
<i class="no-highlight">3225</i>&nbsp;
<i class="no-highlight">3226</i>&nbsp;                // Add the aggregate functions.
<b class="fc"><i class="no-highlight">3227</i>&nbsp;                for (int i = 0, n = tempVecConstructors.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">3228</i>&nbsp;                    VectorAggregateFunctionConstructor constructor = tempVecConstructors.getQuick(i);</b>
<b class="fc"><i class="no-highlight">3229</i>&nbsp;                    int indexInBase = tempVecConstructorArgIndexes.getQuick(i);</b>
<b class="fc"><i class="no-highlight">3230</i>&nbsp;                    int indexInThis = tempAggIndex.getQuick(i);</b>
<b class="fc"><i class="no-highlight">3231</i>&nbsp;                    VectorAggregateFunction vaf = constructor.create(tempKeyKinds.size() == 0 ? 0 : tempKeyKinds.getQuick(0), indexInBase, executionContext.getSharedWorkerCount());</b>
<b class="fc"><i class="no-highlight">3232</i>&nbsp;                    tempVaf.add(vaf);</b>
<b class="fc"><i class="no-highlight">3233</i>&nbsp;                    meta.add(indexInThis,</b>
<i class="no-highlight">3234</i>&nbsp;                            new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3235</i>&nbsp;                                    Chars.toString(columns.getQuick(indexInThis).getName()),</b>
<b class="fc"><i class="no-highlight">3236</i>&nbsp;                                    vaf.getType(),</b>
<i class="no-highlight">3237</i>&nbsp;                                    null
<i class="no-highlight">3238</i>&nbsp;                            )
<i class="no-highlight">3239</i>&nbsp;                    );
<i class="no-highlight">3240</i>&nbsp;                }
<i class="no-highlight">3241</i>&nbsp;
<b class="fc"><i class="no-highlight">3242</i>&nbsp;                if (tempKeyIndexesInBase.size() == 0) {</b>
<b class="fc"><i class="no-highlight">3243</i>&nbsp;                    return new GroupByNotKeyedVectorRecordCursorFactory(</b>
<i class="no-highlight">3244</i>&nbsp;                            configuration,
<i class="no-highlight">3245</i>&nbsp;                            factory,
<i class="no-highlight">3246</i>&nbsp;                            meta,
<i class="no-highlight">3247</i>&nbsp;                            tempVaf
<i class="no-highlight">3248</i>&nbsp;                    );
<i class="no-highlight">3249</i>&nbsp;                }
<i class="no-highlight">3250</i>&nbsp;
<b class="fc"><i class="no-highlight">3251</i>&nbsp;                if (tempKeyIndexesInBase.size() == 1) {</b>
<b class="fc"><i class="no-highlight">3252</i>&nbsp;                    for (int i = 0, n = tempVaf.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">3253</i>&nbsp;                        tempVaf.getQuick(i).pushValueTypes(arrayColumnTypes);</b>
<i class="no-highlight">3254</i>&nbsp;                    }
<i class="no-highlight">3255</i>&nbsp;
<i class="no-highlight">3256</i>&nbsp;                    try {
<b class="fc"><i class="no-highlight">3257</i>&nbsp;                        GroupByUtils.validateGroupByColumns(model, 1);</b>
<b class="fc"><i class="no-highlight">3258</i>&nbsp;                    } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">3259</i>&nbsp;                        Misc.freeObjList(tempVaf);</b>
<b class="fc"><i class="no-highlight">3260</i>&nbsp;                        throw e;</b>
<b class="fc"><i class="no-highlight">3261</i>&nbsp;                    }</b>
<i class="no-highlight">3262</i>&nbsp;
<b class="fc"><i class="no-highlight">3263</i>&nbsp;                    return new GroupByRecordCursorFactory(</b>
<i class="no-highlight">3264</i>&nbsp;                            configuration,
<i class="no-highlight">3265</i>&nbsp;                            factory,
<i class="no-highlight">3266</i>&nbsp;                            meta,
<i class="no-highlight">3267</i>&nbsp;                            arrayColumnTypes,
<b class="fc"><i class="no-highlight">3268</i>&nbsp;                            executionContext.getSharedWorkerCount(),</b>
<i class="no-highlight">3269</i>&nbsp;                            tempVaf,
<b class="fc"><i class="no-highlight">3270</i>&nbsp;                            tempKeyIndexesInBase.getQuick(0),</b>
<b class="fc"><i class="no-highlight">3271</i>&nbsp;                            tempKeyIndex.getQuick(0),</b>
<i class="no-highlight">3272</i>&nbsp;                            tempSymbolSkewIndexes
<i class="no-highlight">3273</i>&nbsp;                    );
<i class="no-highlight">3274</i>&nbsp;                }
<i class="no-highlight">3275</i>&nbsp;
<i class="no-highlight">3276</i>&nbsp;                // Free the vector aggregate functions since we didn&#39;t use them.
<b class="fc"><i class="no-highlight">3277</i>&nbsp;                Misc.freeObjList(tempVaf);</b>
<i class="no-highlight">3278</i>&nbsp;            }
<i class="no-highlight">3279</i>&nbsp;
<b class="fc"><i class="no-highlight">3280</i>&nbsp;            if (specialCaseKeys) {</b>
<i class="no-highlight">3281</i>&nbsp;                // uh-oh, we had special case keys, but could not find implementation for the functions
<i class="no-highlight">3282</i>&nbsp;                // release factory we created unnecessarily
<b class="fc"><i class="no-highlight">3283</i>&nbsp;                factory = Misc.free(factory);</b>
<i class="no-highlight">3284</i>&nbsp;                // create factory on top level model
<b class="fc"><i class="no-highlight">3285</i>&nbsp;                QueryModel.restoreWhereClause(expressionNodePool, model);</b>
<b class="fc"><i class="no-highlight">3286</i>&nbsp;                factory = generateSubQuery(model, executionContext);</b>
<i class="no-highlight">3287</i>&nbsp;                // and reset metadata
<b class="fc"><i class="no-highlight">3288</i>&nbsp;                metadata = factory.getMetadata();</b>
<i class="no-highlight">3289</i>&nbsp;            }
<i class="no-highlight">3290</i>&nbsp;
<b class="fc"><i class="no-highlight">3291</i>&nbsp;            final int timestampIndex = getTimestampIndex(model, factory);</b>
<i class="no-highlight">3292</i>&nbsp;
<b class="fc"><i class="no-highlight">3293</i>&nbsp;            keyTypes.clear();</b>
<b class="fc"><i class="no-highlight">3294</i>&nbsp;            valueTypes.clear();</b>
<b class="fc"><i class="no-highlight">3295</i>&nbsp;            listColumnFilterA.clear();</b>
<i class="no-highlight">3296</i>&nbsp;
<b class="fc"><i class="no-highlight">3297</i>&nbsp;            final int columnCount = model.getColumns().size();</b>
<b class="fc"><i class="no-highlight">3298</i>&nbsp;            ObjList&lt;GroupByFunction&gt; groupByFunctions = new ObjList&lt;&gt;(columnCount);</b>
<i class="no-highlight">3299</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">3300</i>&nbsp;                GroupByUtils.prepareGroupByFunctions(</b>
<i class="no-highlight">3301</i>&nbsp;                        model,
<i class="no-highlight">3302</i>&nbsp;                        metadata,
<i class="no-highlight">3303</i>&nbsp;                        functionParser,
<i class="no-highlight">3304</i>&nbsp;                        executionContext,
<i class="no-highlight">3305</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">3306</i>&nbsp;                        groupByFunctionPositions,
<i class="no-highlight">3307</i>&nbsp;                        valueTypes
<i class="no-highlight">3308</i>&nbsp;                );
<b class="fc"><i class="no-highlight">3309</i>&nbsp;            } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">3310</i>&nbsp;                Misc.freeObjList(groupByFunctions);</b>
<b class="fc"><i class="no-highlight">3311</i>&nbsp;                throw e;</b>
<b class="fc"><i class="no-highlight">3312</i>&nbsp;            }</b>
<i class="no-highlight">3313</i>&nbsp;
<b class="fc"><i class="no-highlight">3314</i>&nbsp;            final ObjList&lt;Function&gt; recordFunctions = new ObjList&lt;&gt;(columnCount);</b>
<b class="fc"><i class="no-highlight">3315</i>&nbsp;            final GenericRecordMetadata groupByMetadata = new GenericRecordMetadata();</b>
<i class="no-highlight">3316</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">3317</i>&nbsp;                GroupByUtils.prepareGroupByRecordFunctions(</b>
<i class="no-highlight">3318</i>&nbsp;                        model,
<i class="no-highlight">3319</i>&nbsp;                        metadata,
<i class="no-highlight">3320</i>&nbsp;                        listColumnFilterA,
<i class="no-highlight">3321</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">3322</i>&nbsp;                        groupByFunctionPositions,
<i class="no-highlight">3323</i>&nbsp;                        recordFunctions,
<i class="no-highlight">3324</i>&nbsp;                        recordFunctionPositions,
<i class="no-highlight">3325</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">3326</i>&nbsp;                        keyTypes,
<b class="fc"><i class="no-highlight">3327</i>&nbsp;                        valueTypes.getColumnCount(),</b>
<i class="no-highlight">3328</i>&nbsp;                        true,
<i class="no-highlight">3329</i>&nbsp;                        timestampIndex
<i class="no-highlight">3330</i>&nbsp;                );
<b class="fc"><i class="no-highlight">3331</i>&nbsp;            } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">3332</i>&nbsp;                Misc.freeObjList(recordFunctions);</b>
<b class="fc"><i class="no-highlight">3333</i>&nbsp;                throw e;</b>
<b class="fc"><i class="no-highlight">3334</i>&nbsp;            }</b>
<i class="no-highlight">3335</i>&nbsp;
<b class="fc"><i class="no-highlight">3336</i>&nbsp;            if (keyTypes.getColumnCount() == 0) {</b>
<b class="fc"><i class="no-highlight">3337</i>&nbsp;                return new GroupByNotKeyedRecordCursorFactory(</b>
<i class="no-highlight">3338</i>&nbsp;                        asm,
<i class="no-highlight">3339</i>&nbsp;                        factory,
<i class="no-highlight">3340</i>&nbsp;                        groupByMetadata,
<i class="no-highlight">3341</i>&nbsp;                        groupByFunctions,
<i class="no-highlight">3342</i>&nbsp;                        recordFunctions,
<b class="fc"><i class="no-highlight">3343</i>&nbsp;                        valueTypes.getColumnCount()</b>
<i class="no-highlight">3344</i>&nbsp;                );
<i class="no-highlight">3345</i>&nbsp;            }
<i class="no-highlight">3346</i>&nbsp;
<b class="fc"><i class="no-highlight">3347</i>&nbsp;            return new io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory(</b>
<i class="no-highlight">3348</i>&nbsp;                    asm,
<i class="no-highlight">3349</i>&nbsp;                    configuration,
<i class="no-highlight">3350</i>&nbsp;                    factory,
<i class="no-highlight">3351</i>&nbsp;                    listColumnFilterA,
<i class="no-highlight">3352</i>&nbsp;                    keyTypes,
<i class="no-highlight">3353</i>&nbsp;                    valueTypes,
<i class="no-highlight">3354</i>&nbsp;                    groupByMetadata,
<i class="no-highlight">3355</i>&nbsp;                    groupByFunctions,
<i class="no-highlight">3356</i>&nbsp;                    recordFunctions
<i class="no-highlight">3357</i>&nbsp;            );
<b class="fc"><i class="no-highlight">3358</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">3359</i>&nbsp;            Misc.free(factory);</b>
<b class="fc"><i class="no-highlight">3360</i>&nbsp;            throw e;</b>
<i class="no-highlight">3361</i>&nbsp;        }
<i class="no-highlight">3362</i>&nbsp;    }
<i class="no-highlight">3363</i>&nbsp;
<i class="no-highlight">3364</i>&nbsp;    private RecordCursorFactory generateSelectVirtual(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">3365</i>&nbsp;        final RecordCursorFactory factory = generateSubQuery(model, executionContext);</b>
<b class="fc"><i class="no-highlight">3366</i>&nbsp;        return generateSelectVirtualWithSubQuery(model, executionContext, factory);</b>
<i class="no-highlight">3367</i>&nbsp;    }
<i class="no-highlight">3368</i>&nbsp;
<i class="no-highlight">3369</i>&nbsp;    @NotNull
<i class="no-highlight">3370</i>&nbsp;    private VirtualRecordCursorFactory generateSelectVirtualWithSubQuery(QueryModel model, SqlExecutionContext executionContext, RecordCursorFactory factory) throws SqlException {
<i class="no-highlight">3371</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">3372</i>&nbsp;            final ObjList&lt;QueryColumn&gt; columns = model.getColumns();</b>
<b class="fc"><i class="no-highlight">3373</i>&nbsp;            final int columnCount = columns.size();</b>
<b class="fc"><i class="no-highlight">3374</i>&nbsp;            final RecordMetadata metadata = factory.getMetadata();</b>
<b class="fc"><i class="no-highlight">3375</i>&nbsp;            final ObjList&lt;Function&gt; functions = new ObjList&lt;&gt;(columnCount);</b>
<b class="fc"><i class="no-highlight">3376</i>&nbsp;            final GenericRecordMetadata virtualMetadata = new GenericRecordMetadata();</b>
<i class="no-highlight">3377</i>&nbsp;
<i class="no-highlight">3378</i>&nbsp;            // attempt to preserve timestamp on new data set
<i class="no-highlight">3379</i>&nbsp;            CharSequence timestampColumn;
<b class="fc"><i class="no-highlight">3380</i>&nbsp;            final int timestampIndex = metadata.getTimestampIndex();</b>
<b class="fc"><i class="no-highlight">3381</i>&nbsp;            if (timestampIndex &gt; -1) {</b>
<b class="fc"><i class="no-highlight">3382</i>&nbsp;                timestampColumn = metadata.getColumnName(timestampIndex);</b>
<i class="no-highlight">3383</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">3384</i>&nbsp;                timestampColumn = null;</b>
<i class="no-highlight">3385</i>&nbsp;            }
<i class="no-highlight">3386</i>&nbsp;
<b class="fc"><i class="no-highlight">3387</i>&nbsp;            for (int i = 0; i &lt; columnCount; i++) {</b>
<b class="fc"><i class="no-highlight">3388</i>&nbsp;                final QueryColumn column = columns.getQuick(i);</b>
<b class="fc"><i class="no-highlight">3389</i>&nbsp;                final ExpressionNode node = column.getAst();</b>
<b class="fc"><i class="no-highlight">3390</i>&nbsp;                if (node.type == ExpressionNode.LITERAL &amp;&amp; Chars.equalsNc(node.token, timestampColumn)) {</b>
<b class="fc"><i class="no-highlight">3391</i>&nbsp;                    virtualMetadata.setTimestampIndex(i);</b>
<i class="no-highlight">3392</i>&nbsp;                }
<i class="no-highlight">3393</i>&nbsp;
<b class="fc"><i class="no-highlight">3394</i>&nbsp;                Function function = functionParser.parseFunction(</b>
<b class="fc"><i class="no-highlight">3395</i>&nbsp;                        column.getAst(),</b>
<i class="no-highlight">3396</i>&nbsp;                        metadata,
<i class="no-highlight">3397</i>&nbsp;                        executionContext
<i class="no-highlight">3398</i>&nbsp;                );
<b class="fc"><i class="no-highlight">3399</i>&nbsp;                int targetColumnType = -1;</b>
<b class="fc"><i class="no-highlight">3400</i>&nbsp;                if (model.isUpdate()) {</b>
<i class="no-highlight">3401</i>&nbsp;                    // Check the type of the column to be updated
<b class="fc"><i class="no-highlight">3402</i>&nbsp;                    int columnIndex = model.getUpdateTableColumnNames().indexOf(column.getAlias());</b>
<b class="fc"><i class="no-highlight">3403</i>&nbsp;                    targetColumnType = model.getUpdateTableColumnTypes().get(columnIndex);</b>
<i class="no-highlight">3404</i>&nbsp;                }
<i class="no-highlight">3405</i>&nbsp;
<i class="no-highlight">3406</i>&nbsp;                // define &quot;undefined&quot; functions as string unless it&#39;s update. Leave Undefined if update
<b class="fc"><i class="no-highlight">3407</i>&nbsp;                if (function.isUndefined()) {</b>
<b class="fc"><i class="no-highlight">3408</i>&nbsp;                    if (!model.isUpdate()) {</b>
<b class="fc"><i class="no-highlight">3409</i>&nbsp;                        function.assignType(ColumnType.STRING, executionContext.getBindVariableService());</b>
<i class="no-highlight">3410</i>&nbsp;                    } else {
<i class="no-highlight">3411</i>&nbsp;                        // Set bind variable the type of the column
<b class="fc"><i class="no-highlight">3412</i>&nbsp;                        function.assignType(targetColumnType, executionContext.getBindVariableService());</b>
<i class="no-highlight">3413</i>&nbsp;                    }
<i class="no-highlight">3414</i>&nbsp;                }
<i class="no-highlight">3415</i>&nbsp;
<b class="fc"><i class="no-highlight">3416</i>&nbsp;                int columnType = function.getType();</b>
<b class="fc"><i class="no-highlight">3417</i>&nbsp;                if (targetColumnType != -1 &amp;&amp; targetColumnType != columnType) {</b>
<i class="no-highlight">3418</i>&nbsp;                    // This is an update and the target column does not match with column the update is trying to perform
<b class="fc"><i class="no-highlight">3419</i>&nbsp;                    if (ColumnType.isBuiltInWideningCast(function.getType(), targetColumnType)) {</b>
<i class="no-highlight">3420</i>&nbsp;                        // All functions will be able to getLong() if they support getInt(), no need to generate cast here
<b class="fc"><i class="no-highlight">3421</i>&nbsp;                        columnType = targetColumnType;</b>
<i class="no-highlight">3422</i>&nbsp;                    } else {
<b class="fc"><i class="no-highlight">3423</i>&nbsp;                        Function castFunction = functionParser.createImplicitCast(column.getAst().position, function, targetColumnType);</b>
<b class="fc"><i class="no-highlight">3424</i>&nbsp;                        if (castFunction != null) {</b>
<b class="fc"><i class="no-highlight">3425</i>&nbsp;                            function = castFunction;</b>
<b class="fc"><i class="no-highlight">3426</i>&nbsp;                            columnType = targetColumnType;</b>
<i class="no-highlight">3427</i>&nbsp;                        }
<i class="no-highlight">3428</i>&nbsp;                        // else - update code will throw incompatibility exception. It will have better chance close resources then
<i class="no-highlight">3429</i>&nbsp;                    }
<i class="no-highlight">3430</i>&nbsp;                }
<i class="no-highlight">3431</i>&nbsp;
<b class="fc"><i class="no-highlight">3432</i>&nbsp;                functions.add(function);</b>
<i class="no-highlight">3433</i>&nbsp;
<b class="fc"><i class="no-highlight">3434</i>&nbsp;                if (columnType == ColumnType.SYMBOL) {</b>
<b class="fc"><i class="no-highlight">3435</i>&nbsp;                    if (function instanceof SymbolFunction) {</b>
<b class="fc"><i class="no-highlight">3436</i>&nbsp;                        virtualMetadata.add(</b>
<i class="no-highlight">3437</i>&nbsp;                                new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3438</i>&nbsp;                                        Chars.toString(column.getAlias()),</b>
<b class="fc"><i class="no-highlight">3439</i>&nbsp;                                        function.getType(),</b>
<i class="no-highlight">3440</i>&nbsp;                                        false,
<i class="no-highlight">3441</i>&nbsp;                                        0,
<b class="fc"><i class="no-highlight">3442</i>&nbsp;                                        ((SymbolFunction) function).isSymbolTableStatic(),</b>
<b class="fc"><i class="no-highlight">3443</i>&nbsp;                                        function.getMetadata()</b>
<i class="no-highlight">3444</i>&nbsp;                                )
<i class="no-highlight">3445</i>&nbsp;                        );
<b class="fc"><i class="no-highlight">3446</i>&nbsp;                    } else if (function instanceof NullConstant) {</b>
<b class="fc"><i class="no-highlight">3447</i>&nbsp;                        virtualMetadata.add(</b>
<i class="no-highlight">3448</i>&nbsp;                                new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3449</i>&nbsp;                                        Chars.toString(column.getAlias()),</b>
<i class="no-highlight">3450</i>&nbsp;                                        ColumnType.SYMBOL,
<i class="no-highlight">3451</i>&nbsp;                                        false,
<i class="no-highlight">3452</i>&nbsp;                                        0,
<i class="no-highlight">3453</i>&nbsp;                                        false,
<b class="fc"><i class="no-highlight">3454</i>&nbsp;                                        function.getMetadata()</b>
<i class="no-highlight">3455</i>&nbsp;                                )
<i class="no-highlight">3456</i>&nbsp;                        );
<i class="no-highlight">3457</i>&nbsp;                        // Replace with symbol null constant
<b class="fc"><i class="no-highlight">3458</i>&nbsp;                        functions.setQuick(functions.size() - 1, SymbolConstant.NULL);</b>
<i class="no-highlight">3459</i>&nbsp;                    }
<i class="no-highlight">3460</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">3461</i>&nbsp;                    virtualMetadata.add(</b>
<i class="no-highlight">3462</i>&nbsp;                            new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3463</i>&nbsp;                                    Chars.toString(column.getAlias()),</b>
<i class="no-highlight">3464</i>&nbsp;                                    columnType,
<b class="fc"><i class="no-highlight">3465</i>&nbsp;                                    function.getMetadata()</b>
<i class="no-highlight">3466</i>&nbsp;                            )
<i class="no-highlight">3467</i>&nbsp;                    );
<i class="no-highlight">3468</i>&nbsp;                }
<i class="no-highlight">3469</i>&nbsp;            }
<i class="no-highlight">3470</i>&nbsp;
<i class="no-highlight">3471</i>&nbsp;            // if timestamp was required and present in the base model but
<i class="no-highlight">3472</i>&nbsp;            // not selected, we will need to add it
<b class="fc"><i class="no-highlight">3473</i>&nbsp;            if (</b>
<b class="fc"><i class="no-highlight">3474</i>&nbsp;                    executionContext.isTimestampRequired()</b>
<i class="no-highlight">3475</i>&nbsp;                            &amp;&amp; timestampColumn != null
<b class="fc"><i class="no-highlight">3476</i>&nbsp;                            &amp;&amp; virtualMetadata.getTimestampIndex() == -1</b>
<i class="no-highlight">3477</i>&nbsp;            ) {
<b class="fc"><i class="no-highlight">3478</i>&nbsp;                final Function timestampFunction = FunctionParser.createColumn(</b>
<i class="no-highlight">3479</i>&nbsp;                        0,
<i class="no-highlight">3480</i>&nbsp;                        timestampColumn,
<i class="no-highlight">3481</i>&nbsp;                        metadata
<i class="no-highlight">3482</i>&nbsp;                );
<b class="fc"><i class="no-highlight">3483</i>&nbsp;                functions.add(timestampFunction);</b>
<i class="no-highlight">3484</i>&nbsp;
<i class="no-highlight">3485</i>&nbsp;                // here the base timestamp column name can name-clash with one of the
<i class="no-highlight">3486</i>&nbsp;                // functions, so we have to use bottomUpColumns to lookup alias we should
<i class="no-highlight">3487</i>&nbsp;                // be using. Bottom up column should have our timestamp because optimiser puts it there
<i class="no-highlight">3488</i>&nbsp;
<b class="fc"><i class="no-highlight">3489</i>&nbsp;                for (int i = 0, n = model.getBottomUpColumns().size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">3490</i>&nbsp;                    QueryColumn qc = model.getBottomUpColumns().getQuick(i);</b>
<b class="fc"><i class="no-highlight">3491</i>&nbsp;                    if (qc.getAst().type == LITERAL &amp;&amp; Chars.equals(timestampColumn, qc.getAst().token)) {</b>
<b class="fc"><i class="no-highlight">3492</i>&nbsp;                        virtualMetadata.setTimestampIndex(virtualMetadata.getColumnCount());</b>
<b class="fc"><i class="no-highlight">3493</i>&nbsp;                        virtualMetadata.add(</b>
<i class="no-highlight">3494</i>&nbsp;                                new TableColumnMetadata(
<b class="fc"><i class="no-highlight">3495</i>&nbsp;                                        Chars.toString(qc.getAlias()),</b>
<b class="fc"><i class="no-highlight">3496</i>&nbsp;                                        timestampFunction.getType(),</b>
<b class="fc"><i class="no-highlight">3497</i>&nbsp;                                        timestampFunction.getMetadata()</b>
<i class="no-highlight">3498</i>&nbsp;                                )
<i class="no-highlight">3499</i>&nbsp;                        );
<b class="fc"><i class="no-highlight">3500</i>&nbsp;                        break;</b>
<i class="no-highlight">3501</i>&nbsp;                    }
<i class="no-highlight">3502</i>&nbsp;                }
<i class="no-highlight">3503</i>&nbsp;            }
<b class="fc"><i class="no-highlight">3504</i>&nbsp;            return new VirtualRecordCursorFactory(virtualMetadata, functions, factory);</b>
<b class="fc"><i class="no-highlight">3505</i>&nbsp;        } catch (SqlException | CairoException e) {</b>
<b class="fc"><i class="no-highlight">3506</i>&nbsp;            factory.close();</b>
<b class="fc"><i class="no-highlight">3507</i>&nbsp;            throw e;</b>
<i class="no-highlight">3508</i>&nbsp;        }
<i class="no-highlight">3509</i>&nbsp;    }
<i class="no-highlight">3510</i>&nbsp;
<i class="no-highlight">3511</i>&nbsp;    /**
<i class="no-highlight">3512</i>&nbsp;     * Generates chain of parent factories each of which takes only two argument factories.
<i class="no-highlight">3513</i>&nbsp;     * Parent factory will perform one of SET operations on its arguments, such as UNION, UNION ALL,
<i class="no-highlight">3514</i>&nbsp;     * INTERSECT or EXCEPT
<i class="no-highlight">3515</i>&nbsp;     *
<i class="no-highlight">3516</i>&nbsp;     * @param model            incoming model is expected to have a chain of models via its QueryModel.getUnionModel() function
<i class="no-highlight">3517</i>&nbsp;     * @param factoryA         is compiled first argument
<i class="no-highlight">3518</i>&nbsp;     * @param executionContext execution context for authorization and parallel execution purposes
<i class="no-highlight">3519</i>&nbsp;     * @return factory that performs a SET operation
<i class="no-highlight">3520</i>&nbsp;     * @throws SqlException when query contains syntax errors
<i class="no-highlight">3521</i>&nbsp;     */
<i class="no-highlight">3522</i>&nbsp;    private RecordCursorFactory generateSetFactory(
<i class="no-highlight">3523</i>&nbsp;            QueryModel model,
<i class="no-highlight">3524</i>&nbsp;            RecordCursorFactory factoryA,
<i class="no-highlight">3525</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">3526</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">3527</i>&nbsp;        final RecordCursorFactory factoryB = generateQuery0(model.getUnionModel(), executionContext, true);</b>
<b class="fc"><i class="no-highlight">3528</i>&nbsp;        ObjList&lt;Function&gt; castFunctionsA = null;</b>
<b class="fc"><i class="no-highlight">3529</i>&nbsp;        ObjList&lt;Function&gt; castFunctionsB = null;</b>
<i class="no-highlight">3530</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">3531</i>&nbsp;            final RecordMetadata metadataA = factoryA.getMetadata();</b>
<b class="fc"><i class="no-highlight">3532</i>&nbsp;            final RecordMetadata metadataB = factoryB.getMetadata();</b>
<b class="fc"><i class="no-highlight">3533</i>&nbsp;            final int positionA = model.getModelPosition();</b>
<b class="fc"><i class="no-highlight">3534</i>&nbsp;            final int positionB = model.getUnionModel().getModelPosition();</b>
<i class="no-highlight">3535</i>&nbsp;
<b class="fc"><i class="no-highlight">3536</i>&nbsp;            switch (model.getSetOperationType()) {</b>
<i class="no-highlight">3537</i>&nbsp;                case SET_OPERATION_UNION: {
<b class="fc"><i class="no-highlight">3538</i>&nbsp;                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, true);</b>
<b class="fc"><i class="no-highlight">3539</i>&nbsp;                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : GenericRecordMetadata.removeTimestamp(metadataA);</b>
<b class="fc"><i class="no-highlight">3540</i>&nbsp;                    if (castIsRequired) {</b>
<b class="fc"><i class="no-highlight">3541</i>&nbsp;                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</b>
<b class="fc"><i class="no-highlight">3542</i>&nbsp;                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</b>
<i class="no-highlight">3543</i>&nbsp;                    }
<i class="no-highlight">3544</i>&nbsp;
<b class="fc"><i class="no-highlight">3545</i>&nbsp;                    return generateUnionFactory(</b>
<i class="no-highlight">3546</i>&nbsp;                            model,
<i class="no-highlight">3547</i>&nbsp;                            executionContext,
<i class="no-highlight">3548</i>&nbsp;                            factoryA,
<i class="no-highlight">3549</i>&nbsp;                            factoryB,
<i class="no-highlight">3550</i>&nbsp;                            castFunctionsA,
<i class="no-highlight">3551</i>&nbsp;                            castFunctionsB,
<i class="no-highlight">3552</i>&nbsp;                            setMetadata,
<i class="no-highlight">3553</i>&nbsp;                            SET_UNION_CONSTRUCTOR
<i class="no-highlight">3554</i>&nbsp;                    );
<i class="no-highlight">3555</i>&nbsp;                }
<i class="no-highlight">3556</i>&nbsp;                case SET_OPERATION_UNION_ALL: {
<b class="fc"><i class="no-highlight">3557</i>&nbsp;                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, true);</b>
<b class="fc"><i class="no-highlight">3558</i>&nbsp;                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : GenericRecordMetadata.removeTimestamp(metadataA);</b>
<b class="fc"><i class="no-highlight">3559</i>&nbsp;                    if (castIsRequired) {</b>
<b class="fc"><i class="no-highlight">3560</i>&nbsp;                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</b>
<b class="fc"><i class="no-highlight">3561</i>&nbsp;                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</b>
<i class="no-highlight">3562</i>&nbsp;                    }
<i class="no-highlight">3563</i>&nbsp;
<b class="fc"><i class="no-highlight">3564</i>&nbsp;                    return generateUnionAllFactory(</b>
<i class="no-highlight">3565</i>&nbsp;                            model,
<i class="no-highlight">3566</i>&nbsp;                            executionContext,
<i class="no-highlight">3567</i>&nbsp;                            factoryA,
<i class="no-highlight">3568</i>&nbsp;                            factoryB,
<i class="no-highlight">3569</i>&nbsp;                            castFunctionsA,
<i class="no-highlight">3570</i>&nbsp;                            castFunctionsB,
<i class="no-highlight">3571</i>&nbsp;                            setMetadata
<i class="no-highlight">3572</i>&nbsp;                    );
<i class="no-highlight">3573</i>&nbsp;                }
<i class="no-highlight">3574</i>&nbsp;                case SET_OPERATION_EXCEPT: {
<b class="fc"><i class="no-highlight">3575</i>&nbsp;                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, false);</b>
<b class="fc"><i class="no-highlight">3576</i>&nbsp;                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : metadataA;</b>
<b class="fc"><i class="no-highlight">3577</i>&nbsp;                    if (castIsRequired) {</b>
<b class="fc"><i class="no-highlight">3578</i>&nbsp;                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</b>
<b class="fc"><i class="no-highlight">3579</i>&nbsp;                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</b>
<i class="no-highlight">3580</i>&nbsp;                    }
<i class="no-highlight">3581</i>&nbsp;
<b class="fc"><i class="no-highlight">3582</i>&nbsp;                    return generateUnionFactory(</b>
<i class="no-highlight">3583</i>&nbsp;                            model,
<i class="no-highlight">3584</i>&nbsp;                            executionContext,
<i class="no-highlight">3585</i>&nbsp;                            factoryA,
<i class="no-highlight">3586</i>&nbsp;                            factoryB,
<i class="no-highlight">3587</i>&nbsp;                            castFunctionsA,
<i class="no-highlight">3588</i>&nbsp;                            castFunctionsB,
<i class="no-highlight">3589</i>&nbsp;                            setMetadata,
<i class="no-highlight">3590</i>&nbsp;                            SET_EXCEPT_CONSTRUCTOR
<i class="no-highlight">3591</i>&nbsp;                    );
<i class="no-highlight">3592</i>&nbsp;                }
<i class="no-highlight">3593</i>&nbsp;                case SET_OPERATION_INTERSECT: {
<b class="fc"><i class="no-highlight">3594</i>&nbsp;                    final boolean castIsRequired = checkIfSetCastIsRequired(metadataA, metadataB, false);</b>
<b class="fc"><i class="no-highlight">3595</i>&nbsp;                    final RecordMetadata setMetadata = castIsRequired ? widenSetMetadata(metadataA, metadataB) : metadataA;</b>
<b class="fc"><i class="no-highlight">3596</i>&nbsp;                    if (castIsRequired) {</b>
<b class="fc"><i class="no-highlight">3597</i>&nbsp;                        castFunctionsA = generateCastFunctions(setMetadata, metadataA, positionA);</b>
<b class="fc"><i class="no-highlight">3598</i>&nbsp;                        castFunctionsB = generateCastFunctions(setMetadata, metadataB, positionB);</b>
<i class="no-highlight">3599</i>&nbsp;                    }
<i class="no-highlight">3600</i>&nbsp;
<b class="fc"><i class="no-highlight">3601</i>&nbsp;                    return generateUnionFactory(</b>
<i class="no-highlight">3602</i>&nbsp;                            model,
<i class="no-highlight">3603</i>&nbsp;                            executionContext,
<i class="no-highlight">3604</i>&nbsp;                            factoryA,
<i class="no-highlight">3605</i>&nbsp;                            factoryB,
<i class="no-highlight">3606</i>&nbsp;                            castFunctionsA,
<i class="no-highlight">3607</i>&nbsp;                            castFunctionsB,
<i class="no-highlight">3608</i>&nbsp;                            setMetadata,
<i class="no-highlight">3609</i>&nbsp;                            SET_INTERSECT_CONSTRUCTOR
<i class="no-highlight">3610</i>&nbsp;                    );
<i class="no-highlight">3611</i>&nbsp;                }
<i class="no-highlight">3612</i>&nbsp;                default:
<b class="nc"><i class="no-highlight">3613</i>&nbsp;                    assert false;</b>
<b class="nc"><i class="no-highlight">3614</i>&nbsp;                    return null;</b>
<i class="no-highlight">3615</i>&nbsp;            }
<b class="fc"><i class="no-highlight">3616</i>&nbsp;        } catch (Throwable e) {</b>
<b class="fc"><i class="no-highlight">3617</i>&nbsp;            Misc.free(factoryA);</b>
<b class="fc"><i class="no-highlight">3618</i>&nbsp;            Misc.free(factoryB);</b>
<b class="fc"><i class="no-highlight">3619</i>&nbsp;            Misc.freeObjList(castFunctionsA);</b>
<b class="fc"><i class="no-highlight">3620</i>&nbsp;            Misc.freeObjList(castFunctionsB);</b>
<b class="fc"><i class="no-highlight">3621</i>&nbsp;            throw e;</b>
<i class="no-highlight">3622</i>&nbsp;        }
<i class="no-highlight">3623</i>&nbsp;    }
<i class="no-highlight">3624</i>&nbsp;
<i class="no-highlight">3625</i>&nbsp;    private RecordCursorFactory generateSubQuery(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">3626</i>&nbsp;        assert model.getNestedModel() != null;</b>
<b class="fc"><i class="no-highlight">3627</i>&nbsp;        return generateQuery(model.getNestedModel(), executionContext, true);</b>
<i class="no-highlight">3628</i>&nbsp;    }
<i class="no-highlight">3629</i>&nbsp;
<i class="no-highlight">3630</i>&nbsp;    private RecordCursorFactory generateTableQuery(
<i class="no-highlight">3631</i>&nbsp;            QueryModel model,
<i class="no-highlight">3632</i>&nbsp;            SqlExecutionContext executionContext
<i class="no-highlight">3633</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">3634</i>&nbsp;        final ObjList&lt;ExpressionNode&gt; latestBy = model.getLatestBy();</b>
<i class="no-highlight">3635</i>&nbsp;
<b class="fc"><i class="no-highlight">3636</i>&nbsp;        final GenericLexer.FloatingSequence tab = (GenericLexer.FloatingSequence) model.getTableName();</b>
<i class="no-highlight">3637</i>&nbsp;        final boolean supportsRandomAccess;
<b class="fc"><i class="no-highlight">3638</i>&nbsp;        if (Chars.startsWith(tab, NO_ROWID_MARKER)) {</b>
<b class="fc"><i class="no-highlight">3639</i>&nbsp;            tab.setLo(tab.getLo() + NO_ROWID_MARKER.length());</b>
<b class="fc"><i class="no-highlight">3640</i>&nbsp;            supportsRandomAccess = false;</b>
<i class="no-highlight">3641</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">3642</i>&nbsp;            supportsRandomAccess = true;</b>
<i class="no-highlight">3643</i>&nbsp;        }
<i class="no-highlight">3644</i>&nbsp;
<b class="fc"><i class="no-highlight">3645</i>&nbsp;        final TableToken tableToken = executionContext.getTableToken(tab);</b>
<b class="fc"><i class="no-highlight">3646</i>&nbsp;        if (model.isUpdate() &amp;&amp; !executionContext.isWalApplication()) {</b>
<b class="nc"><i class="no-highlight">3647</i>&nbsp;            try (</b>
<b class="fc"><i class="no-highlight">3648</i>&nbsp;                    TableReader reader = executionContext.getReader(tableToken);</b>
<b class="fc"><i class="no-highlight">3649</i>&nbsp;                    TableRecordMetadata metadata = executionContext.getMetadata(tableToken, model.getTableVersion())</b>
<i class="no-highlight">3650</i>&nbsp;            ) {
<b class="fc"><i class="no-highlight">3651</i>&nbsp;                return generateTableQuery0(model, executionContext, latestBy, supportsRandomAccess, reader, metadata);</b>
<b class="fc"><i class="no-highlight">3652</i>&nbsp;            }</b>
<i class="no-highlight">3653</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">3654</i>&nbsp;            try (TableReader reader = executionContext.getReader(</b>
<i class="no-highlight">3655</i>&nbsp;                    tableToken,
<b class="fc"><i class="no-highlight">3656</i>&nbsp;                    model.getTableVersion())) {</b>
<b class="fc"><i class="no-highlight">3657</i>&nbsp;                return generateTableQuery0(model, executionContext, latestBy, supportsRandomAccess, reader, reader.getMetadata());</b>
<b class="fc"><i class="no-highlight">3658</i>&nbsp;            }</b>
<i class="no-highlight">3659</i>&nbsp;        }
<i class="no-highlight">3660</i>&nbsp;    }
<i class="no-highlight">3661</i>&nbsp;
<i class="no-highlight">3662</i>&nbsp;    private RecordCursorFactory generateTableQuery0(QueryModel model, SqlExecutionContext executionContext, ObjList&lt;ExpressionNode&gt; latestBy, boolean supportsRandomAccess, TableReader reader, TableRecordMetadata metadata) throws SqlException {
<i class="no-highlight">3663</i>&nbsp;        // create metadata based on top-down columns that are required
<i class="no-highlight">3664</i>&nbsp;
<b class="fc"><i class="no-highlight">3665</i>&nbsp;        final ObjList&lt;QueryColumn&gt; topDownColumns = model.getTopDownColumns();</b>
<b class="fc"><i class="no-highlight">3666</i>&nbsp;        final int topDownColumnCount = topDownColumns.size();</b>
<b class="fc"><i class="no-highlight">3667</i>&nbsp;        final IntList columnIndexes = new IntList();</b>
<b class="fc"><i class="no-highlight">3668</i>&nbsp;        final IntList columnSizes = new IntList();</b>
<i class="no-highlight">3669</i>&nbsp;
<i class="no-highlight">3670</i>&nbsp;        // topDownColumnCount can be 0 for &#39;select count()&#39; queries
<i class="no-highlight">3671</i>&nbsp;
<i class="no-highlight">3672</i>&nbsp;        int readerTimestampIndex;
<b class="fc"><i class="no-highlight">3673</i>&nbsp;        readerTimestampIndex = getTimestampIndex(model, metadata);</b>
<i class="no-highlight">3674</i>&nbsp;
<i class="no-highlight">3675</i>&nbsp;        // Latest by on a table requires the provided timestamp column to be the designated timestamp.
<b class="fc"><i class="no-highlight">3676</i>&nbsp;        if (latestBy.size() &gt; 0 &amp;&amp; readerTimestampIndex != metadata.getTimestampIndex()) {</b>
<b class="fc"><i class="no-highlight">3677</i>&nbsp;            throw SqlException.$(model.getTimestamp().position, &quot;latest by over a table requires designated TIMESTAMP&quot;);</b>
<i class="no-highlight">3678</i>&nbsp;        }
<i class="no-highlight">3679</i>&nbsp;
<b class="fc"><i class="no-highlight">3680</i>&nbsp;        boolean requiresTimestamp = joinsRequiringTimestamp[model.getJoinType()];</b>
<b class="fc"><i class="no-highlight">3681</i>&nbsp;        final GenericRecordMetadata myMeta = new GenericRecordMetadata();</b>
<i class="no-highlight">3682</i>&nbsp;        boolean framingSupported;
<i class="no-highlight">3683</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">3684</i>&nbsp;            if (requiresTimestamp) {</b>
<b class="fc"><i class="no-highlight">3685</i>&nbsp;                executionContext.pushTimestampRequiredFlag(true);</b>
<i class="no-highlight">3686</i>&nbsp;            }
<i class="no-highlight">3687</i>&nbsp;
<b class="fc"><i class="no-highlight">3688</i>&nbsp;            boolean contextTimestampRequired = executionContext.isTimestampRequired();</b>
<i class="no-highlight">3689</i>&nbsp;            // some &quot;sample by&quot; queries don&#39;t select any cols but needs timestamp col selected
<i class="no-highlight">3690</i>&nbsp;            // for example &quot;select count() from x sample by 1h&quot; implicitly needs timestamp column selected
<b class="fc"><i class="no-highlight">3691</i>&nbsp;            if (topDownColumnCount &gt; 0 || contextTimestampRequired || model.isUpdate()) {</b>
<b class="fc"><i class="no-highlight">3692</i>&nbsp;                framingSupported = true;</b>
<b class="fc"><i class="no-highlight">3693</i>&nbsp;                for (int i = 0; i &lt; topDownColumnCount; i++) {</b>
<b class="fc"><i class="no-highlight">3694</i>&nbsp;                    int columnIndex = metadata.getColumnIndexQuiet(topDownColumns.getQuick(i).getName());</b>
<b class="fc"><i class="no-highlight">3695</i>&nbsp;                    int type = metadata.getColumnType(columnIndex);</b>
<b class="fc"><i class="no-highlight">3696</i>&nbsp;                    int typeSize = ColumnType.sizeOf(type);</b>
<i class="no-highlight">3697</i>&nbsp;
<b class="fc"><i class="no-highlight">3698</i>&nbsp;                    columnIndexes.add(columnIndex);</b>
<b class="fc"><i class="no-highlight">3699</i>&nbsp;                    columnSizes.add(Numbers.msb(typeSize));</b>
<i class="no-highlight">3700</i>&nbsp;
<b class="fc"><i class="no-highlight">3701</i>&nbsp;                    myMeta.add(new TableColumnMetadata(</b>
<b class="fc"><i class="no-highlight">3702</i>&nbsp;                            Chars.toString(topDownColumns.getQuick(i).getName()),</b>
<i class="no-highlight">3703</i>&nbsp;                            type,
<b class="fc"><i class="no-highlight">3704</i>&nbsp;                            metadata.isColumnIndexed(columnIndex),</b>
<b class="fc"><i class="no-highlight">3705</i>&nbsp;                            metadata.getIndexValueBlockCapacity(columnIndex),</b>
<b class="fc"><i class="no-highlight">3706</i>&nbsp;                            metadata.isSymbolTableStatic(columnIndex),</b>
<b class="fc"><i class="no-highlight">3707</i>&nbsp;                            metadata.getMetadata(columnIndex)</b>
<i class="no-highlight">3708</i>&nbsp;                    ));
<i class="no-highlight">3709</i>&nbsp;
<b class="fc"><i class="no-highlight">3710</i>&nbsp;                    if (columnIndex == readerTimestampIndex) {</b>
<b class="fc"><i class="no-highlight">3711</i>&nbsp;                        myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);</b>
<i class="no-highlight">3712</i>&nbsp;                    }
<i class="no-highlight">3713</i>&nbsp;                }
<i class="no-highlight">3714</i>&nbsp;
<i class="no-highlight">3715</i>&nbsp;                // select timestamp when it is required but not already selected
<b class="fc"><i class="no-highlight">3716</i>&nbsp;                if (readerTimestampIndex != -1 &amp;&amp; myMeta.getTimestampIndex() == -1 &amp;&amp; contextTimestampRequired) {</b>
<b class="fc"><i class="no-highlight">3717</i>&nbsp;                    myMeta.add(new TableColumnMetadata(</b>
<b class="fc"><i class="no-highlight">3718</i>&nbsp;                            metadata.getColumnName(readerTimestampIndex),</b>
<b class="fc"><i class="no-highlight">3719</i>&nbsp;                            metadata.getColumnType(readerTimestampIndex),</b>
<b class="fc"><i class="no-highlight">3720</i>&nbsp;                            metadata.getMetadata(readerTimestampIndex)</b>
<i class="no-highlight">3721</i>&nbsp;                    ));
<b class="fc"><i class="no-highlight">3722</i>&nbsp;                    myMeta.setTimestampIndex(myMeta.getColumnCount() - 1);</b>
<i class="no-highlight">3723</i>&nbsp;
<b class="fc"><i class="no-highlight">3724</i>&nbsp;                    columnIndexes.add(readerTimestampIndex);</b>
<b class="fc"><i class="no-highlight">3725</i>&nbsp;                    columnSizes.add((Numbers.msb(ColumnType.TIMESTAMP)));</b>
<i class="no-highlight">3726</i>&nbsp;                }
<i class="no-highlight">3727</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">3728</i>&nbsp;                framingSupported = false;</b>
<i class="no-highlight">3729</i>&nbsp;            }
<i class="no-highlight">3730</i>&nbsp;        } finally {
<b class="fc"><i class="no-highlight">3731</i>&nbsp;            if (requiresTimestamp) {</b>
<b class="fc"><i class="no-highlight">3732</i>&nbsp;                executionContext.popTimestampRequiredFlag();</b>
<i class="no-highlight">3733</i>&nbsp;            }
<b class="nc"><i class="no-highlight">3734</i>&nbsp;        }</b>
<i class="no-highlight">3735</i>&nbsp;
<b class="fc"><i class="no-highlight">3736</i>&nbsp;        GenericRecordMetadata dfcFactoryMeta = GenericRecordMetadata.deepCopyOf(reader.getMetadata());</b>
<b class="fc"><i class="no-highlight">3737</i>&nbsp;        final int latestByColumnCount = prepareLatestByColumnIndexes(latestBy, myMeta);</b>
<i class="no-highlight">3738</i>&nbsp;        // Reader TableToken can have out of date table name in getLoggingName().
<i class="no-highlight">3739</i>&nbsp;        // We need to resolve it from the engine to get correct value.
<b class="fc"><i class="no-highlight">3740</i>&nbsp;        final TableToken tableToken = reader.getTableToken();</b>
<i class="no-highlight">3741</i>&nbsp;
<b class="fc"><i class="no-highlight">3742</i>&nbsp;        final ExpressionNode withinExtracted = whereClauseParser.extractWithin(</b>
<i class="no-highlight">3743</i>&nbsp;                model,
<b class="fc"><i class="no-highlight">3744</i>&nbsp;                model.getWhereClause(),</b>
<i class="no-highlight">3745</i>&nbsp;                metadata,
<i class="no-highlight">3746</i>&nbsp;                functionParser,
<i class="no-highlight">3747</i>&nbsp;                executionContext,
<i class="no-highlight">3748</i>&nbsp;                prefixes
<i class="no-highlight">3749</i>&nbsp;        );
<i class="no-highlight">3750</i>&nbsp;
<b class="fc"><i class="no-highlight">3751</i>&nbsp;        model.setWhereClause(withinExtracted);</b>
<i class="no-highlight">3752</i>&nbsp;
<b class="fc"><i class="no-highlight">3753</i>&nbsp;        if (withinExtracted != null) {</b>
<i class="no-highlight">3754</i>&nbsp;
<b class="fc"><i class="no-highlight">3755</i>&nbsp;            CharSequence preferredKeyColumn = null;</b>
<i class="no-highlight">3756</i>&nbsp;
<b class="fc"><i class="no-highlight">3757</i>&nbsp;            if (latestByColumnCount == 1) {</b>
<b class="fc"><i class="no-highlight">3758</i>&nbsp;                final int latestByIndex = listColumnFilterA.getColumnIndexFactored(0);</b>
<i class="no-highlight">3759</i>&nbsp;
<b class="fc"><i class="no-highlight">3760</i>&nbsp;                if (ColumnType.isSymbol(myMeta.getColumnType(latestByIndex))) {</b>
<b class="fc"><i class="no-highlight">3761</i>&nbsp;                    preferredKeyColumn = latestBy.getQuick(0).token;</b>
<i class="no-highlight">3762</i>&nbsp;                }
<i class="no-highlight">3763</i>&nbsp;            }
<i class="no-highlight">3764</i>&nbsp;
<b class="fc"><i class="no-highlight">3765</i>&nbsp;            final IntrinsicModel intrinsicModel = whereClauseParser.extract(</b>
<i class="no-highlight">3766</i>&nbsp;                    model,
<i class="no-highlight">3767</i>&nbsp;                    withinExtracted,
<i class="no-highlight">3768</i>&nbsp;                    metadata,
<i class="no-highlight">3769</i>&nbsp;                    preferredKeyColumn,
<i class="no-highlight">3770</i>&nbsp;                    readerTimestampIndex,
<i class="no-highlight">3771</i>&nbsp;                    functionParser,
<i class="no-highlight">3772</i>&nbsp;                    myMeta,
<i class="no-highlight">3773</i>&nbsp;                    executionContext,
<i class="no-highlight">3774</i>&nbsp;                    latestByColumnCount &gt; 1,
<i class="no-highlight">3775</i>&nbsp;                    reader
<i class="no-highlight">3776</i>&nbsp;            );
<i class="no-highlight">3777</i>&nbsp;
<i class="no-highlight">3778</i>&nbsp;            // intrinsic parser can collapse where clause when removing parts it can replace
<i class="no-highlight">3779</i>&nbsp;            // need to make sure that filter is updated on the model in case it is processed up the call stack
<i class="no-highlight">3780</i>&nbsp;            //
<i class="no-highlight">3781</i>&nbsp;            // At this juncture filter can use used up by one of the implementations below.
<i class="no-highlight">3782</i>&nbsp;            // We will clear it preemptively. If nothing picks filter up we will set model &quot;where&quot;
<i class="no-highlight">3783</i>&nbsp;            // to the downsized filter
<b class="fc"><i class="no-highlight">3784</i>&nbsp;            model.setWhereClause(null);</b>
<i class="no-highlight">3785</i>&nbsp;
<b class="fc"><i class="no-highlight">3786</i>&nbsp;            if (intrinsicModel.intrinsicValue == IntrinsicModel.FALSE) {</b>
<b class="fc"><i class="no-highlight">3787</i>&nbsp;                return new EmptyTableRecordCursorFactory(myMeta);</b>
<i class="no-highlight">3788</i>&nbsp;            }
<i class="no-highlight">3789</i>&nbsp;
<i class="no-highlight">3790</i>&nbsp;            DataFrameCursorFactory dfcFactory;
<i class="no-highlight">3791</i>&nbsp;
<b class="fc"><i class="no-highlight">3792</i>&nbsp;            if (latestByColumnCount &gt; 0) {</b>
<b class="fc"><i class="no-highlight">3793</i>&nbsp;                Function f = compileFilter(intrinsicModel, myMeta, executionContext);</b>
<b class="fc"><i class="no-highlight">3794</i>&nbsp;                if (f != null &amp;&amp; f.isConstant() &amp;&amp; !f.getBool(null)) {</b>
<i class="no-highlight">3795</i>&nbsp;                    // &#39;latest by&#39; clause takes over the latest by nodes, so that the later generateLatestBy() is no-op
<b class="fc"><i class="no-highlight">3796</i>&nbsp;                    model.getLatestBy().clear();</b>
<b class="fc"><i class="no-highlight">3797</i>&nbsp;                    Misc.free(f);</b>
<b class="fc"><i class="no-highlight">3798</i>&nbsp;                    return new EmptyTableRecordCursorFactory(myMeta);</b>
<i class="no-highlight">3799</i>&nbsp;                }
<i class="no-highlight">3800</i>&nbsp;
<i class="no-highlight">3801</i>&nbsp;                // a sub-query present in the filter may have used the latest by
<i class="no-highlight">3802</i>&nbsp;                // column index lists, so we need to regenerate them
<b class="fc"><i class="no-highlight">3803</i>&nbsp;                prepareLatestByColumnIndexes(latestBy, myMeta);</b>
<i class="no-highlight">3804</i>&nbsp;
<b class="fc"><i class="no-highlight">3805</i>&nbsp;                return generateLatestByTableQuery(</b>
<i class="no-highlight">3806</i>&nbsp;                        model,
<i class="no-highlight">3807</i>&nbsp;                        reader,
<i class="no-highlight">3808</i>&nbsp;                        myMeta,
<i class="no-highlight">3809</i>&nbsp;                        tableToken,
<i class="no-highlight">3810</i>&nbsp;                        intrinsicModel,
<i class="no-highlight">3811</i>&nbsp;                        f,
<i class="no-highlight">3812</i>&nbsp;                        executionContext,
<i class="no-highlight">3813</i>&nbsp;                        readerTimestampIndex,
<i class="no-highlight">3814</i>&nbsp;                        columnIndexes,
<i class="no-highlight">3815</i>&nbsp;                        columnSizes,
<i class="no-highlight">3816</i>&nbsp;                        prefixes
<i class="no-highlight">3817</i>&nbsp;                );
<i class="no-highlight">3818</i>&nbsp;            }
<i class="no-highlight">3819</i>&nbsp;
<i class="no-highlight">3820</i>&nbsp;            // below code block generates index-based filter
<i class="no-highlight">3821</i>&nbsp;            final boolean intervalHitsOnlyOnePartition;
<b class="fc"><i class="no-highlight">3822</i>&nbsp;            if (intrinsicModel.hasIntervalFilters()) {</b>
<b class="fc"><i class="no-highlight">3823</i>&nbsp;                RuntimeIntrinsicIntervalModel intervalModel = intrinsicModel.buildIntervalModel();</b>
<b class="fc"><i class="no-highlight">3824</i>&nbsp;                dfcFactory = new IntervalFwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), intervalModel, readerTimestampIndex, dfcFactoryMeta);</b>
<b class="fc"><i class="no-highlight">3825</i>&nbsp;                intervalHitsOnlyOnePartition = intervalModel.allIntervalsHitOnePartition(reader.getPartitionedBy());</b>
<b class="fc"><i class="no-highlight">3826</i>&nbsp;            } else {</b>
<b class="fc"><i class="no-highlight">3827</i>&nbsp;                dfcFactory = new FullFwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</b>
<b class="fc"><i class="no-highlight">3828</i>&nbsp;                intervalHitsOnlyOnePartition = false;</b>
<i class="no-highlight">3829</i>&nbsp;            }
<i class="no-highlight">3830</i>&nbsp;
<b class="fc"><i class="no-highlight">3831</i>&nbsp;            if (intrinsicModel.keyColumn != null) {</b>
<i class="no-highlight">3832</i>&nbsp;                // existence of column would have been already validated
<b class="fc"><i class="no-highlight">3833</i>&nbsp;                final int keyColumnIndex = metadata.getColumnIndexQuiet(intrinsicModel.keyColumn);</b>
<b class="fc"><i class="no-highlight">3834</i>&nbsp;                final int nKeyValues = intrinsicModel.keyValueFuncs.size();</b>
<b class="fc"><i class="no-highlight">3835</i>&nbsp;                final int nKeyExcludedValues = intrinsicModel.keyExcludedValueFuncs.size();</b>
<i class="no-highlight">3836</i>&nbsp;
<b class="fc"><i class="no-highlight">3837</i>&nbsp;                if (intrinsicModel.keySubQuery != null) {</b>
<b class="fc"><i class="no-highlight">3838</i>&nbsp;                    final RecordCursorFactory rcf = generate(intrinsicModel.keySubQuery, executionContext);</b>
<b class="fc"><i class="no-highlight">3839</i>&nbsp;                    final Record.CharSequenceFunction func = validateSubQueryColumnAndGetGetter(intrinsicModel, rcf.getMetadata());</b>
<i class="no-highlight">3840</i>&nbsp;
<b class="fc"><i class="no-highlight">3841</i>&nbsp;                    Function f = compileFilter(intrinsicModel, myMeta, executionContext);</b>
<b class="fc"><i class="no-highlight">3842</i>&nbsp;                    if (f != null &amp;&amp; f.isConstant() &amp;&amp; !f.getBool(null)) {</b>
<b class="fc"><i class="no-highlight">3843</i>&nbsp;                        Misc.free(dfcFactory);</b>
<b class="fc"><i class="no-highlight">3844</i>&nbsp;                        return new EmptyTableRecordCursorFactory(myMeta);</b>
<i class="no-highlight">3845</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">3846</i>&nbsp;                    return new FilterOnSubQueryRecordCursorFactory(</b>
<i class="no-highlight">3847</i>&nbsp;                            myMeta,
<i class="no-highlight">3848</i>&nbsp;                            dfcFactory,
<i class="no-highlight">3849</i>&nbsp;                            rcf,
<i class="no-highlight">3850</i>&nbsp;                            keyColumnIndex,
<i class="no-highlight">3851</i>&nbsp;                            f,
<i class="no-highlight">3852</i>&nbsp;                            func,
<i class="no-highlight">3853</i>&nbsp;                            columnIndexes
<i class="no-highlight">3854</i>&nbsp;                    );
<i class="no-highlight">3855</i>&nbsp;                }
<b class="fc"><i class="no-highlight">3856</i>&nbsp;                assert nKeyValues &gt; 0 || nKeyExcludedValues &gt; 0;</b>
<i class="no-highlight">3857</i>&nbsp;
<b class="fc"><i class="no-highlight">3858</i>&nbsp;                boolean orderByKeyColumn = false;</b>
<b class="fc"><i class="no-highlight">3859</i>&nbsp;                int indexDirection = BitmapIndexReader.DIR_FORWARD;</b>
<b class="fc"><i class="no-highlight">3860</i>&nbsp;                if (intervalHitsOnlyOnePartition) {</b>
<b class="fc"><i class="no-highlight">3861</i>&nbsp;                    final ObjList&lt;ExpressionNode&gt; orderByAdvice = model.getOrderByAdvice();</b>
<b class="fc"><i class="no-highlight">3862</i>&nbsp;                    final int orderByAdviceSize = orderByAdvice.size();</b>
<b class="fc"><i class="no-highlight">3863</i>&nbsp;                    if (orderByAdviceSize &gt; 0 &amp;&amp; orderByAdviceSize &lt; 3) {</b>
<i class="no-highlight">3864</i>&nbsp;                        // todo: when order by coincides with keyColumn and there is index we can incorporate
<i class="no-highlight">3865</i>&nbsp;                        //    ordering in the code that returns rows from index rather than having an
<i class="no-highlight">3866</i>&nbsp;                        //    &quot;overhead&quot; order by implementation, which would be trying to oder already ordered symbols
<b class="fc"><i class="no-highlight">3867</i>&nbsp;                        if (Chars.equals(orderByAdvice.getQuick(0).token, intrinsicModel.keyColumn)) {</b>
<b class="fc"><i class="no-highlight">3868</i>&nbsp;                            myMeta.setTimestampIndex(-1);</b>
<b class="fc"><i class="no-highlight">3869</i>&nbsp;                            if (orderByAdviceSize == 1) {</b>
<b class="fc"><i class="no-highlight">3870</i>&nbsp;                                orderByKeyColumn = true;</b>
<b class="fc"><i class="no-highlight">3871</i>&nbsp;                            } else if (Chars.equals(orderByAdvice.getQuick(1).token, model.getTimestamp().token)) {</b>
<b class="fc"><i class="no-highlight">3872</i>&nbsp;                                orderByKeyColumn = true;</b>
<b class="fc"><i class="no-highlight">3873</i>&nbsp;                                if (getOrderByDirectionOrDefault(model, 1) == QueryModel.ORDER_DIRECTION_DESCENDING) {</b>
<b class="fc"><i class="no-highlight">3874</i>&nbsp;                                    indexDirection = BitmapIndexReader.DIR_BACKWARD;</b>
<i class="no-highlight">3875</i>&nbsp;                                }
<i class="no-highlight">3876</i>&nbsp;                            }
<i class="no-highlight">3877</i>&nbsp;                        }
<i class="no-highlight">3878</i>&nbsp;                    }
<i class="no-highlight">3879</i>&nbsp;                }
<i class="no-highlight">3880</i>&nbsp;
<b class="fc"><i class="no-highlight">3881</i>&nbsp;                if (intrinsicModel.keyExcludedValueFuncs.size() == 0) {</b>
<b class="fc"><i class="no-highlight">3882</i>&nbsp;                    Function f = compileFilter(intrinsicModel, myMeta, executionContext);</b>
<b class="fc"><i class="no-highlight">3883</i>&nbsp;                    if (f != null &amp;&amp; f.isConstant()) {</b>
<i class="no-highlight">3884</i>&nbsp;                        try {
<b class="fc"><i class="no-highlight">3885</i>&nbsp;                            if (!f.getBool(null)) {</b>
<b class="fc"><i class="no-highlight">3886</i>&nbsp;                                Misc.free(dfcFactory);</b>
<b class="fc"><i class="no-highlight">3887</i>&nbsp;                                return new EmptyTableRecordCursorFactory(myMeta);</b>
<i class="no-highlight">3888</i>&nbsp;                            }
<i class="no-highlight">3889</i>&nbsp;                        } finally {
<b class="fc"><i class="no-highlight">3890</i>&nbsp;                            f = Misc.free(f);</b>
<b class="fc"><i class="no-highlight">3891</i>&nbsp;                        }</b>
<i class="no-highlight">3892</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">3893</i>&nbsp;                    if (nKeyValues == 1) {</b>
<i class="no-highlight">3894</i>&nbsp;                        final RowCursorFactory rcf;
<b class="fc"><i class="no-highlight">3895</i>&nbsp;                        final Function symbolFunc = intrinsicModel.keyValueFuncs.get(0);</b>
<b class="fc"><i class="no-highlight">3896</i>&nbsp;                        final SymbolMapReader symbolMapReader = reader.getSymbolMapReader(keyColumnIndex);</b>
<b class="fc"><i class="no-highlight">3897</i>&nbsp;                        final int symbolKey = symbolFunc.isRuntimeConstant()</b>
<b class="fc"><i class="no-highlight">3898</i>&nbsp;                                ? SymbolTable.VALUE_NOT_FOUND</b>
<b class="fc"><i class="no-highlight">3899</i>&nbsp;                                : symbolMapReader.keyOf(symbolFunc.getStr(null));</b>
<i class="no-highlight">3900</i>&nbsp;
<b class="fc"><i class="no-highlight">3901</i>&nbsp;                        if (symbolKey == SymbolTable.VALUE_NOT_FOUND) {</b>
<b class="fc"><i class="no-highlight">3902</i>&nbsp;                            if (f == null) {</b>
<b class="fc"><i class="no-highlight">3903</i>&nbsp;                                rcf = new DeferredSymbolIndexRowCursorFactory(keyColumnIndex,</b>
<i class="no-highlight">3904</i>&nbsp;                                        symbolFunc,
<i class="no-highlight">3905</i>&nbsp;                                        true,
<i class="no-highlight">3906</i>&nbsp;                                        indexDirection
<i class="no-highlight">3907</i>&nbsp;                                );
<i class="no-highlight">3908</i>&nbsp;                            } else {
<b class="fc"><i class="no-highlight">3909</i>&nbsp;                                rcf = new DeferredSymbolIndexFilteredRowCursorFactory(</b>
<i class="no-highlight">3910</i>&nbsp;                                        keyColumnIndex,
<i class="no-highlight">3911</i>&nbsp;                                        symbolFunc,
<i class="no-highlight">3912</i>&nbsp;                                        f,
<i class="no-highlight">3913</i>&nbsp;                                        true,
<i class="no-highlight">3914</i>&nbsp;                                        indexDirection,
<i class="no-highlight">3915</i>&nbsp;                                        columnIndexes
<i class="no-highlight">3916</i>&nbsp;                                );
<i class="no-highlight">3917</i>&nbsp;                            }
<i class="no-highlight">3918</i>&nbsp;                        } else {
<b class="fc"><i class="no-highlight">3919</i>&nbsp;                            if (f == null) {</b>
<b class="fc"><i class="no-highlight">3920</i>&nbsp;                                rcf = new SymbolIndexRowCursorFactory(keyColumnIndex, symbolKey, true, indexDirection, null);</b>
<i class="no-highlight">3921</i>&nbsp;                            } else {
<b class="fc"><i class="no-highlight">3922</i>&nbsp;                                rcf = new SymbolIndexFilteredRowCursorFactory(keyColumnIndex, symbolKey, f, true, indexDirection, columnIndexes, null);</b>
<i class="no-highlight">3923</i>&nbsp;                            }
<i class="no-highlight">3924</i>&nbsp;                        }
<i class="no-highlight">3925</i>&nbsp;
<b class="fc"><i class="no-highlight">3926</i>&nbsp;                        if (f == null) {</b>
<i class="no-highlight">3927</i>&nbsp;                            // This special case factory can later be disassembled to framing and index
<i class="no-highlight">3928</i>&nbsp;                            // cursors in Sample By processing
<b class="fc"><i class="no-highlight">3929</i>&nbsp;                            return new DeferredSingleSymbolFilterDataFrameRecordCursorFactory(</b>
<i class="no-highlight">3930</i>&nbsp;                                    configuration,
<i class="no-highlight">3931</i>&nbsp;                                    keyColumnIndex,
<i class="no-highlight">3932</i>&nbsp;                                    symbolFunc,
<i class="no-highlight">3933</i>&nbsp;                                    rcf,
<i class="no-highlight">3934</i>&nbsp;                                    myMeta,
<i class="no-highlight">3935</i>&nbsp;                                    dfcFactory,
<i class="no-highlight">3936</i>&nbsp;                                    orderByKeyColumn,
<i class="no-highlight">3937</i>&nbsp;                                    columnIndexes,
<i class="no-highlight">3938</i>&nbsp;                                    columnSizes,
<i class="no-highlight">3939</i>&nbsp;                                    supportsRandomAccess
<i class="no-highlight">3940</i>&nbsp;                            );
<i class="no-highlight">3941</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">3942</i>&nbsp;                        return new DataFrameRecordCursorFactory(</b>
<i class="no-highlight">3943</i>&nbsp;                                configuration,
<i class="no-highlight">3944</i>&nbsp;                                myMeta,
<i class="no-highlight">3945</i>&nbsp;                                dfcFactory,
<i class="no-highlight">3946</i>&nbsp;                                rcf,
<i class="no-highlight">3947</i>&nbsp;                                orderByKeyColumn,
<i class="no-highlight">3948</i>&nbsp;                                f,
<i class="no-highlight">3949</i>&nbsp;                                false,
<i class="no-highlight">3950</i>&nbsp;                                columnIndexes,
<i class="no-highlight">3951</i>&nbsp;                                columnSizes,
<i class="no-highlight">3952</i>&nbsp;                                supportsRandomAccess
<i class="no-highlight">3953</i>&nbsp;                        );
<i class="no-highlight">3954</i>&nbsp;                    }
<i class="no-highlight">3955</i>&nbsp;
<b class="fc"><i class="no-highlight">3956</i>&nbsp;                    if (orderByKeyColumn) {</b>
<b class="fc"><i class="no-highlight">3957</i>&nbsp;                        myMeta.setTimestampIndex(-1);</b>
<i class="no-highlight">3958</i>&nbsp;                    }
<i class="no-highlight">3959</i>&nbsp;
<b class="fc"><i class="no-highlight">3960</i>&nbsp;                    return new FilterOnValuesRecordCursorFactory(</b>
<i class="no-highlight">3961</i>&nbsp;                            myMeta,
<i class="no-highlight">3962</i>&nbsp;                            dfcFactory,
<i class="no-highlight">3963</i>&nbsp;                            intrinsicModel.keyValueFuncs,
<i class="no-highlight">3964</i>&nbsp;                            keyColumnIndex,
<i class="no-highlight">3965</i>&nbsp;                            reader,
<i class="no-highlight">3966</i>&nbsp;                            f,
<b class="fc"><i class="no-highlight">3967</i>&nbsp;                            model.getOrderByAdviceMnemonic(),</b>
<i class="no-highlight">3968</i>&nbsp;                            orderByKeyColumn,
<b class="fc"><i class="no-highlight">3969</i>&nbsp;                            getOrderByDirectionOrDefault(model, 0),</b>
<i class="no-highlight">3970</i>&nbsp;                            indexDirection,
<i class="no-highlight">3971</i>&nbsp;                            columnIndexes
<i class="no-highlight">3972</i>&nbsp;                    );
<b class="fc"><i class="no-highlight">3973</i>&nbsp;                } else if (</b>
<b class="fc"><i class="no-highlight">3974</i>&nbsp;                        intrinsicModel.keyExcludedValueFuncs.size() &gt; 0</b>
<b class="fc"><i class="no-highlight">3975</i>&nbsp;                                &amp;&amp; reader.getSymbolMapReader(keyColumnIndex).getSymbolCount() &lt; configuration.getMaxSymbolNotEqualsCount()</b>
<i class="no-highlight">3976</i>&nbsp;                ) {
<b class="fc"><i class="no-highlight">3977</i>&nbsp;                    Function f = compileFilter(intrinsicModel, myMeta, executionContext);</b>
<b class="fc"><i class="no-highlight">3978</i>&nbsp;                    if (f != null &amp;&amp; f.isConstant()) {</b>
<i class="no-highlight">3979</i>&nbsp;                        try {
<b class="fc"><i class="no-highlight">3980</i>&nbsp;                            if (!f.getBool(null)) {</b>
<b class="fc"><i class="no-highlight">3981</i>&nbsp;                                Misc.free(dfcFactory);</b>
<b class="fc"><i class="no-highlight">3982</i>&nbsp;                                return new EmptyTableRecordCursorFactory(myMeta);</b>
<i class="no-highlight">3983</i>&nbsp;                            }
<i class="no-highlight">3984</i>&nbsp;                        } finally {
<b class="fc"><i class="no-highlight">3985</i>&nbsp;                            f = Misc.free(f);</b>
<b class="nc"><i class="no-highlight">3986</i>&nbsp;                        }</b>
<i class="no-highlight">3987</i>&nbsp;                    }
<i class="no-highlight">3988</i>&nbsp;
<b class="fc"><i class="no-highlight">3989</i>&nbsp;                    return new FilterOnExcludedValuesRecordCursorFactory(</b>
<i class="no-highlight">3990</i>&nbsp;                            myMeta,
<i class="no-highlight">3991</i>&nbsp;                            dfcFactory,
<i class="no-highlight">3992</i>&nbsp;                            intrinsicModel.keyExcludedValueFuncs,
<i class="no-highlight">3993</i>&nbsp;                            keyColumnIndex,
<i class="no-highlight">3994</i>&nbsp;                            f,
<b class="fc"><i class="no-highlight">3995</i>&nbsp;                            model.getOrderByAdviceMnemonic(),</b>
<i class="no-highlight">3996</i>&nbsp;                            orderByKeyColumn,
<i class="no-highlight">3997</i>&nbsp;                            indexDirection,
<i class="no-highlight">3998</i>&nbsp;                            columnIndexes,
<b class="fc"><i class="no-highlight">3999</i>&nbsp;                            configuration.getMaxSymbolNotEqualsCount()</b>
<i class="no-highlight">4000</i>&nbsp;                    );
<i class="no-highlight">4001</i>&nbsp;                }
<i class="no-highlight">4002</i>&nbsp;            }
<i class="no-highlight">4003</i>&nbsp;
<b class="fc"><i class="no-highlight">4004</i>&nbsp;            if (intervalHitsOnlyOnePartition &amp;&amp; intrinsicModel.filter == null) {</b>
<b class="fc"><i class="no-highlight">4005</i>&nbsp;                final ObjList&lt;ExpressionNode&gt; orderByAdvice = model.getOrderByAdvice();</b>
<b class="fc"><i class="no-highlight">4006</i>&nbsp;                final int orderByAdviceSize = orderByAdvice.size();</b>
<b class="fc"><i class="no-highlight">4007</i>&nbsp;                if (orderByAdviceSize &gt; 0 &amp;&amp; orderByAdviceSize &lt; 3 &amp;&amp; intrinsicModel.hasIntervalFilters()) {</b>
<i class="no-highlight">4008</i>&nbsp;                    // we can only deal with &#39;order by symbol, timestamp&#39; at best
<i class="no-highlight">4009</i>&nbsp;                    // skip this optimisation if order by is more extensive
<b class="fc"><i class="no-highlight">4010</i>&nbsp;                    final int columnIndex = myMeta.getColumnIndexQuiet(model.getOrderByAdvice().getQuick(0).token);</b>
<b class="fc"><i class="no-highlight">4011</i>&nbsp;                    assert columnIndex &gt; -1;</b>
<i class="no-highlight">4012</i>&nbsp;
<i class="no-highlight">4013</i>&nbsp;                    // this is our kind of column
<b class="fc"><i class="no-highlight">4014</i>&nbsp;                    if (myMeta.isColumnIndexed(columnIndex)) {</b>
<b class="fc"><i class="no-highlight">4015</i>&nbsp;                        boolean orderByKeyColumn = false;</b>
<b class="fc"><i class="no-highlight">4016</i>&nbsp;                        int indexDirection = BitmapIndexReader.DIR_FORWARD;</b>
<b class="fc"><i class="no-highlight">4017</i>&nbsp;                        if (orderByAdviceSize == 1) {</b>
<b class="fc"><i class="no-highlight">4018</i>&nbsp;                            orderByKeyColumn = true;</b>
<b class="fc"><i class="no-highlight">4019</i>&nbsp;                        } else if (Chars.equals(orderByAdvice.getQuick(1).token, model.getTimestamp().token)) {</b>
<b class="fc"><i class="no-highlight">4020</i>&nbsp;                            orderByKeyColumn = true;</b>
<b class="fc"><i class="no-highlight">4021</i>&nbsp;                            if (getOrderByDirectionOrDefault(model, 1) == QueryModel.ORDER_DIRECTION_DESCENDING) {</b>
<b class="fc"><i class="no-highlight">4022</i>&nbsp;                                indexDirection = BitmapIndexReader.DIR_BACKWARD;</b>
<i class="no-highlight">4023</i>&nbsp;                            }
<i class="no-highlight">4024</i>&nbsp;                        }
<i class="no-highlight">4025</i>&nbsp;
<b class="fc"><i class="no-highlight">4026</i>&nbsp;                        if (orderByKeyColumn) {</b>
<i class="no-highlight">4027</i>&nbsp;                            // check that intrinsicModel.intervals hit only one partition
<b class="fc"><i class="no-highlight">4028</i>&nbsp;                            myMeta.setTimestampIndex(-1);</b>
<b class="fc"><i class="no-highlight">4029</i>&nbsp;                            return new SortedSymbolIndexRecordCursorFactory(</b>
<i class="no-highlight">4030</i>&nbsp;                                    myMeta,
<i class="no-highlight">4031</i>&nbsp;                                    dfcFactory,
<i class="no-highlight">4032</i>&nbsp;                                    columnIndex,
<b class="fc"><i class="no-highlight">4033</i>&nbsp;                                    getOrderByDirectionOrDefault(model, 0) == QueryModel.ORDER_DIRECTION_ASCENDING,</b>
<i class="no-highlight">4034</i>&nbsp;                                    indexDirection,
<i class="no-highlight">4035</i>&nbsp;                                    columnIndexes
<i class="no-highlight">4036</i>&nbsp;                            );
<i class="no-highlight">4037</i>&nbsp;                        }
<i class="no-highlight">4038</i>&nbsp;                    }
<i class="no-highlight">4039</i>&nbsp;                }
<i class="no-highlight">4040</i>&nbsp;            }
<i class="no-highlight">4041</i>&nbsp;
<b class="fc"><i class="no-highlight">4042</i>&nbsp;            boolean isOrderByTimestampDesc = isOrderDescendingByDesignatedTimestampOnly(model);</b>
<i class="no-highlight">4043</i>&nbsp;            RowCursorFactory rowFactory;
<i class="no-highlight">4044</i>&nbsp;
<b class="fc"><i class="no-highlight">4045</i>&nbsp;            if (isOrderByTimestampDesc &amp;&amp; !intrinsicModel.hasIntervalFilters()) {</b>
<b class="fc"><i class="no-highlight">4046</i>&nbsp;                Misc.free(dfcFactory);</b>
<b class="fc"><i class="no-highlight">4047</i>&nbsp;                dfcFactory = new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</b>
<b class="fc"><i class="no-highlight">4048</i>&nbsp;                rowFactory = new BwdDataFrameRowCursorFactory();</b>
<i class="no-highlight">4049</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4050</i>&nbsp;                rowFactory = new DataFrameRowCursorFactory();</b>
<i class="no-highlight">4051</i>&nbsp;            }
<i class="no-highlight">4052</i>&nbsp;
<b class="fc"><i class="no-highlight">4053</i>&nbsp;            model.setWhereClause(intrinsicModel.filter);</b>
<b class="fc"><i class="no-highlight">4054</i>&nbsp;            return new DataFrameRecordCursorFactory(</b>
<i class="no-highlight">4055</i>&nbsp;                    configuration,
<i class="no-highlight">4056</i>&nbsp;                    myMeta,
<i class="no-highlight">4057</i>&nbsp;                    dfcFactory,
<i class="no-highlight">4058</i>&nbsp;                    rowFactory,
<i class="no-highlight">4059</i>&nbsp;                    false,
<i class="no-highlight">4060</i>&nbsp;                    null,
<i class="no-highlight">4061</i>&nbsp;                    framingSupported,
<i class="no-highlight">4062</i>&nbsp;                    columnIndexes,
<i class="no-highlight">4063</i>&nbsp;                    columnSizes,
<i class="no-highlight">4064</i>&nbsp;                    supportsRandomAccess
<i class="no-highlight">4065</i>&nbsp;            );
<i class="no-highlight">4066</i>&nbsp;        }
<i class="no-highlight">4067</i>&nbsp;
<i class="no-highlight">4068</i>&nbsp;        // no where clause
<b class="fc"><i class="no-highlight">4069</i>&nbsp;        if (latestByColumnCount == 0) {</b>
<i class="no-highlight">4070</i>&nbsp;            // construct new metadata, which is a copy of what we constructed just above, but
<i class="no-highlight">4071</i>&nbsp;            // in the interest of isolating problems we will only affect this factory
<i class="no-highlight">4072</i>&nbsp;
<i class="no-highlight">4073</i>&nbsp;            AbstractDataFrameCursorFactory cursorFactory;
<i class="no-highlight">4074</i>&nbsp;            RowCursorFactory rowCursorFactory;
<i class="no-highlight">4075</i>&nbsp;
<b class="fc"><i class="no-highlight">4076</i>&nbsp;            if (isOrderDescendingByDesignatedTimestampOnly(model)) {</b>
<b class="fc"><i class="no-highlight">4077</i>&nbsp;                cursorFactory = new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</b>
<b class="fc"><i class="no-highlight">4078</i>&nbsp;                rowCursorFactory = new BwdDataFrameRowCursorFactory();</b>
<i class="no-highlight">4079</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4080</i>&nbsp;                cursorFactory = new FullFwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta);</b>
<b class="fc"><i class="no-highlight">4081</i>&nbsp;                rowCursorFactory = new DataFrameRowCursorFactory();</b>
<i class="no-highlight">4082</i>&nbsp;            }
<i class="no-highlight">4083</i>&nbsp;
<b class="fc"><i class="no-highlight">4084</i>&nbsp;            return new DataFrameRecordCursorFactory(</b>
<i class="no-highlight">4085</i>&nbsp;                    configuration,
<i class="no-highlight">4086</i>&nbsp;                    myMeta,
<i class="no-highlight">4087</i>&nbsp;                    cursorFactory,
<i class="no-highlight">4088</i>&nbsp;                    rowCursorFactory,
<i class="no-highlight">4089</i>&nbsp;                    false,
<i class="no-highlight">4090</i>&nbsp;                    null,
<i class="no-highlight">4091</i>&nbsp;                    framingSupported,
<i class="no-highlight">4092</i>&nbsp;                    columnIndexes,
<i class="no-highlight">4093</i>&nbsp;                    columnSizes,
<i class="no-highlight">4094</i>&nbsp;                    supportsRandomAccess
<i class="no-highlight">4095</i>&nbsp;            );
<i class="no-highlight">4096</i>&nbsp;        }
<i class="no-highlight">4097</i>&nbsp;
<i class="no-highlight">4098</i>&nbsp;        // &#39;latest by&#39; clause takes over the latest by nodes, so that the later generateLatestBy() is no-op
<b class="fc"><i class="no-highlight">4099</i>&nbsp;        model.getLatestBy().clear();</b>
<i class="no-highlight">4100</i>&nbsp;
<i class="no-highlight">4101</i>&nbsp;        // listColumnFilterA = latest by column indexes
<b class="fc"><i class="no-highlight">4102</i>&nbsp;        if (latestByColumnCount == 1) {</b>
<b class="fc"><i class="no-highlight">4103</i>&nbsp;            int latestByColumnIndex = listColumnFilterA.getColumnIndexFactored(0);</b>
<b class="fc"><i class="no-highlight">4104</i>&nbsp;            if (myMeta.isColumnIndexed(latestByColumnIndex)) {</b>
<b class="fc"><i class="no-highlight">4105</i>&nbsp;                return new LatestByAllIndexedRecordCursorFactory(</b>
<i class="no-highlight">4106</i>&nbsp;                        myMeta,
<i class="no-highlight">4107</i>&nbsp;                        configuration,
<b class="fc"><i class="no-highlight">4108</i>&nbsp;                        new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</b>
<b class="fc"><i class="no-highlight">4109</i>&nbsp;                        listColumnFilterA.getColumnIndexFactored(0),</b>
<i class="no-highlight">4110</i>&nbsp;                        columnIndexes,
<i class="no-highlight">4111</i>&nbsp;                        prefixes
<i class="no-highlight">4112</i>&nbsp;                );
<i class="no-highlight">4113</i>&nbsp;            }
<i class="no-highlight">4114</i>&nbsp;
<b class="fc"><i class="no-highlight">4115</i>&nbsp;            if (ColumnType.isSymbol(myMeta.getColumnType(latestByColumnIndex))</b>
<b class="fc"><i class="no-highlight">4116</i>&nbsp;                    &amp;&amp; myMeta.isSymbolTableStatic(latestByColumnIndex)) {</b>
<i class="no-highlight">4117</i>&nbsp;                // we have &quot;latest by&quot; symbol column values, but no index
<b class="fc"><i class="no-highlight">4118</i>&nbsp;                return new LatestByDeferredListValuesFilteredRecordCursorFactory(</b>
<i class="no-highlight">4119</i>&nbsp;                        configuration,
<i class="no-highlight">4120</i>&nbsp;                        myMeta,
<b class="fc"><i class="no-highlight">4121</i>&nbsp;                        new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</b>
<i class="no-highlight">4122</i>&nbsp;                        latestByColumnIndex,
<i class="no-highlight">4123</i>&nbsp;                        null,
<i class="no-highlight">4124</i>&nbsp;                        columnIndexes
<i class="no-highlight">4125</i>&nbsp;                );
<i class="no-highlight">4126</i>&nbsp;            }
<i class="no-highlight">4127</i>&nbsp;        }
<i class="no-highlight">4128</i>&nbsp;
<b class="fc"><i class="no-highlight">4129</i>&nbsp;        boolean symbolKeysOnly = true;</b>
<b class="fc"><i class="no-highlight">4130</i>&nbsp;        for (int i = 0, n = keyTypes.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">4131</i>&nbsp;            symbolKeysOnly &amp;= ColumnType.isSymbol(keyTypes.getColumnType(i));</b>
<i class="no-highlight">4132</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4133</i>&nbsp;        if (symbolKeysOnly) {</b>
<b class="fc"><i class="no-highlight">4134</i>&nbsp;            IntList partitionByColumnIndexes = new IntList(listColumnFilterA.size());</b>
<b class="fc"><i class="no-highlight">4135</i>&nbsp;            for (int i = 0, n = listColumnFilterA.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">4136</i>&nbsp;                partitionByColumnIndexes.add(listColumnFilterA.getColumnIndexFactored(i));</b>
<i class="no-highlight">4137</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4138</i>&nbsp;            return new LatestByAllSymbolsFilteredRecordCursorFactory(</b>
<i class="no-highlight">4139</i>&nbsp;                    myMeta,
<i class="no-highlight">4140</i>&nbsp;                    configuration,
<b class="fc"><i class="no-highlight">4141</i>&nbsp;                    new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</b>
<b class="fc"><i class="no-highlight">4142</i>&nbsp;                    RecordSinkFactory.getInstance(asm, myMeta, listColumnFilterA, false),</b>
<i class="no-highlight">4143</i>&nbsp;                    keyTypes,
<i class="no-highlight">4144</i>&nbsp;                    partitionByColumnIndexes,
<i class="no-highlight">4145</i>&nbsp;                    null,
<i class="no-highlight">4146</i>&nbsp;                    null,
<i class="no-highlight">4147</i>&nbsp;                    columnIndexes
<i class="no-highlight">4148</i>&nbsp;            );
<i class="no-highlight">4149</i>&nbsp;        }
<i class="no-highlight">4150</i>&nbsp;
<b class="fc"><i class="no-highlight">4151</i>&nbsp;        return new LatestByAllFilteredRecordCursorFactory(</b>
<i class="no-highlight">4152</i>&nbsp;                myMeta,
<i class="no-highlight">4153</i>&nbsp;                configuration,
<b class="fc"><i class="no-highlight">4154</i>&nbsp;                new FullBwdDataFrameCursorFactory(tableToken, model.getTableId(), model.getTableVersion(), dfcFactoryMeta),</b>
<b class="fc"><i class="no-highlight">4155</i>&nbsp;                RecordSinkFactory.getInstance(asm, myMeta, listColumnFilterA, false),</b>
<i class="no-highlight">4156</i>&nbsp;                keyTypes,
<i class="no-highlight">4157</i>&nbsp;                null,
<i class="no-highlight">4158</i>&nbsp;                columnIndexes
<i class="no-highlight">4159</i>&nbsp;        );
<i class="no-highlight">4160</i>&nbsp;    }
<i class="no-highlight">4161</i>&nbsp;
<i class="no-highlight">4162</i>&nbsp;    private RecordCursorFactory generateUnionAllFactory(
<i class="no-highlight">4163</i>&nbsp;            QueryModel model,
<i class="no-highlight">4164</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">4165</i>&nbsp;            RecordCursorFactory factoryA,
<i class="no-highlight">4166</i>&nbsp;            RecordCursorFactory factoryB,
<i class="no-highlight">4167</i>&nbsp;            ObjList&lt;Function&gt; castFunctionsA,
<i class="no-highlight">4168</i>&nbsp;            ObjList&lt;Function&gt; castFunctionsB,
<i class="no-highlight">4169</i>&nbsp;            RecordMetadata setMetadata
<i class="no-highlight">4170</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">4171</i>&nbsp;        final RecordCursorFactory setFactory = new UnionAllRecordCursorFactory(</b>
<i class="no-highlight">4172</i>&nbsp;                setMetadata,
<i class="no-highlight">4173</i>&nbsp;                factoryA,
<i class="no-highlight">4174</i>&nbsp;                factoryB,
<i class="no-highlight">4175</i>&nbsp;                castFunctionsA,
<i class="no-highlight">4176</i>&nbsp;                castFunctionsB
<i class="no-highlight">4177</i>&nbsp;        );
<i class="no-highlight">4178</i>&nbsp;
<b class="fc"><i class="no-highlight">4179</i>&nbsp;        if (model.getUnionModel().getUnionModel() != null) {</b>
<b class="fc"><i class="no-highlight">4180</i>&nbsp;            return generateSetFactory(model.getUnionModel(), setFactory, executionContext);</b>
<i class="no-highlight">4181</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4182</i>&nbsp;        return setFactory;</b>
<i class="no-highlight">4183</i>&nbsp;    }
<i class="no-highlight">4184</i>&nbsp;
<i class="no-highlight">4185</i>&nbsp;    private RecordCursorFactory generateUnionFactory(
<i class="no-highlight">4186</i>&nbsp;            QueryModel model,
<i class="no-highlight">4187</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">4188</i>&nbsp;            RecordCursorFactory factoryA,
<i class="no-highlight">4189</i>&nbsp;            RecordCursorFactory factoryB,
<i class="no-highlight">4190</i>&nbsp;            ObjList&lt;Function&gt; castFunctionsA,
<i class="no-highlight">4191</i>&nbsp;            ObjList&lt;Function&gt; castFunctionsB,
<i class="no-highlight">4192</i>&nbsp;            RecordMetadata setMetadata,
<i class="no-highlight">4193</i>&nbsp;            SetRecordCursorFactoryConstructor constructor
<i class="no-highlight">4194</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">4195</i>&nbsp;        entityColumnFilter.of(factoryA.getMetadata().getColumnCount());</b>
<b class="fc"><i class="no-highlight">4196</i>&nbsp;        final RecordSink recordSink = RecordSinkFactory.getInstance(</b>
<i class="no-highlight">4197</i>&nbsp;                asm,
<i class="no-highlight">4198</i>&nbsp;                setMetadata,
<i class="no-highlight">4199</i>&nbsp;                entityColumnFilter,
<i class="no-highlight">4200</i>&nbsp;                true
<i class="no-highlight">4201</i>&nbsp;        );
<b class="fc"><i class="no-highlight">4202</i>&nbsp;        valueTypes.clear();</b>
<i class="no-highlight">4203</i>&nbsp;        // Remap symbol columns to string type since that&#39;s how recordSink copies them.
<b class="fc"><i class="no-highlight">4204</i>&nbsp;        keyTypes.clear();</b>
<b class="fc"><i class="no-highlight">4205</i>&nbsp;        for (int i = 0, n = setMetadata.getColumnCount(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">4206</i>&nbsp;            final int columnType = setMetadata.getColumnType(i);</b>
<b class="fc"><i class="no-highlight">4207</i>&nbsp;            if (ColumnType.isSymbol(columnType)) {</b>
<b class="fc"><i class="no-highlight">4208</i>&nbsp;                keyTypes.add(ColumnType.STRING);</b>
<i class="no-highlight">4209</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4210</i>&nbsp;                keyTypes.add(columnType);</b>
<i class="no-highlight">4211</i>&nbsp;            }
<i class="no-highlight">4212</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4213</i>&nbsp;        RecordCursorFactory unionFactory = constructor.create(</b>
<i class="no-highlight">4214</i>&nbsp;                configuration,
<i class="no-highlight">4215</i>&nbsp;                setMetadata,
<i class="no-highlight">4216</i>&nbsp;                factoryA,
<i class="no-highlight">4217</i>&nbsp;                factoryB,
<i class="no-highlight">4218</i>&nbsp;                castFunctionsA,
<i class="no-highlight">4219</i>&nbsp;                castFunctionsB,
<i class="no-highlight">4220</i>&nbsp;                recordSink,
<i class="no-highlight">4221</i>&nbsp;                keyTypes,
<i class="no-highlight">4222</i>&nbsp;                valueTypes
<i class="no-highlight">4223</i>&nbsp;        );
<i class="no-highlight">4224</i>&nbsp;
<b class="fc"><i class="no-highlight">4225</i>&nbsp;        if (model.getUnionModel().getUnionModel() != null) {</b>
<b class="fc"><i class="no-highlight">4226</i>&nbsp;            return generateSetFactory(model.getUnionModel(), unionFactory, executionContext);</b>
<i class="no-highlight">4227</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4228</i>&nbsp;        return unionFactory;</b>
<i class="no-highlight">4229</i>&nbsp;    }
<i class="no-highlight">4230</i>&nbsp;
<i class="no-highlight">4231</i>&nbsp;    @Nullable
<i class="no-highlight">4232</i>&nbsp;    private Function getHiFunction(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">4233</i>&nbsp;        return toLimitFunction(executionContext, model.getLimitHi(), null);</b>
<i class="no-highlight">4234</i>&nbsp;    }
<i class="no-highlight">4235</i>&nbsp;
<i class="no-highlight">4236</i>&nbsp;    @Nullable
<i class="no-highlight">4237</i>&nbsp;    private Function getLimitLoFunctionOnly(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">4238</i>&nbsp;        if (model.getLimitAdviceLo() != null &amp;&amp; model.getLimitAdviceHi() == null) {</b>
<b class="fc"><i class="no-highlight">4239</i>&nbsp;            return toLimitFunction(executionContext, model.getLimitAdviceLo(), LongConstant.ZERO);</b>
<i class="no-highlight">4240</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4241</i>&nbsp;        return null;</b>
<i class="no-highlight">4242</i>&nbsp;    }
<i class="no-highlight">4243</i>&nbsp;
<i class="no-highlight">4244</i>&nbsp;    @NotNull
<i class="no-highlight">4245</i>&nbsp;    private Function getLoFunction(QueryModel model, SqlExecutionContext executionContext) throws SqlException {
<b class="fc"><i class="no-highlight">4246</i>&nbsp;        return toLimitFunction(executionContext, model.getLimitLo(), LongConstant.ZERO);</b>
<i class="no-highlight">4247</i>&nbsp;    }
<i class="no-highlight">4248</i>&nbsp;
<i class="no-highlight">4249</i>&nbsp;    private int getTimestampIndex(QueryModel model, RecordCursorFactory factory) throws SqlException {
<b class="fc"><i class="no-highlight">4250</i>&nbsp;        return getTimestampIndex(model, factory.getMetadata());</b>
<i class="no-highlight">4251</i>&nbsp;    }
<i class="no-highlight">4252</i>&nbsp;
<i class="no-highlight">4253</i>&nbsp;    private int getTimestampIndex(QueryModel model, RecordMetadata metadata) throws SqlException {
<b class="fc"><i class="no-highlight">4254</i>&nbsp;        final ExpressionNode timestamp = model.getTimestamp();</b>
<b class="fc"><i class="no-highlight">4255</i>&nbsp;        if (timestamp != null) {</b>
<b class="fc"><i class="no-highlight">4256</i>&nbsp;            int timestampIndex = metadata.getColumnIndexQuiet(timestamp.token);</b>
<b class="fc"><i class="no-highlight">4257</i>&nbsp;            if (timestampIndex == -1) {</b>
<b class="fc"><i class="no-highlight">4258</i>&nbsp;                throw SqlException.invalidColumn(timestamp.position, timestamp.token);</b>
<i class="no-highlight">4259</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4260</i>&nbsp;            if (!ColumnType.isTimestamp(metadata.getColumnType(timestampIndex))) {</b>
<b class="fc"><i class="no-highlight">4261</i>&nbsp;                throw SqlException.$(timestamp.position, &quot;not a TIMESTAMP&quot;);</b>
<i class="no-highlight">4262</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4263</i>&nbsp;            return timestampIndex;</b>
<i class="no-highlight">4264</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4265</i>&nbsp;        return metadata.getTimestampIndex();</b>
<i class="no-highlight">4266</i>&nbsp;    }
<i class="no-highlight">4267</i>&nbsp;
<i class="no-highlight">4268</i>&nbsp;    private boolean isOrderDescendingByDesignatedTimestampOnly(QueryModel model) {
<b class="fc"><i class="no-highlight">4269</i>&nbsp;        return model.getOrderByAdvice().size() == 1 &amp;&amp; model.getTimestamp() != null &amp;&amp;</b>
<b class="fc"><i class="no-highlight">4270</i>&nbsp;                Chars.equalsIgnoreCase(model.getOrderByAdvice().getQuick(0).token, model.getTimestamp().token) &amp;&amp;</b>
<b class="fc"><i class="no-highlight">4271</i>&nbsp;                getOrderByDirectionOrDefault(model, 0) == ORDER_DIRECTION_DESCENDING;</b>
<i class="no-highlight">4272</i>&nbsp;    }
<i class="no-highlight">4273</i>&nbsp;
<i class="no-highlight">4274</i>&nbsp;    private boolean isSingleColumnFunction(ExpressionNode ast, CharSequence name) {
<b class="fc"><i class="no-highlight">4275</i>&nbsp;        return ast.type == FUNCTION &amp;&amp; ast.paramCount == 1 &amp;&amp; Chars.equalsIgnoreCase(ast.token, name) &amp;&amp; ast.rhs.type == LITERAL;</b>
<i class="no-highlight">4276</i>&nbsp;    }
<i class="no-highlight">4277</i>&nbsp;
<i class="no-highlight">4278</i>&nbsp;    private void lookupColumnIndexes(
<i class="no-highlight">4279</i>&nbsp;            ListColumnFilter filter,
<i class="no-highlight">4280</i>&nbsp;            ObjList&lt;ExpressionNode&gt; columnNames,
<i class="no-highlight">4281</i>&nbsp;            RecordMetadata metadata
<i class="no-highlight">4282</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">4283</i>&nbsp;        filter.clear();</b>
<b class="fc"><i class="no-highlight">4284</i>&nbsp;        for (int i = 0, n = columnNames.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">4285</i>&nbsp;            final CharSequence columnName = columnNames.getQuick(i).token;</b>
<b class="fc"><i class="no-highlight">4286</i>&nbsp;            int columnIndex = metadata.getColumnIndexQuiet(columnName);</b>
<b class="fc"><i class="no-highlight">4287</i>&nbsp;            if (columnIndex &gt; -1) {</b>
<b class="fc"><i class="no-highlight">4288</i>&nbsp;                filter.add(columnIndex + 1);</b>
<i class="no-highlight">4289</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4290</i>&nbsp;                int dot = Chars.indexOf(columnName, &#39;.&#39;);</b>
<b class="fc"><i class="no-highlight">4291</i>&nbsp;                if (dot &gt; -1) {</b>
<b class="fc"><i class="no-highlight">4292</i>&nbsp;                    columnIndex = metadata.getColumnIndexQuiet(columnName, dot + 1, columnName.length());</b>
<b class="fc"><i class="no-highlight">4293</i>&nbsp;                    if (columnIndex &gt; -1) {</b>
<b class="fc"><i class="no-highlight">4294</i>&nbsp;                        filter.add(columnIndex + 1);</b>
<i class="no-highlight">4295</i>&nbsp;                        return;
<i class="no-highlight">4296</i>&nbsp;                    }
<i class="no-highlight">4297</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4298</i>&nbsp;                throw SqlException.invalidColumn(columnNames.getQuick(i).position, columnName);</b>
<i class="no-highlight">4299</i>&nbsp;            }
<i class="no-highlight">4300</i>&nbsp;        }
<i class="no-highlight">4301</i>&nbsp;    }
<i class="no-highlight">4302</i>&nbsp;
<i class="no-highlight">4303</i>&nbsp;    private void lookupColumnIndexesUsingVanillaNames(
<i class="no-highlight">4304</i>&nbsp;            ListColumnFilter filter,
<i class="no-highlight">4305</i>&nbsp;            ObjList&lt;CharSequence&gt; columnNames,
<i class="no-highlight">4306</i>&nbsp;            RecordMetadata metadata
<i class="no-highlight">4307</i>&nbsp;    ) {
<b class="fc"><i class="no-highlight">4308</i>&nbsp;        filter.clear();</b>
<b class="fc"><i class="no-highlight">4309</i>&nbsp;        for (int i = 0, n = columnNames.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">4310</i>&nbsp;            filter.add(metadata.getColumnIndex(columnNames.getQuick(i)) + 1);</b>
<i class="no-highlight">4311</i>&nbsp;        }
<i class="no-highlight">4312</i>&nbsp;    }
<i class="no-highlight">4313</i>&nbsp;
<i class="no-highlight">4314</i>&nbsp;    private int prepareLatestByColumnIndexes(ObjList&lt;ExpressionNode&gt; latestBy, RecordMetadata myMeta) throws SqlException {
<b class="fc"><i class="no-highlight">4315</i>&nbsp;        keyTypes.clear();</b>
<b class="fc"><i class="no-highlight">4316</i>&nbsp;        listColumnFilterA.clear();</b>
<i class="no-highlight">4317</i>&nbsp;
<b class="fc"><i class="no-highlight">4318</i>&nbsp;        final int latestByColumnCount = latestBy.size();</b>
<b class="fc"><i class="no-highlight">4319</i>&nbsp;        if (latestByColumnCount &gt; 0) {</b>
<i class="no-highlight">4320</i>&nbsp;            // validate the latest by against the current reader
<i class="no-highlight">4321</i>&nbsp;            // first check if column is valid
<b class="fc"><i class="no-highlight">4322</i>&nbsp;            for (int i = 0; i &lt; latestByColumnCount; i++) {</b>
<b class="fc"><i class="no-highlight">4323</i>&nbsp;                final ExpressionNode latestByNode = latestBy.getQuick(i);</b>
<b class="fc"><i class="no-highlight">4324</i>&nbsp;                final int index = myMeta.getColumnIndexQuiet(latestByNode.token);</b>
<b class="fc"><i class="no-highlight">4325</i>&nbsp;                if (index == -1) {</b>
<b class="fc"><i class="no-highlight">4326</i>&nbsp;                    throw SqlException.invalidColumn(latestByNode.position, latestByNode.token);</b>
<i class="no-highlight">4327</i>&nbsp;                }
<i class="no-highlight">4328</i>&nbsp;
<i class="no-highlight">4329</i>&nbsp;                // check the type of the column, not all are supported
<b class="fc"><i class="no-highlight">4330</i>&nbsp;                int columnType = myMeta.getColumnType(index);</b>
<b class="fc"><i class="no-highlight">4331</i>&nbsp;                switch (ColumnType.tagOf(columnType)) {</b>
<i class="no-highlight">4332</i>&nbsp;                    case ColumnType.BOOLEAN:
<i class="no-highlight">4333</i>&nbsp;                    case ColumnType.CHAR:
<i class="no-highlight">4334</i>&nbsp;                    case ColumnType.SHORT:
<i class="no-highlight">4335</i>&nbsp;                    case ColumnType.INT:
<i class="no-highlight">4336</i>&nbsp;                    case ColumnType.LONG:
<i class="no-highlight">4337</i>&nbsp;                    case ColumnType.LONG256:
<i class="no-highlight">4338</i>&nbsp;                    case ColumnType.STRING:
<i class="no-highlight">4339</i>&nbsp;                    case ColumnType.SYMBOL:
<i class="no-highlight">4340</i>&nbsp;                    case ColumnType.UUID:
<i class="no-highlight">4341</i>&nbsp;                    case ColumnType.LONG128:
<i class="no-highlight">4342</i>&nbsp;                        // we are reusing collections which leads to confusing naming for this method
<i class="no-highlight">4343</i>&nbsp;                        // keyTypes are types of columns we collect &#39;latest by&#39; for
<b class="fc"><i class="no-highlight">4344</i>&nbsp;                        keyTypes.add(columnType);</b>
<i class="no-highlight">4345</i>&nbsp;                        // listColumnFilterA are indexes of columns we collect &#39;latest by&#39; for
<b class="fc"><i class="no-highlight">4346</i>&nbsp;                        listColumnFilterA.add(index + 1);</b>
<b class="fc"><i class="no-highlight">4347</i>&nbsp;                        break;</b>
<i class="no-highlight">4348</i>&nbsp;
<i class="no-highlight">4349</i>&nbsp;                    default:
<b class="fc"><i class="no-highlight">4350</i>&nbsp;                        throw SqlException</b>
<b class="fc"><i class="no-highlight">4351</i>&nbsp;                                .position(latestByNode.position)</b>
<b class="fc"><i class="no-highlight">4352</i>&nbsp;                                .put(latestByNode.token)</b>
<b class="fc"><i class="no-highlight">4353</i>&nbsp;                                .put(&quot; (&quot;)</b>
<b class="fc"><i class="no-highlight">4354</i>&nbsp;                                .put(ColumnType.nameOf(columnType))</b>
<b class="fc"><i class="no-highlight">4355</i>&nbsp;                                .put(&quot;): invalid type, only [BOOLEAN, SHORT, INT, LONG, LONG128, LONG256, CHAR, STRING, SYMBOL, UUID] are supported in LATEST BY&quot;);</b>
<i class="no-highlight">4356</i>&nbsp;                }
<i class="no-highlight">4357</i>&nbsp;            }
<i class="no-highlight">4358</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4359</i>&nbsp;        return latestByColumnCount;</b>
<i class="no-highlight">4360</i>&nbsp;    }
<i class="no-highlight">4361</i>&nbsp;
<i class="no-highlight">4362</i>&nbsp;    private void processJoinContext(
<i class="no-highlight">4363</i>&nbsp;            boolean vanillaMaster,
<i class="no-highlight">4364</i>&nbsp;            JoinContext jc,
<i class="no-highlight">4365</i>&nbsp;            RecordMetadata masterMetadata,
<i class="no-highlight">4366</i>&nbsp;            RecordMetadata slaveMetadata
<i class="no-highlight">4367</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">4368</i>&nbsp;        lookupColumnIndexesUsingVanillaNames(listColumnFilterA, jc.aNames, slaveMetadata);</b>
<b class="fc"><i class="no-highlight">4369</i>&nbsp;        if (vanillaMaster) {</b>
<b class="fc"><i class="no-highlight">4370</i>&nbsp;            lookupColumnIndexesUsingVanillaNames(listColumnFilterB, jc.bNames, masterMetadata);</b>
<i class="no-highlight">4371</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">4372</i>&nbsp;            lookupColumnIndexes(listColumnFilterB, jc.bNodes, masterMetadata);</b>
<i class="no-highlight">4373</i>&nbsp;        }
<i class="no-highlight">4374</i>&nbsp;
<i class="no-highlight">4375</i>&nbsp;        // compare types and populate keyTypes
<b class="fc"><i class="no-highlight">4376</i>&nbsp;        keyTypes.clear();</b>
<b class="fc"><i class="no-highlight">4377</i>&nbsp;        for (int k = 0, m = listColumnFilterA.getColumnCount(); k &lt; m; k++) {</b>
<i class="no-highlight">4378</i>&nbsp;            // Don&#39;t use tagOf(columnType) to compare the types.
<i class="no-highlight">4379</i>&nbsp;            // Key types have too much exactly except SYMBOL and STRING special case
<b class="fc"><i class="no-highlight">4380</i>&nbsp;            int columnTypeA = slaveMetadata.getColumnType(listColumnFilterA.getColumnIndexFactored(k));</b>
<b class="fc"><i class="no-highlight">4381</i>&nbsp;            int columnTypeB = masterMetadata.getColumnType(listColumnFilterB.getColumnIndexFactored(k));</b>
<b class="fc"><i class="no-highlight">4382</i>&nbsp;            if (columnTypeB != columnTypeA &amp;&amp; !(ColumnType.isSymbolOrString(columnTypeB) &amp;&amp; ColumnType.isSymbolOrString(columnTypeA))) {</b>
<i class="no-highlight">4383</i>&nbsp;                // index in column filter and join context is the same
<b class="fc"><i class="no-highlight">4384</i>&nbsp;                throw SqlException.$(jc.aNodes.getQuick(k).position, &quot;join column type mismatch&quot;);</b>
<i class="no-highlight">4385</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4386</i>&nbsp;            keyTypes.add(columnTypeB == ColumnType.SYMBOL ? ColumnType.STRING : columnTypeB);</b>
<i class="no-highlight">4387</i>&nbsp;        }
<i class="no-highlight">4388</i>&nbsp;    }
<i class="no-highlight">4389</i>&nbsp;
<i class="no-highlight">4390</i>&nbsp;    private void processNodeQueryModels(ExpressionNode node, ModelOperator operator) {
<b class="fc"><i class="no-highlight">4391</i>&nbsp;        sqlNodeStack.clear();</b>
<b class="fc"><i class="no-highlight">4392</i>&nbsp;        while (node != null) {</b>
<b class="fc"><i class="no-highlight">4393</i>&nbsp;            if (node.queryModel != null) {</b>
<b class="fc"><i class="no-highlight">4394</i>&nbsp;                operator.operate(expressionNodePool, node.queryModel);</b>
<i class="no-highlight">4395</i>&nbsp;            }
<i class="no-highlight">4396</i>&nbsp;
<b class="fc"><i class="no-highlight">4397</i>&nbsp;            if (node.lhs != null) {</b>
<b class="fc"><i class="no-highlight">4398</i>&nbsp;                sqlNodeStack.push(node.lhs);</b>
<i class="no-highlight">4399</i>&nbsp;            }
<i class="no-highlight">4400</i>&nbsp;
<b class="fc"><i class="no-highlight">4401</i>&nbsp;            if (node.rhs != null) {</b>
<b class="fc"><i class="no-highlight">4402</i>&nbsp;                node = node.rhs;</b>
<i class="no-highlight">4403</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4404</i>&nbsp;                if (!sqlNodeStack.isEmpty()) {</b>
<b class="fc"><i class="no-highlight">4405</i>&nbsp;                    node = this.sqlNodeStack.poll();</b>
<i class="no-highlight">4406</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">4407</i>&nbsp;                    node = null;</b>
<i class="no-highlight">4408</i>&nbsp;                }
<i class="no-highlight">4409</i>&nbsp;            }
<i class="no-highlight">4410</i>&nbsp;        }
<i class="no-highlight">4411</i>&nbsp;
<i class="no-highlight">4412</i>&nbsp;    }
<i class="no-highlight">4413</i>&nbsp;
<i class="no-highlight">4414</i>&nbsp;    private void restoreWhereClause(ExpressionNode node) {
<b class="fc"><i class="no-highlight">4415</i>&nbsp;        processNodeQueryModels(node, RESTORE_WHERE_CLAUSE);</b>
<i class="no-highlight">4416</i>&nbsp;    }
<i class="no-highlight">4417</i>&nbsp;
<i class="no-highlight">4418</i>&nbsp;    private Function toLimitFunction(
<i class="no-highlight">4419</i>&nbsp;            SqlExecutionContext executionContext,
<i class="no-highlight">4420</i>&nbsp;            ExpressionNode limit,
<i class="no-highlight">4421</i>&nbsp;            ConstantFunction defaultValue
<i class="no-highlight">4422</i>&nbsp;    ) throws SqlException {
<b class="fc"><i class="no-highlight">4423</i>&nbsp;        if (limit == null) {</b>
<b class="fc"><i class="no-highlight">4424</i>&nbsp;            return defaultValue;</b>
<i class="no-highlight">4425</i>&nbsp;        }
<i class="no-highlight">4426</i>&nbsp;
<b class="fc"><i class="no-highlight">4427</i>&nbsp;        final Function func = functionParser.parseFunction(limit, EmptyRecordMetadata.INSTANCE, executionContext);</b>
<b class="fc"><i class="no-highlight">4428</i>&nbsp;        final int type = func.getType();</b>
<b class="fc"><i class="no-highlight">4429</i>&nbsp;        if (limitTypes.excludes(type)) {</b>
<b class="fc"><i class="no-highlight">4430</i>&nbsp;            if (type == ColumnType.UNDEFINED) {</b>
<b class="fc"><i class="no-highlight">4431</i>&nbsp;                if (func instanceof IndexedParameterLinkFunction) {</b>
<b class="fc"><i class="no-highlight">4432</i>&nbsp;                    executionContext.getBindVariableService().setLong(((IndexedParameterLinkFunction) func).getVariableIndex(), defaultValue.getLong(null));</b>
<b class="fc"><i class="no-highlight">4433</i>&nbsp;                    return func;</b>
<i class="no-highlight">4434</i>&nbsp;                }
<i class="no-highlight">4435</i>&nbsp;
<b class="nc"><i class="no-highlight">4436</i>&nbsp;                if (func instanceof NamedParameterLinkFunction) {</b>
<b class="nc"><i class="no-highlight">4437</i>&nbsp;                    executionContext.getBindVariableService().setLong(((NamedParameterLinkFunction) func).getVariableName(), defaultValue.getLong(null));</b>
<b class="nc"><i class="no-highlight">4438</i>&nbsp;                    return func;</b>
<i class="no-highlight">4439</i>&nbsp;                }
<i class="no-highlight">4440</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4441</i>&nbsp;            throw SqlException.$(limit.position, &quot;invalid type: &quot;).put(ColumnType.nameOf(type));</b>
<i class="no-highlight">4442</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4443</i>&nbsp;        return func;</b>
<i class="no-highlight">4444</i>&nbsp;    }
<i class="no-highlight">4445</i>&nbsp;
<i class="no-highlight">4446</i>&nbsp;    private IntList toOrderIndices(RecordMetadata m, ObjList&lt;ExpressionNode&gt; orderBy, IntList orderByDirection) throws SqlException {
<b class="fc"><i class="no-highlight">4447</i>&nbsp;        final IntList indices = intListPool.next();</b>
<b class="fc"><i class="no-highlight">4448</i>&nbsp;        for (int i = 0, n = orderBy.size(); i &lt; n; i++) {</b>
<b class="fc"><i class="no-highlight">4449</i>&nbsp;            ExpressionNode tok = orderBy.getQuick(i);</b>
<b class="fc"><i class="no-highlight">4450</i>&nbsp;            int index = m.getColumnIndexQuiet(tok.token);</b>
<b class="fc"><i class="no-highlight">4451</i>&nbsp;            if (index == -1) {</b>
<b class="nc"><i class="no-highlight">4452</i>&nbsp;                throw SqlException.invalidColumn(tok.position, tok.token);</b>
<i class="no-highlight">4453</i>&nbsp;            }
<i class="no-highlight">4454</i>&nbsp;
<i class="no-highlight">4455</i>&nbsp;            // shift index by 1 to use sign as sort direction
<b class="fc"><i class="no-highlight">4456</i>&nbsp;            index++;</b>
<i class="no-highlight">4457</i>&nbsp;
<i class="no-highlight">4458</i>&nbsp;            // negative column index means descending order of sort
<b class="fc"><i class="no-highlight">4459</i>&nbsp;            if (orderByDirection.getQuick(i) == QueryModel.ORDER_DIRECTION_DESCENDING) {</b>
<b class="fc"><i class="no-highlight">4460</i>&nbsp;                index = -index;</b>
<i class="no-highlight">4461</i>&nbsp;            }
<i class="no-highlight">4462</i>&nbsp;
<b class="fc"><i class="no-highlight">4463</i>&nbsp;            indices.add(index);</b>
<i class="no-highlight">4464</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4465</i>&nbsp;        return indices;</b>
<i class="no-highlight">4466</i>&nbsp;    }
<i class="no-highlight">4467</i>&nbsp;
<i class="no-highlight">4468</i>&nbsp;    private void validateBothTimestampOrders(RecordCursorFactory masterFactory, RecordCursorFactory slaveFactory, int position) throws SqlException {
<b class="fc"><i class="no-highlight">4469</i>&nbsp;        if (masterFactory.hasDescendingOrder()) {</b>
<b class="fc"><i class="no-highlight">4470</i>&nbsp;            throw SqlException.$(position, &quot;left side of time series join has DESC timestamp order&quot;);</b>
<i class="no-highlight">4471</i>&nbsp;        }
<i class="no-highlight">4472</i>&nbsp;
<b class="fc"><i class="no-highlight">4473</i>&nbsp;        if (slaveFactory.hasDescendingOrder()) {</b>
<b class="fc"><i class="no-highlight">4474</i>&nbsp;            throw SqlException.$(position, &quot;right side of time series join has DESC timestamp order&quot;);</b>
<i class="no-highlight">4475</i>&nbsp;        }
<i class="no-highlight">4476</i>&nbsp;    }
<i class="no-highlight">4477</i>&nbsp;
<i class="no-highlight">4478</i>&nbsp;    private void validateBothTimestamps(QueryModel slaveModel, RecordMetadata masterMetadata, RecordMetadata slaveMetadata) throws SqlException {
<b class="fc"><i class="no-highlight">4479</i>&nbsp;        if (masterMetadata.getTimestampIndex() == -1) {</b>
<b class="fc"><i class="no-highlight">4480</i>&nbsp;            throw SqlException.$(slaveModel.getJoinKeywordPosition(), &quot;left side of time series join has no timestamp&quot;);</b>
<i class="no-highlight">4481</i>&nbsp;        }
<i class="no-highlight">4482</i>&nbsp;
<b class="fc"><i class="no-highlight">4483</i>&nbsp;        if (slaveMetadata.getTimestampIndex() == -1) {</b>
<b class="fc"><i class="no-highlight">4484</i>&nbsp;            throw SqlException.$(slaveModel.getJoinKeywordPosition(), &quot;right side of time series join has no timestamp&quot;);</b>
<i class="no-highlight">4485</i>&nbsp;        }
<i class="no-highlight">4486</i>&nbsp;    }
<i class="no-highlight">4487</i>&nbsp;
<i class="no-highlight">4488</i>&nbsp;    private void validateOuterJoinExpressions(QueryModel model, CharSequence joinType) throws SqlException {
<b class="fc"><i class="no-highlight">4489</i>&nbsp;        if (model.getOuterJoinExpressionClause() != null) {</b>
<b class="fc"><i class="no-highlight">4490</i>&nbsp;            throw SqlException.$(model.getOuterJoinExpressionClause().position, &quot;unsupported &quot;).put(joinType).put(&quot; join expression &quot;)</b>
<b class="fc"><i class="no-highlight">4491</i>&nbsp;                    .put(&quot;[expr=&#39;&quot;).put(model.getOuterJoinExpressionClause()).put(&quot;&#39;]&quot;);</b>
<i class="no-highlight">4492</i>&nbsp;        }
<i class="no-highlight">4493</i>&nbsp;    }
<i class="no-highlight">4494</i>&nbsp;
<i class="no-highlight">4495</i>&nbsp;    private Record.CharSequenceFunction validateSubQueryColumnAndGetGetter(IntrinsicModel intrinsicModel, RecordMetadata metadata) throws SqlException {
<b class="fc"><i class="no-highlight">4496</i>&nbsp;        int columnType = metadata.getColumnType(0);</b>
<b class="fc"><i class="no-highlight">4497</i>&nbsp;        if (!ColumnType.isSymbolOrString(columnType)) {</b>
<b class="fc"><i class="no-highlight">4498</i>&nbsp;            assert intrinsicModel.keySubQuery.getColumns() != null;</b>
<b class="fc"><i class="no-highlight">4499</i>&nbsp;            assert intrinsicModel.keySubQuery.getColumns().size() &gt; 0;</b>
<i class="no-highlight">4500</i>&nbsp;
<b class="fc"><i class="no-highlight">4501</i>&nbsp;            throw SqlException</b>
<b class="fc"><i class="no-highlight">4502</i>&nbsp;                    .position(intrinsicModel.keySubQuery.getColumns().getQuick(0).getAst().position)</b>
<b class="fc"><i class="no-highlight">4503</i>&nbsp;                    .put(&quot;unsupported column type: &quot;)</b>
<b class="fc"><i class="no-highlight">4504</i>&nbsp;                    .put(metadata.getColumnName(0))</b>
<b class="fc"><i class="no-highlight">4505</i>&nbsp;                    .put(&quot;: &quot;)</b>
<b class="fc"><i class="no-highlight">4506</i>&nbsp;                    .put(ColumnType.nameOf(columnType));</b>
<i class="no-highlight">4507</i>&nbsp;        }
<i class="no-highlight">4508</i>&nbsp;
<b class="fc"><i class="no-highlight">4509</i>&nbsp;        return ColumnType.isString(columnType) ? Record.GET_STR : Record.GET_SYM;</b>
<i class="no-highlight">4510</i>&nbsp;    }
<i class="no-highlight">4511</i>&nbsp;
<i class="no-highlight">4512</i>&nbsp;    private RecordMetadata widenSetMetadata(RecordMetadata typesA, RecordMetadata typesB) {
<b class="fc"><i class="no-highlight">4513</i>&nbsp;        int columnCount = typesA.getColumnCount();</b>
<b class="fc"><i class="no-highlight">4514</i>&nbsp;        assert columnCount == typesB.getColumnCount();</b>
<i class="no-highlight">4515</i>&nbsp;
<b class="fc"><i class="no-highlight">4516</i>&nbsp;        GenericRecordMetadata metadata = new GenericRecordMetadata();</b>
<b class="fc"><i class="no-highlight">4517</i>&nbsp;        for (int i = 0; i &lt; columnCount; i++) {</b>
<b class="fc"><i class="no-highlight">4518</i>&nbsp;            int typeA = typesA.getColumnType(i);</b>
<b class="fc"><i class="no-highlight">4519</i>&nbsp;            int typeB = typesB.getColumnType(i);</b>
<i class="no-highlight">4520</i>&nbsp;
<b class="fc"><i class="no-highlight">4521</i>&nbsp;            if (typeA == typeB &amp;&amp; typeA != ColumnType.SYMBOL) {</b>
<b class="fc"><i class="no-highlight">4522</i>&nbsp;                metadata.add(AbstractRecordMetadata.copyOf(typesA, i));</b>
<b class="fc"><i class="no-highlight">4523</i>&nbsp;            } else if (ColumnType.isToSameOrWider(typeB, typeA) &amp;&amp; typeA != ColumnType.SYMBOL &amp;&amp; typeA != ColumnType.CHAR) {</b>
<i class="no-highlight">4524</i>&nbsp;                // CHAR is &quot;specially&quot; assignable from SHORT, but we don&#39;t want that
<b class="fc"><i class="no-highlight">4525</i>&nbsp;                metadata.add(AbstractRecordMetadata.copyOf(typesA, i));</b>
<b class="fc"><i class="no-highlight">4526</i>&nbsp;            } else if (ColumnType.isToSameOrWider(typeA, typeB) &amp;&amp; typeB != ColumnType.SYMBOL) {</b>
<i class="no-highlight">4527</i>&nbsp;                // even though A is assignable to B (e.g. A union B)
<i class="no-highlight">4528</i>&nbsp;                // set metadata will use A column names
<b class="fc"><i class="no-highlight">4529</i>&nbsp;                metadata.add(new TableColumnMetadata(</b>
<b class="fc"><i class="no-highlight">4530</i>&nbsp;                        typesA.getColumnName(i),</b>
<i class="no-highlight">4531</i>&nbsp;                        typeB
<i class="no-highlight">4532</i>&nbsp;                ));
<i class="no-highlight">4533</i>&nbsp;            } else {
<i class="no-highlight">4534</i>&nbsp;                // we can cast anything to string
<b class="fc"><i class="no-highlight">4535</i>&nbsp;                metadata.add(new TableColumnMetadata(</b>
<b class="fc"><i class="no-highlight">4536</i>&nbsp;                        typesA.getColumnName(i),</b>
<i class="no-highlight">4537</i>&nbsp;                        ColumnType.STRING
<i class="no-highlight">4538</i>&nbsp;                ));
<i class="no-highlight">4539</i>&nbsp;            }
<i class="no-highlight">4540</i>&nbsp;        }
<i class="no-highlight">4541</i>&nbsp;
<b class="fc"><i class="no-highlight">4542</i>&nbsp;        return metadata;</b>
<i class="no-highlight">4543</i>&nbsp;    }
<i class="no-highlight">4544</i>&nbsp;
<i class="no-highlight">4545</i>&nbsp;    // used in tests
<i class="no-highlight">4546</i>&nbsp;    void setEnableJitNullChecks(boolean value) {
<b class="nc"><i class="no-highlight">4547</i>&nbsp;        enableJitNullChecks = value;</b>
<i class="no-highlight">4548</i>&nbsp;    }
<i class="no-highlight">4549</i>&nbsp;
<i class="no-highlight">4550</i>&nbsp;    void setFullFatJoins(boolean fullFatJoins) {
<b class="fc"><i class="no-highlight">4551</i>&nbsp;        this.fullFatJoins = fullFatJoins;</b>
<i class="no-highlight">4552</i>&nbsp;    }
<i class="no-highlight">4553</i>&nbsp;
<i class="no-highlight">4554</i>&nbsp;    @FunctionalInterface
<i class="no-highlight">4555</i>&nbsp;    public interface FullFatJoinGenerator {
<i class="no-highlight">4556</i>&nbsp;        RecordCursorFactory create(
<i class="no-highlight">4557</i>&nbsp;                CairoConfiguration configuration,
<i class="no-highlight">4558</i>&nbsp;                RecordMetadata metadata,
<i class="no-highlight">4559</i>&nbsp;                RecordCursorFactory masterFactory,
<i class="no-highlight">4560</i>&nbsp;                RecordCursorFactory slaveFactory,
<i class="no-highlight">4561</i>&nbsp;                @Transient ColumnTypes mapKeyTypes,
<i class="no-highlight">4562</i>&nbsp;                @Transient ColumnTypes mapValueTypes,
<i class="no-highlight">4563</i>&nbsp;                @Transient ColumnTypes slaveColumnTypes,
<i class="no-highlight">4564</i>&nbsp;                RecordSink masterKeySink,
<i class="no-highlight">4565</i>&nbsp;                RecordSink slaveKeySink,
<i class="no-highlight">4566</i>&nbsp;                int columnSplit,
<i class="no-highlight">4567</i>&nbsp;                RecordValueSink slaveValueSink,
<i class="no-highlight">4568</i>&nbsp;                IntList columnIndex,
<i class="no-highlight">4569</i>&nbsp;                JoinContext joinContext
<i class="no-highlight">4570</i>&nbsp;        );
<i class="no-highlight">4571</i>&nbsp;    }
<i class="no-highlight">4572</i>&nbsp;
<i class="no-highlight">4573</i>&nbsp;    @FunctionalInterface
<i class="no-highlight">4574</i>&nbsp;    interface ModelOperator {
<i class="no-highlight">4575</i>&nbsp;        void operate(ObjectPool&lt;ExpressionNode&gt; pool, QueryModel model);
<i class="no-highlight">4576</i>&nbsp;    }
<i class="no-highlight">4577</i>&nbsp;
<i class="no-highlight">4578</i>&nbsp;    private static class RecordCursorFactoryStub implements RecordCursorFactory {
<i class="no-highlight">4579</i>&nbsp;        final ExecutionModel model;
<i class="no-highlight">4580</i>&nbsp;        RecordCursorFactory factory;
<i class="no-highlight">4581</i>&nbsp;
<b class="fc"><i class="no-highlight">4582</i>&nbsp;        protected RecordCursorFactoryStub(ExecutionModel model, RecordCursorFactory factory) {</b>
<b class="fc"><i class="no-highlight">4583</i>&nbsp;            this.model = model;</b>
<b class="fc"><i class="no-highlight">4584</i>&nbsp;            this.factory = factory;</b>
<i class="no-highlight">4585</i>&nbsp;        }
<i class="no-highlight">4586</i>&nbsp;
<i class="no-highlight">4587</i>&nbsp;        @Override
<i class="no-highlight">4588</i>&nbsp;        public void close() {
<b class="fc"><i class="no-highlight">4589</i>&nbsp;            factory = Misc.free(factory);</b>
<i class="no-highlight">4590</i>&nbsp;        }
<i class="no-highlight">4591</i>&nbsp;
<i class="no-highlight">4592</i>&nbsp;        @Override
<i class="no-highlight">4593</i>&nbsp;        public RecordCursor getCursor(SqlExecutionContext executionContext) throws SqlException {
<b class="nc"><i class="no-highlight">4594</i>&nbsp;            if (factory != null) {</b>
<b class="nc"><i class="no-highlight">4595</i>&nbsp;                return factory.getCursor(executionContext);</b>
<i class="no-highlight">4596</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">4597</i>&nbsp;                return null;</b>
<i class="no-highlight">4598</i>&nbsp;            }
<i class="no-highlight">4599</i>&nbsp;        }
<i class="no-highlight">4600</i>&nbsp;
<i class="no-highlight">4601</i>&nbsp;        @Override
<i class="no-highlight">4602</i>&nbsp;        public RecordMetadata getMetadata() {
<b class="nc"><i class="no-highlight">4603</i>&nbsp;            return null;</b>
<i class="no-highlight">4604</i>&nbsp;        }
<i class="no-highlight">4605</i>&nbsp;
<i class="no-highlight">4606</i>&nbsp;        @Override
<i class="no-highlight">4607</i>&nbsp;        public boolean recordCursorSupportsRandomAccess() {
<b class="nc"><i class="no-highlight">4608</i>&nbsp;            return false;</b>
<i class="no-highlight">4609</i>&nbsp;        }
<i class="no-highlight">4610</i>&nbsp;
<i class="no-highlight">4611</i>&nbsp;        @Override
<i class="no-highlight">4612</i>&nbsp;        public void toPlan(PlanSink sink) {
<b class="fc"><i class="no-highlight">4613</i>&nbsp;            sink.type(model.getTypeName());</b>
<i class="no-highlight">4614</i>&nbsp;
<b class="fc"><i class="no-highlight">4615</i>&nbsp;            CharSequence tableName = model.getTableName();</b>
<b class="fc"><i class="no-highlight">4616</i>&nbsp;            if (tableName != null) {</b>
<b class="fc"><i class="no-highlight">4617</i>&nbsp;                sink.meta(&quot;table&quot;).val(tableName);</b>
<i class="no-highlight">4618</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4619</i>&nbsp;            if (factory != null) {</b>
<b class="fc"><i class="no-highlight">4620</i>&nbsp;                sink.child(factory);</b>
<i class="no-highlight">4621</i>&nbsp;            }
<i class="no-highlight">4622</i>&nbsp;        }
<i class="no-highlight">4623</i>&nbsp;    }
<i class="no-highlight">4624</i>&nbsp;
<i class="no-highlight">4625</i>&nbsp;    static {
<b class="fc"><i class="no-highlight">4626</i>&nbsp;        joinsRequiringTimestamp[JOIN_INNER] = false;</b>
<b class="fc"><i class="no-highlight">4627</i>&nbsp;        joinsRequiringTimestamp[JOIN_OUTER] = false;</b>
<b class="fc"><i class="no-highlight">4628</i>&nbsp;        joinsRequiringTimestamp[JOIN_CROSS] = false;</b>
<b class="fc"><i class="no-highlight">4629</i>&nbsp;        joinsRequiringTimestamp[JOIN_ASOF] = true;</b>
<b class="fc"><i class="no-highlight">4630</i>&nbsp;        joinsRequiringTimestamp[JOIN_SPLICE] = true;</b>
<b class="fc"><i class="no-highlight">4631</i>&nbsp;        joinsRequiringTimestamp[JOIN_LT] = true;</b>
<b class="fc"><i class="no-highlight">4632</i>&nbsp;        joinsRequiringTimestamp[JOIN_ONE] = false;</b>
<i class="no-highlight">4633</i>&nbsp;    }
<i class="no-highlight">4634</i>&nbsp;
<i class="no-highlight">4635</i>&nbsp;    static {
<b class="fc"><i class="no-highlight">4636</i>&nbsp;        limitTypes.add(ColumnType.LONG);</b>
<b class="fc"><i class="no-highlight">4637</i>&nbsp;        limitTypes.add(ColumnType.BYTE);</b>
<b class="fc"><i class="no-highlight">4638</i>&nbsp;        limitTypes.add(ColumnType.SHORT);</b>
<b class="fc"><i class="no-highlight">4639</i>&nbsp;        limitTypes.add(ColumnType.INT);</b>
<i class="no-highlight">4640</i>&nbsp;    }
<i class="no-highlight">4641</i>&nbsp;
<i class="no-highlight">4642</i>&nbsp;    static {
<b class="fc"><i class="no-highlight">4643</i>&nbsp;        limitTypes.add(ColumnType.LONG);</b>
<b class="fc"><i class="no-highlight">4644</i>&nbsp;        limitTypes.add(ColumnType.BYTE);</b>
<b class="fc"><i class="no-highlight">4645</i>&nbsp;        limitTypes.add(ColumnType.SHORT);</b>
<b class="fc"><i class="no-highlight">4646</i>&nbsp;        limitTypes.add(ColumnType.INT);</b>
<i class="no-highlight">4647</i>&nbsp;    }
<i class="no-highlight">4648</i>&nbsp;
<i class="no-highlight">4649</i>&nbsp;    static {
<b class="fc"><i class="no-highlight">4650</i>&nbsp;        countConstructors.put(ColumnType.DOUBLE, CountDoubleVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4651</i>&nbsp;        countConstructors.put(ColumnType.INT, CountIntVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4652</i>&nbsp;        countConstructors.put(ColumnType.LONG, CountLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4653</i>&nbsp;        countConstructors.put(ColumnType.DATE, CountLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4654</i>&nbsp;        countConstructors.put(ColumnType.TIMESTAMP, CountLongVectorAggregateFunction::new);</b>
<i class="no-highlight">4655</i>&nbsp;
<b class="fc"><i class="no-highlight">4656</i>&nbsp;        sumConstructors.put(ColumnType.DOUBLE, SumDoubleVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4657</i>&nbsp;        sumConstructors.put(ColumnType.INT, SumIntVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4658</i>&nbsp;        sumConstructors.put(ColumnType.LONG, SumLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4659</i>&nbsp;        sumConstructors.put(ColumnType.LONG256, SumLong256VectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4660</i>&nbsp;        sumConstructors.put(ColumnType.DATE, SumDateVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4661</i>&nbsp;        sumConstructors.put(ColumnType.TIMESTAMP, SumTimestampVectorAggregateFunction::new);</b>
<i class="no-highlight">4662</i>&nbsp;
<b class="fc"><i class="no-highlight">4663</i>&nbsp;        ksumConstructors.put(ColumnType.DOUBLE, KSumDoubleVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4664</i>&nbsp;        nsumConstructors.put(ColumnType.DOUBLE, NSumDoubleVectorAggregateFunction::new);</b>
<i class="no-highlight">4665</i>&nbsp;
<b class="fc"><i class="no-highlight">4666</i>&nbsp;        avgConstructors.put(ColumnType.DOUBLE, AvgDoubleVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4667</i>&nbsp;        avgConstructors.put(ColumnType.LONG, AvgLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4668</i>&nbsp;        avgConstructors.put(ColumnType.TIMESTAMP, AvgLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4669</i>&nbsp;        avgConstructors.put(ColumnType.DATE, AvgLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4670</i>&nbsp;        avgConstructors.put(ColumnType.INT, AvgIntVectorAggregateFunction::new);</b>
<i class="no-highlight">4671</i>&nbsp;
<b class="fc"><i class="no-highlight">4672</i>&nbsp;        minConstructors.put(ColumnType.DOUBLE, MinDoubleVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4673</i>&nbsp;        minConstructors.put(ColumnType.LONG, MinLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4674</i>&nbsp;        minConstructors.put(ColumnType.DATE, MinDateVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4675</i>&nbsp;        minConstructors.put(ColumnType.TIMESTAMP, MinTimestampVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4676</i>&nbsp;        minConstructors.put(ColumnType.INT, MinIntVectorAggregateFunction::new);</b>
<i class="no-highlight">4677</i>&nbsp;
<b class="fc"><i class="no-highlight">4678</i>&nbsp;        maxConstructors.put(ColumnType.DOUBLE, MaxDoubleVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4679</i>&nbsp;        maxConstructors.put(ColumnType.LONG, MaxLongVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4680</i>&nbsp;        maxConstructors.put(ColumnType.DATE, MaxDateVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4681</i>&nbsp;        maxConstructors.put(ColumnType.TIMESTAMP, MaxTimestampVectorAggregateFunction::new);</b>
<b class="fc"><i class="no-highlight">4682</i>&nbsp;        maxConstructors.put(ColumnType.INT, MaxIntVectorAggregateFunction::new);</b>
<i class="no-highlight">4683</i>&nbsp;    }
<i class="no-highlight">4684</i>&nbsp;}
</div>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
        var codeBlock = document.getElementById('sourceCode');

        if (codeBlock) {
            hljs.highlightBlock(codeBlock);
        }
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-02-16 15:46</div>
</div>
</body>
</html>

trigger: none

pr:
  branches:
    include:
      - master
      - master-ent-next
  drafts: false

variables:
  QDB_LOG_W_FILE_LOCATION: "$(Build.BinariesDirectory)/tests.log"
  ARCHIVED_LOGS: "$(Build.ArtifactStagingDirectory)/questdb-$(Build.SourceBranchName)-$(Build.SourceVersion)-$(System.StageAttempt)-$(Agent.OS)-$(jdk).zip"
  DIFF_COVER_THRESHOLD_PCT: 50
  excludeTests: ""
  includeTests: "%regex[.*[^o].class]"
  MAVEN_CACHE_FOLDER: $(HOME)/.m2/repository
  MAVEN_OPTS: "-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER) -Xmx3g -XX:+UseParallelGC"
  MAVEN_RUN_OPTS: "-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER) -Dmaven.resolver.transport=wagon -Dmaven.wagon.httpconnectionManager.ttlSeconds=30 "
  MAVEN_VERSION: "version"
  MAVEN_VERSION_OPTION: "Default"

stages:
  - stage: CheckChanges
    displayName: "Check Changes"
    jobs:
      - template: templates/check-changes-job.yml

  - stage: SelfHostedRunGriffin
    displayName: "SelfHosted Griffin And Fuzz tests"
    condition: eq(variables['System.PullRequest.IsFork'], 'false')
    dependsOn:
      - CheckChanges
    jobs:
      - template: templates/start-self-hosted-job.yml
      - template: templates/self-hosted-jobs.yml
    variables:
      includeTests: "**/griffin/**,**/cairo/**"

  - stage: SelfHostedRunOther
    displayName: "SelfHosted Other tests"
    condition: eq(variables['System.PullRequest.IsFork'], 'false')
    dependsOn:
      - CheckChanges
    jobs:
      - template: templates/start-self-hosted-job.yml
      - template: templates/self-hosted-jobs.yml
    variables:
      excludeTests: "**/griffin/**,**/cairo/**"

  - stage: HostedRunTestsBranches
    displayName: "Hosted Running tests"
    dependsOn:
      - CheckChanges
    jobs:
      - template: templates/hosted-jobs.yml

  - stage: SelfHostedRunTestsCoverageBranches
    displayName: "SelfHosted Running tests with cover"
    dependsOn:
      - CheckChanges
    jobs:
      - template: templates/self-hosted-cover-jobs.yml

  - stage: JavaAndRustLint
    displayName: "Rust Test and Lint"
    dependsOn:
      - CheckChanges
    jobs:
      - template: templates/aux-job.yml

  - stage: CoverageReports
    displayName: "Coverage Report"
    dependsOn:
      - CheckChanges
      - SelfHostedRunTestsCoverageBranches
    jobs:
      - job: CoverageReport
        displayName: "Coverage Report"
        pool:
          vmImage: "ubuntu-latest"
        variables:
          RUST_SOURCE_CODE_CHANGED: $[stageDependencies.CheckChanges.CheckChanges.outputs['check_coverage.RUST_SOURCE_CODE_CHANGED']]
          CODE_COVERAGE_TOOL_OPTION: $[stageDependencies.CheckChanges.CheckChanges.outputs['check_coverage.CODE_COVERAGE_TOOL_OPTION']]
          COVERAGE_DIFF: $[stageDependencies.CheckChanges.CheckChanges.outputs['check_coverage.COVERAGE_DIFF']]
          SHOULD_RUN: $[ and( or( eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'), eq(variables['CODE_COVERAGE_TOOL_OPTION'], 'JaCoCo') ), eq(variables['System.PullRequest.IsFork'], 'false') )]
          jdk: "1.17"

        # Coverage Job is required to run by a validation rule, but there's no point in running the steps
        # if there were no code changes. Therefore we define SHOULD_RUN and use it as a condition in all steps.
        steps:
          - checkout: self
            fetchDepth: 1
            lfs: false
            submodules: false
          - download: current
            artifact: jacoco-coverage
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['CODE_COVERAGE_TOOL_OPTION'], 'JaCoCo'))
          - download: current
            artifact: rust-llvm-coverage
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
          - script: python3 .github/prepare_rust_env.py --export-cargo-install-env --match core/rust/qdbr/rust-toolchain.toml
            displayName: "Ensure Rust is installed"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
          - template: templates/install-llvm.yml
            parameters:
              shouldRun: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
          - task: Cache@2
            continueOnError: true
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['CODE_COVERAGE_TOOL_OPTION'], 'JaCoCo'))
            inputs:
              key: '"questdb_main" | "maven"'
              path: $(MAVEN_CACHE_FOLDER)
          - task: Maven@3
            displayName: "Compile with Maven"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['CODE_COVERAGE_TOOL_OPTION'], 'JaCoCo'))
            inputs:
              mavenPomFile: "core/pom.xml"
              mavenOptions: "$(MAVEN_OPTS)"
              goals: "compile"
              options: "--batch-mode -DskipTests -Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)"
              jdkVersionOption: $(jdk)
          - task: Maven@3
            displayName: "Merge partial JaCoCo reports"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['CODE_COVERAGE_TOOL_OPTION'], 'JaCoCo'))
            inputs:
              mavenPomFile: "ci/jacoco-merge.xml"
              goals: "verify"
              options:
                "--batch-mode -Dhttp.keepAlive=false -DincludeRoot=$(Pipeline.Workspace)
                -DoutputDirectory=$(Pipeline.Workspace)/jacoco-aggregate
                -DcoverDiff=$(COVERAGE_DIFF)
                -Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)"
              jdkVersionOption: $(jdk)
          - bash: |
              set -eux
              export PATH=$LLVM_TOOLS_PATH:$PATH

              # Debug: Show LLVM tool versions
              echo "=== LLVM Tools Versions ==="
              llvm-profdata --version || echo "llvm-profdata not found"
              llvm-cov --version || echo "llvm-cov not found"
              echo ""

              # Debug: Show downloaded artifacts
              echo "=== Downloaded Rust Coverage Artifacts ==="
              ls -alR $(Pipeline.Workspace)/rust-llvm-coverage || echo "rust-llvm-coverage directory not found"
              echo ""

              # Debug: Show workspace structure
              echo "=== Pipeline Workspace Contents ==="
              find $(Pipeline.Workspace) -type f -name "*.profdata" -o -name "*.so" -o -name "*test-binary" || true
              echo ""

              # Debug: Verify required binaries exist
              echo "=== Verifying Required Binaries ==="
              if [ -f "$(Pipeline.Workspace)/rust-llvm-coverage/libquestdbr.so" ]; then
                echo "libquestdbr.so found (size: $(stat -f%z "$(Pipeline.Workspace)/rust-llvm-coverage/libquestdbr.so" 2>/dev/null || stat -c%s "$(Pipeline.Workspace)/rust-llvm-coverage/libquestdbr.so"))"
              else
                echo "libquestdbr.so NOT found"
              fi
              if [ -f "$(Pipeline.Workspace)/rust-llvm-coverage/questdbr-test-binary" ]; then
                echo "questdbr-test-binary found (size: $(stat -f%z "$(Pipeline.Workspace)/rust-llvm-coverage/questdbr-test-binary" 2>/dev/null || stat -c%s "$(Pipeline.Workspace)/rust-llvm-coverage/questdbr-test-binary"))"
              else
                echo "questdbr-test-binary NOT found"
              fi
              echo ""

              # Debug: Count and list profdata files
              echo "=== Profdata Files to Merge ==="
              PROFDATA_COUNT=$(ls -1 $(Pipeline.Workspace)/rust-llvm-coverage/*.profdata 2>/dev/null | wc -l)
              echo "Found $PROFDATA_COUNT .profdata files:"
              ls -lh $(Pipeline.Workspace)/rust-llvm-coverage/*.profdata 2>/dev/null || echo "No .profdata files found"
              echo ""

              # Merge partial profdata files into the complete report
              echo "=== Merging Profdata Files ==="
              llvm-profdata merge -sparse -v -o questdbr.profdata $(Pipeline.Workspace)/rust-llvm-coverage/*.profdata
              if [ $? -eq 0 ] && [ -f questdbr.profdata ]; then
                echo "Successfully merged profdata (size: $(stat -f%z questdbr.profdata 2>/dev/null || stat -c%s questdbr.profdata) bytes)"
              else
                echo "Failed to merge profdata files"
                exit 1
              fi
              echo ""

              # Compile the merged coverage report into an HTML report
              echo "=== Generating HTML Coverage Report ==="
              llvm-cov show \
                --format=html \
                --output-dir=rust-llvm-coverage \
                --ignore-filename-regex='(\.cargo/registry|rustc/.*\.rs)' \
                --path-equivalence=/azp/_work/1/s,$(Build.SourcesDirectory) \
                --instr-profile=questdbr.profdata \
                --object $(Pipeline.Workspace)/rust-llvm-coverage/libquestdbr.so \
                --object $(Pipeline.Workspace)/rust-llvm-coverage/questdbr-test-binary
              if [ $? -eq 0 ] && [ -d rust-llvm-coverage ]; then
                HTML_FILES=$(find rust-llvm-coverage -name "*.html" | wc -l)
                echo "Successfully generated HTML report ($HTML_FILES HTML files)"
                ls -lh rust-llvm-coverage/index.html 2>/dev/null || echo "Note: index.html not found"
              else
                echo "Failed to generate HTML coverage report"
                exit 1
              fi
              echo ""

              # Export the merged coverage report to LCOV format
              echo "=== Exporting to LCOV Format ==="
              llvm-cov export \
                --format=lcov \
                --ignore-filename-regex='(.cargo/registry|rustc/.*\.rs)' \
                --path-equivalence=/azp/_work/1/s,$(Build.SourcesDirectory) \
                --instr-profile=questdbr.profdata \
                --object $(Pipeline.Workspace)/rust-llvm-coverage/libquestdbr.so \
                --object $(Pipeline.Workspace)/rust-llvm-coverage/questdbr-test-binary \
                > questdbr.lcov.dat
              if [ $? -eq 0 ] && [ -f questdbr.lcov.dat ]; then
                LCOV_LINES=$(wc -l < questdbr.lcov.dat)
                echo "Successfully exported to LCOV (size: $(stat -f%z questdbr.lcov.dat 2>/dev/null || stat -c%s questdbr.lcov.dat) bytes, $LCOV_LINES lines)"
              else
                echo "Failed to export to LCOV format"
                exit 1
              fi
              echo ""

              # Convert LCOV coverage results to Cobertura XML format
              echo "=== Converting to Cobertura XML ==="
              # https://www.collabora.com/news-and-blog/blog/2021/03/24/rust-integrating-llvm-source-base-code-coverage-with-gitlab/
              curl -LsSf https://astral.sh/uv/install.sh | sh
              uv run --with lcov_cobertura python3 -m lcov_cobertura \
                  questdbr.lcov.dat \
                  --output cobertura.xml \
                  --base-dir core/rust/qdbr/src
              if [ $? -eq 0 ] && [ -f cobertura.xml ]; then
                echo "Successfully converted to Cobertura XML (size: $(stat -f%z cobertura.xml 2>/dev/null || stat -c%s cobertura.xml) bytes)"
                head -n 5 cobertura.xml
              else
                echo "Failed to convert to Cobertura XML"
                exit 1
              fi
              echo ""

              echo "=== Coverage Generation Complete ==="
              echo "Generated artifacts:"
              ls -lh questdbr.profdata questdbr.lcov.dat cobertura.xml 2>/dev/null
              echo "HTML report location: rust-llvm-coverage/"
            displayName: "Merge partial Rust reports"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))

          - task: PublishBuildArtifacts@1
            displayName: "Publish Rust Coverage Reports"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
            continueOnError: true
            inputs:
              PathtoPublish: '$(Build.SourcesDirectory)/rust-llvm-coverage'
              ArtifactName: 'rust-coverage-html'
              publishLocation: 'Container'

          - task: PublishBuildArtifacts@1
            displayName: "Publish Cobertura XML"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
            continueOnError: true
            inputs:
              PathtoPublish: '$(Build.SourcesDirectory)/cobertura.xml'
              ArtifactName: 'rust-cobertura-xml'
              publishLocation: 'Container'

          - task: PublishBuildArtifacts@1
            displayName: "Publish Merged Profdata"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
            continueOnError: true
            inputs:
              PathtoPublish: '$(Build.SourcesDirectory)/questdbr.profdata'
              ArtifactName: 'rust-merged-profdata'
              publishLocation: 'Container'

          - task: PublishBuildArtifacts@1
            displayName: "Publish LCOV Data"
            condition: and(eq(variables['SHOULD_RUN'], 'true'), eq(variables['RUST_SOURCE_CODE_CHANGED'], 'true'))
            continueOnError: true
            inputs:
              PathtoPublish: '$(Build.SourcesDirectory)/questdbr.lcov.dat'
              ArtifactName: 'rust-lcov-data'
              publishLocation: 'Container'

          - bash: |
              set -eux
              COVER_ARGS=""
              for f in "$(Pipeline.Workspace)/jacoco-aggregate/jacoco.xml"; do
                [ -f "$f" ] && COVER_ARGS="-type jacoco --cover $f"
              done
              [ -f cobertura.xml ] && COVER_ARGS="$COVER_ARGS -type cobertura --cover cobertura.xml"

              $JAVA_HOME_17_X64/bin/java -jar \
                $(Build.SourcesDirectory)/ci/cover-checker-1.5.0-all.jar \
                $COVER_ARGS --repo "questdb/questdb" --pr $(System.PullRequest.PullRequestNumber) \
                -t $(DIFF_COVER_THRESHOLD_PCT) --github-token $(GH_TOKEN)
            displayName: "Post combined report to GitHub"
            condition: eq(variables['SHOULD_RUN'], 'true')

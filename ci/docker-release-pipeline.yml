trigger:
  branches:
    exclude:
      - "*"
  tags:
    include:
      - '*.*.*'

pr: none

schedules:
  - cron: "0 0 * * *"
    displayName: Midnight Trigger
    branches:
      include:
        - master

# Define variable at the top level
variables:
  SKIP_VALIDATION: 'false'  # Set to 'true' to skip validation

pool:
  vmImage: 'ubuntu-20.04'

jobs:
  - job: RunOn
    displayName: "Build and push docker"

    pool:
      name: "Azure Pipelines"
      vmImage: "ubuntu-latest"

    timeoutInMinutes: 60

    steps:
      - bash: |
          tag=$(Build.SourceBranchName)
          echo "Checking tag: $tag"
          
          if [[ ! $tag =~ ^\d+(\.\d+)*$ ]]; then
            echo "Tag '$tag' is not a pure numeric version (x.y.z) - skipping build"
            echo "Valid tags should only contain numbers and dots (e.g., 1.2.3, 10.0.5)"
            echo "##vso[task.complete result=Succeeded;]Skipping build for non-numeric version tag"
            exit 0
          fi
          
          echo "Tag '$tag' is a valid numeric version, continuing with build"
        displayName: 'Validate semantic version format'
        condition: and(startsWith(variables['Build.SourceBranch'], 'refs/tags/'), ne(variables['SKIP_VALIDATION'], 'true'))

      - task: CmdLine@2
        displayName: Install Trivy vulnerability scanner
        inputs:
          script: |
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh -o /tmp/install-trivy.sh
            sh /tmp/install-trivy.sh -b /usr/local/bin

      - task: CmdLine@2
        displayName: Download latest openshift-preflight tool
        inputs:
          script: |
            wget https://github.com/redhat-openshift-ecosystem/openshift-preflight/releases/latest/download/preflight-linux-amd64 -O /usr/local/bin/preflight
            chmod +x /usr/local/bin/preflight
            which preflight

      - task: Docker@2
        inputs:
          command: 'login'
          containerRegistry: serviceaccountquestdb

      - task: CmdLine@2
        displayName: Setup docker buildx
        inputs:
          script: |
            docker run --privileged --rm tonistiigi/binfmt --install arm64
            docker run --privileged --rm tonistiigi/binfmt
            docker buildx create --use

      - task: CmdLine@2
        displayName: Release Nightly MASTER
        inputs:
          script: |
            docker buildx build --platform linux/amd64,linux/arm64 --push -t questdb/questdb:nightly .
            docker buildx build --platform linux/amd64,linux/arm64 --push -t questdb/questdb:nightly-rhel --target rhel  .
            preflight check container questdb/questdb:nightly-rhel
          workingDirectory: core
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))

      - task: CmdLine@2
        displayName: Scan nightly docker image for vulnerabilities
        inputs:
          script: |
            echo "Scanning image: questdb/questdb:nightly"
            trivy image --exit-code 1 --severity HIGH,CRITICAL questdb/questdb:nightly

            echo "Scanning image: questdb/questdb:nightly-rhel"
            trivy image --exit-code 1 --severity HIGH,CRITICAL questdb/questdb:nightly-rhel
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))

      - task: CmdLine@2
        displayName: Release Tag
        inputs:
          script: |
            # Cannot use Build.SourceBranchName if a tag name contains a "/", since the var only returns the final path component
            # We use cut instead to trim the first 2 components off the Build.SourceBranch ("refs/tags")
            tag_name=$(echo "$(Build.SourceBranch)" | cut -d'/' -f '3-')
            echo $tag_name
            pattern='^[0-9]+\.[0-9]+\.[0-9]+$'
            if [[ "$tag_name" =~ $pattern ]]; then
              echo "labeling latest"
              docker buildx build --build-arg tag_name=$tag_name --platform linux/amd64,linux/arm64 --push -t questdb/questdb:$tag_name -t questdb/questdb:latest .
            else
              echo "NOT labeling latest"
              docker buildx build --build-arg tag_name=$tag_name --platform linux/amd64,linux/arm64 --push -t questdb/questdb:$tag_name .
            fi
            docker buildx build --build-arg tag_name=$tag_name --platform linux/amd64,linux/arm64 --push -t questdb/questdb:$tag_name-rhel --target rhel  .
            preflight check container questdb/questdb:$tag_name-rhel
          workingDirectory: core
        condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))

      - task: CmdLine@2
        displayName: Scan tagged docker image for vulnerabilities
        inputs:
          script: |
            tag_name=$(echo "$(Build.SourceBranch)" | cut -d'/' -f '3-')

            echo "Scanning image: questdb/questdb:${tag_name}"
            trivy image --exit-code 1 --severity HIGH,CRITICAL "questdb/questdb:${tag_name}"

            echo "Scanning image: questdb/questdb:${tag_name}-rhel"
            trivy image --exit-code 1 --severity HIGH,CRITICAL "questdb/questdb:${tag_name}-rhel"
        condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))

      - task: CmdLine@2
        displayName: Release Commit from Branch
        inputs:
          script: |
            # Cannot use Build.SourceBranchName if a branch name contains a "/", since the var only returns the final path component
            # We use cut instead to trim the first 2 components off the Build.SourceBranch ("refs/heads")
            tag_name=$(echo "$(Build.SourceBranch)" | cut -d'/' -f '3-')
            echo $tag_name
            # Docker tags are prefixed with "patch-" and use the short commit hash
            docker_tag_name=patch-$(echo $(Build.SourceVersion) | cut -c 1-7)
            echo $docker_tag_name
            docker buildx build --build-arg tag_name=$tag_name --platform linux/amd64,linux/arm64 --push -t questdb/questdb:${docker_tag_name} .
            docker buildx build --build-arg tag_name=$tag_name --platform linux/amd64,linux/arm64 --push -t questdb/questdb:${docker_tag_name}-rhel --target rhel .
            preflight check container questdb/questdb:${docker_tag_name}-rhel
          workingDirectory: core
        condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/heads/'), ne(variables['Build.SourceBranch'], 'refs/heads/master'))

      - task: CmdLine@2
        displayName: Scan branch docker image for vulnerabilities
        inputs:
          script: |
            docker_tag_name=patch-$(echo $(Build.SourceVersion) | cut -c 1-7)

            echo "Scanning image: questdb/questdb:${docker_tag_name}"
            trivy image --exit-code 1 --severity HIGH,CRITICAL "questdb/questdb:${docker_tag_name}"

            echo "Scanning image: questdb/questdb:${docker_tag_name}-rhel"
            trivy image --exit-code 1 --severity HIGH,CRITICAL "questdb/questdb:${docker_tag_name}-rhel"
        condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/heads/'), ne(variables['Build.SourceBranch'], 'refs/heads/master'))

      - task: CmdLine@2
        displayName: Notify Slack on Failure
        inputs:
          script: |
            curl -X POST -H 'Content-type: application/json' \
              --data '{"text":"ðŸš¨ *Docker Build Failed (OSS)*\n\nBranch: `$(Build.SourceBranchName)`\nBuild: <$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)|#$(Build.BuildId)>\nCommit: `$(Build.SourceVersion)`"}' \
              "$(BUILDS_SLACK_HOOK_URL)"
        condition: failed()
        env:
          BUILDS_SLACK_HOOK_URL: $(BUILDS_SLACK_HOOK_URL)
